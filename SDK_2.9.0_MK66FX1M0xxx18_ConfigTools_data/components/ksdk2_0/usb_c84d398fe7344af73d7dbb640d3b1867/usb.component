<?xml version="1.0" encoding= "UTF-8" ?>
<component:config_component xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://swtools.freescale.net/XSD/component/1.0 http://swtools.freescale.net/XSD/component/1.0/component-6.0.xsd"
    xmlns:component="http://swtools.freescale.net/XSD/component/1.0" id="usb" label="USB" category="Middleware">
    <migrations>
        <migration_component id="usb_210" component_type="usb">
            <sw_comp_ref name="middleware.usb.stack_common" version="2.1.0"/>
        </migration_component>
        <migration_component id="usb_220" component_type="usb">
            <sw_comp_ref name="middleware.usb.stack_common" version="2.2.0"/>
        </migration_component>
    </migrations>
    <sw_comp_ref name="middleware.usb.common_header" version="2.6.0"/>
    <description>Universal Serial Bus (USB)</description>
    <mode id="device" label="Device">
        <description>USB device configuration</description>
        <config_set_refs>
            <config_set_ref>deviceSetting</config_set_ref>
        </config_set_refs>
        <master_peripheral>
            <peripheral_type>USB</peripheral_type>
            <peripheral_type>USBHS</peripheral_type>
            <peripheral_type>USBHSD</peripheral_type>
        </master_peripheral>
    </mode>
    <mode id="host" label="Host">
        <description>USB device configuration</description>
        <config_set_refs>
            <config_set_ref>hostSettings</config_set_ref>
        </config_set_refs>
        <master_peripheral>
            <peripheral_type>USB</peripheral_type>
            <peripheral_type>USBHS</peripheral_type>
            <peripheral_type>USBFSH</peripheral_type>
            <peripheral_type>USBHSH</peripheral_type>
        </master_peripheral>
    </mode>
    <script file="usb_codegenerator.js"/>
    <user_functions>
        <function_def id="packetSizeLowerThan128">
            (ep) -> (ep.getSetting(`max_packet_size_hs`).getValue() == `k0`) || (ep.getSetting(`max_packet_size_hs`).getValue() == `k8`) || (ep.getSetting(`max_packet_size_hs`).getValue() == `k16`) || (ep.getSetting(`max_packet_size_hs`).getValue() == `k32`) || (ep.getSetting(`max_packet_size_hs`).getValue() == `k64`)
        </function_def>
        <function_def id="validateName">
            x -> x.regexMatch(`\s*[A-Za-z_][0-9A-Za-z_\s]*`)
        </function_def>
        <function_def id="calculateEndpointNumberByDirection">
            (arrayOfEndpoints, endpointIndex, endpointDirection, startingNumber) -> arrayOfEndpoints.reduce(
                startingNumber,
                (acc, endpoint) -> acc + (((endpointIndex &lt; 0) || (endpoint.getId().toInt() &lt;= endpointIndex))
                    ? (endpoint.getSetting(`direction`).getValue() == endpointDirection
                        ? 1 : 0) : 0))
        </function_def>
        <function_def id="checkEndpoint">
            (endpoint, transferType, endpointDirection) -> (endpoint.getSetting(`transfer_type`).getEnumItemId() == transferType) &amp;&amp; (endpoint.getSetting(`direction`).getEnumItemId() == endpointDirection)
        </function_def>
        <function_def id="checkEndpointDirectionSymmetry">
            arrayOfEndpoints -> arrayOfEndpoints.reduce(
                0,
                (acc, endpoint) -> (endpoint.getSetting(`direction`).getEnumItemId() == `kIn`) ? acc + 1 : ((endpoint.getSetting(`direction`).getEnumItemId() == `kOut`) ? acc - 1 : acc)
                ) == 0
        </function_def>
        <function_def id="countDataTransmissionInterfaces">
            (arrayOfInterfaces, interfaceIndex, interfaceCount) -> arrayOfInterfaces.reduce(
                0,
                (acc, interface) -> acc + (((interface.getSetting(`interface_class`).getEnumItemId() == `kClassDic`) &amp;&amp; (interface.getId().toInt() &gt; interfaceIndex) &amp;&amp; (interface.getId().toInt() &lt;= (interfaceIndex + interfaceCount)))
                    ? 1 : 0)) 
        </function_def>
        <function_def id="endpointCount">
            () -> $instance.getPeripheral() == `USB0` ? fsEndpointCount() : hsEndpointCount() 
        </function_def>
        <function_def id="enumerateSucceedingInterfaceKeys">
            (arrayOfInterfaces, interfaceIndex, interfaceCount) -> arrayOfInterfaces.reduce(
                toArray(),
                (acc, interface) -> acc.merge(((interface.getId().toInt() &gt; interfaceIndex) &amp;&amp; (interface.getId().toInt() &lt;= (interfaceIndex + interfaceCount)))
                    ? interface.generateInterfaceKey().toArray() : toArray())) 
        </function_def>
        <function_def id="fsEndpointCount">
            () -> (featureDefined(`USB_ENDPT_COUNT`)
                ? getFeature(`USB_ENDPT_COUNT`) : (featureDefined(`USB_EP_NUM`)
                    ? getFeature(`USB_EP_NUM`) : 0)) - 1
        </function_def>
        <function_def id="generateSettingKey">
            setting -> `#` + setting.getId() + ` ` + setting.getSetting(`setting_name`).getValue()
        </function_def>
        <function_def id="generateEndpointKey">
            ep -> ep.getSetting(`direction`).getValue() == `kIn` ? calculateCurrentEpNumber(`kIn`, ep.getParent(), getStartingNumber(`starting_in_ep_nr`, ep.getParent()), ep.getId().toInt()) : calculateCurrentEpNumber(`kOut`, ep.getParent(), getStartingNumber(`starting_out_ep_nr`, ep.getParent()), ep.getId().toInt())
        </function_def>
        <function_def id="generateInterfaceKey">
            interface -> `#` + interface.getId() + ` ` + interface.getSelectedInterface().getSetting(`interface_name`).getValue()
        </function_def>
        <function_def id="getConfiguredEndpointsCount">
            (starting_var, count_var) -> $configSet.interfaces.getLast().getSelectedInterface().getSetting(starting_var).getValue() - 1 + $configSet.interfaces.getLast().getSelectedInterface().getSetting(count_var).getValue()
        </function_def>
        <function_def id="getConfiguredInEndpointsCount">
            () -> getConfiguredEndpointsCount(`starting_in_ep_nr`, `in_ep_count`)
        </function_def>
        <function_def id="getConfiguredOutEndpointsCount">
            () -> getConfiguredEndpointsCount(`starting_out_ep_nr`, `out_ep_count`)
        </function_def>
        <function_def id="getSelectedInterface">
            interface -> ((interface.getSetting(`interface_class`).getEnumItemId() == `kClassCic`) 
                ? interface.getSetting(`setting_cic`) 
                : ((interface.getSetting(`interface_class`).getEnumItemId() == `kClassDic`) 
                ? interface.getSetting(`setting_dic`) 
                : ((interface.getSetting(`interface_class`).getEnumItemId() == `kClassHid`)
                ? interface.getSetting(`setting_hid`) 
                : ((interface.getSetting(`interface_class`).getEnumItemId() == `kClassMsc`)
                ? interface.getSetting(`setting_msc`) 
                : ((interface.getSetting(`interface_class`).getEnumItemId() == `kClassPrinter`)
                ? interface.getSetting(`setting_printer`) 
                : ((interface.getSetting(`interface_class`).getEnumItemId() == `kClassPhdc`)
                ? interface.getSetting(`setting_phdc`) 
                : ((interface.getSetting(`interface_class`).getEnumItemId() == `kClassAudio_1_0`)
                ? interface.getSetting(`setting_audio_1_0`) 
                : ((interface.getSetting(`interface_class`).getEnumItemId() == `kClassAudio_2_0`)
                ? interface.getSetting(`setting_audio_2_0`) 
                : ((interface.getSetting(`interface_class`).getEnumItemId() == `kClassAudioHost`)
                ? interface.getSetting(`setting_audiohost`)
                : (interface.getSetting(`interface_class`).getEnumItemId() == `kClassDfu`)
                ? interface.getSetting(`setting_dfu`)
                : `FALLBACK`)))))))))
        </function_def>
        <function_def id="hsEndpointCount">
            () -> (featureDefined(`USBHS_ENDPT_COUNT`)
            ? getFeature(`USBHS_ENDPT_COUNT`) : (featureDefined(`USBHSD_EP_NUM`)
            ? getFeature(`USBHSD_EP_NUM`) : 0)) - 1
        </function_def>
        <function_def id="isFsEndpointCountKnown">
            () -> featureDefined(`USB_ENDPT_COUNT`) || featureDefined(`USB_EP_NUM`)
        </function_def>
        <function_def id="isHsEndpointCountKnown">
            () -> featureDefined(`USBHS_ENDPT_COUNT`) || featureDefined(`USBHSD_EP_NUM`)
        </function_def>
        <function_def id="isEndpointCountKnown">
            () -> $instance.getPeripheral() == `USB0` ? isFsEndpointCountKnown() : isHsEndpointCountKnown() 
        </function_def>
        <function_def id="isStandaloneDataTransmissionInterface">
            (arrayOfInterfaces, interfaceIndex) -> (arrayOfInterfaces.reduce(
                0,
                (acc, interface) -> acc + (((interface.getSetting(`interface_class`).getEnumItemId() == `kClassDic`) &amp;&amp; (interface.getId().toInt() &lt;= interfaceIndex))
                    ? 1 : 0)) - arrayOfInterfaces.reduce(
                        0,
                        (acc, interface) -> acc + (((interface.getSetting(`interface_class`).getEnumItemId() == `kClassCic`) &amp;&amp; (interface.getId().toInt() &lt;= interfaceIndex))
                            ? interface.getSetting(`setting_cic`).getSetting(`data_interface_count`).getValue() : 0))) &gt; 0
        </function_def>
        <function_def id="isLpcUsbController">
            () -> featureDefined(`USB_EP_NUM`) || featureDefined(`USBHSD_EP_NUM`)
        </function_def>
        <function_def id="countEndpoints">
            (arrayOfEndpoints, transferType, endpointDirection) -> arrayOfEndpoints.reduce(
            0,
            (acc, endpoint) -> acc + (endpoint.checkEndpoint(transferType, endpointDirection) ? 1 : 0))
        </function_def>
        <function_def id="getPhdcImplementation">
            () -> ($instance.getMode() == `device`) ? `kImplementationWeightScale` : `kImplementationManager`
        </function_def>
        <function_def id="isIeee11073TypesRequired">
            (arrayOfInterfaces) -> arrayOfInterfaces.reduce(false, (requireTypes, interface) -> requireTypes || (interface.getSelectedInterface().getSetting(`implementation`).getValue() == getPhdcImplementation()))
        </function_def>
        <function_def id="getConfigSet">
            (component, mode) -> mode == `device` ? component.getSetting(`deviceSetting`) : component.getSetting(`hostSettings`)
        </function_def>
        <function_def id="isUsbMode">
            (component, mode) -> (component.getParent().getId() == `usb`) &amp;&amp; (component.getMode() == mode)
        </function_def>
        <function_def id="hasComponentPhdc">
            (component, mode) -> component.getConfigSet(mode).getSetting(`interfaces`).reduce(false, (instanceHasPhdc, interface) -> instanceHasPhdc || interface.getSetting(`interface_class`).getValue() == `kClassPhdc`)
        </function_def>
        <function_def id="hasInterface">
            (interfaces, interfaceClass) -> interfaces.reduce(false, (instanceHasDfu, interface) -> instanceHasDfu || interface.getSetting(`interface_class`).getValue() == interfaceClass)
        </function_def>
        <function_def id="hasModePhdc">
            (mode) -> $root.reduce(false, (hasPhdc, group) -> hasPhdc || (group.countOccurrences(component -> (component.isEnabled() &amp;&amp; component.isUsbMode(mode) &amp;&amp; component.hasComponentPhdc(mode))) &gt; 0))
        </function_def>
        <function_def id="isIeee11073TypesRequiredInMode">
            (mode) -> $root.reduce(false, (required, group) -> required || (group.countOccurrences(component -> (component.isEnabled() &amp;&amp; component.isUsbMode(mode) &amp;&amp; component.getConfigSet(mode).getSetting(`ieee11073TypesRequired`).getValue())) &gt; 0))
        </function_def>
        <function_def id="getPrevInterfaceTopEpInNumber">
            (prevInterfaceSetting) -> prevInterfaceSetting.getSetting(`starting_in_ep_nr`).getValue() + prevInterfaceSetting.getSetting(`in_ep_count`).getValue()
        </function_def>
        <function_def id="getPrevInterfaceTopEpOutNumber">
            (prevInterfaceSetting) -> prevInterfaceSetting.getSetting(`starting_out_ep_nr`).getValue() + prevInterfaceSetting.getSetting(`out_ep_count`).getValue()
        </function_def>
        <function_def id="getStartingInEpNumber">
            (interfaces, interfaceIndex) -> interfaceIndex == 0 ? 1 : getPrevInterfaceTopEpInNumber(interfaces.get(interfaceIndex - 1).getSelectedInterface())
        </function_def>
        <function_def id="getStartingOutEpNumber">
            (interfaces, interfaceIndex) -> interfaceIndex == 0 ? 1 : getPrevInterfaceTopEpOutNumber(interfaces.get(interfaceIndex - 1).getSelectedInterface())
        </function_def>
        <function_def id="getEndpointsCount">
            (endpointsSetting, direction) -> endpointsSetting.getSetting(`endpoints`).countOccurrences(ep -> ep.getSetting(`direction`).getValue() == direction)
        </function_def>
        <function_def id="calculateCurrentEpNumber">
            (direction, endpointsSetting, startingNr, currentIndex) -> startingNr + endpointsSetting.countOccurrences(ep -> (ep.getId().toInt() &lt; currentIndex) &amp;&amp; (ep.getSetting(`direction`).getValue() == direction))
        </function_def>
        <function_def id="getStartingNumber">
            (startingNrVariable, epParent) -> epParent.getParent().getParent().getParent().getSetting(startingNrVariable).getValue()
        </function_def>
        <function_def id="isFirstSetting">
            () -> $parent.getId().toInt() &lt; 1
        </function_def>
        <function_def id="getImplementationFromEpSettings">
            () -> $parent.getParent().getParent().getSetting(`implementation`).getEnumItemId()
        </function_def>
        <function_def id="getProtocolFromEpSettings">
            () -> $parent.getParent().getParent().getSetting(`protocol`).getEnumItemId()
        </function_def>
        <function_def id="isSomeImplementationSelectedFromEpsSettings">
            () -> $parent.implementation.getEnumItemId() != `kImplementationNone`
        </function_def>
        <!-- Function for checking a valid integer value and its range. The value is passsed as a string.
             Parameters:
                i - integer value as a string
                min - minimum value
                max - maximum value
         -->
        <function_def id="isValidIntegerValue">
            (i, min, max) -> (i.regexMatch(system::decHexNumRegExpr()) &amp;&amp; (i.toInt() &gt;= min) &amp;&amp; (i.toInt() &lt;= max)) 
        </function_def>
        <!-- Function return the audion unit/terminal ID of the audio unit node
            Paremeters:
                node - node that represent an audio unit 1.0
         -->
        <function_def id="getAudioUnitID">
            (node) -> (
            (node.getSetting(`audio_unit`).getValue() == `kInputTerminal`)
            ? node.getSetting(`input_terminal.bTerminalID`).getValue()
            : (node.getSetting(`audio_unit`).getValue() == `kOutputTerminal`)
            ? node.getSetting(`output_terminal.bTerminalID`).getValue()
            : node.getSetting(`feature_unit.bUnitID`).getValue()
            )     
        </function_def>
        <function_def id="checkPreviousClasses">
        (interfaces, thisInter) -> (interfaces.noneMatch(x -> (x.getId().toInt() &lt; thisInter.getParent().getId().toInt()) &amp;&amp; (x.getSetting(`interface_class`).getValue() == thisInter.getValue())))
        </function_def>
    </user_functions>
    <config_set id="commonSettings" label="Common role">
        <description>Common mode settings</description>
        <generated_types/>
        <user_types>
            <enum id="interface_class_t" label="USB class" from="_class">
                <item id="kClassDfu" label="Application Specific" value="Dfu" available="$this.getMode() == `device`"/>
                <item id="kClassCic" label="CIC" value="Cic"/>
                <item id="kClassDic" label="DIC" value="Dic"/>
                <item id="kClassHid" label="HID" value="Hid"/>
                <item id="kClassMsc" label="MSC" value="Msc" available="$this.getMode() == `device`"/>
                <item id="kClassPhdc" label="PHDC" value="Phdc"/>
                <item id="kClassPrinter" label="Printer" value="Printer"/>
                <item id="kClassAudio_1_0" label="Audio 1.0" value="Audio" available="$this.getMode() == `device`"/>
                <item id="kClassAudio_2_0" label="Audio 2.0" value="Audio20" available="$this.getMode() == `device`"/>
                <item id="kClassAudioHost" label="Audio" value="AudioHost" available="$this.getMode() == `host`"/>
            </enum>
            <enum id="subclass_cic_t" from="_subclass_cic">
                <item id="kSubclassAcm" label="Abstract Control Model"/>
            </enum>
            <enum id="protocol_cic_t" from="_protocol_cic">
                <item id="kProtocolNone" label="None"/>
            </enum>
            <enum id="subclass_dic_t" from="_subclass_dic">
                <item id="kSubclassNone" label="None"/>
            </enum>
            <enum id="protocol_dic_t" from="_protocol_dic">
                <item id="kProtocolNone" label="None"/>
            </enum>
            <enum id="subclass_hid_t" from="_subclass_hid">
                <item id="kSubclassBootInterface" label="Boot Interface"/>
            </enum>
            <enum id="protocol_hid_t" from="_protocol_hid">
                <item id="kProtocolNone" label="None"/>
                <item id="kProtocolMouse" label="Mouse"/>
                <item id="kProtocolKeyboard" label="Keyboard"/>
            </enum>
            <enum id="subclass_msc_t" from="_subclass_msc">
                <item id="kSubclassScsi" label="SCSI transparent command set"/>
            </enum>
            <enum id="subclass_appspecific_t" from="_subclass_dfu">
                <item id="kSubclassDfu" label="Device Firmware Upgrade"/>
            </enum>
            <enum id="protocol_msc_t" from="_protocol_msc">
                <item id="kProtocolBbb" label="BBB (bulk-only transport)"/>
            </enum>
            <enum id="protocol_dfu_t" from="_protocol_dfu">
                <item id="kProtocolAppIdle" label="DFU: app-idle">
                    <description>Device starts and enumerates as a composite device, the DFU process is supposed to be enabled by switching mode to dfu-mode. Switching is done by software for dfu communication. This switching is followed by re-enumeration, after which this device acts as dfu-only device with no other interface.</description>
                </item>
                <item id="kProtocolDfuIdle" label="DFU: dfu-idle">
                    <description>Device starts directly in dfu-mode and can start to preform dfu operations right away. Adding another interfaces is not recommended for such device.</description>
                </item>
            </enum>
            <enum id="subclass_phdc_t" from="_subclass_phdc">
                <item id="kSubclassNone" label="None"/>
            </enum>
            <enum id="protocol_phdc_t" from="_protocol_phdc">
                <item id="kProtocolNone" label="None"/>
            </enum>
            <enum id="subclass_printer_t" from="_subclass_printer">
                <item id="kSubclassPrinters" label="Printers"/>
            </enum>
            <enum id="protocol_printer_t" from="_protocol_printer">
                <item id="kProtocolBiDirectional" label="Bi-directional interface"/>
            </enum>
            <struct id="report_descriptor_entry_t">
                <reference id="type" type="report_descriptor_item_t" label="HID item"/>
                <integer id="value" type="int32_t" label="Value" available="$parent.intType.getValue() != `N/A`">
                    <description>Negative values can be entered in decimal format or in 32-bit hexadecimal format, even if the minimum value requires less bits. E.g. when a value range is limited to 8bit number, -128 must be entered either as -128 or as 0xFFFFFF80. The generated value is optimized for the lowest possible number of bits.</description>
                    <validation>
                        <constraint when_expr="$parent.intType.getValue() == `uint`" cond_expr="($this.getValue() &gt;= 0) &amp;&amp; ($this.getValue() &lt;= $parent.maxValue.getValue())" level="error" 
                            description_expr="`The value of the ` + $parent.type.getEnumItemLabel() + ` item is out of the range (0 - ` + $parent.maxValue.getValue() + `)`"/>
                        <constraint when_expr="$parent.intType.getValue() == `int`" cond_expr="($this.getValue() &gt;= (-($parent.maxValue.getValue()/2))) &amp;&amp; ($this.getValue() &lt;= (($parent.maxValue.getValue()/2)-1))" level="error" 
                            description_expr="`The value of the ` + $parent.type.getEnumItemLabel() + ` item is out of the range (-` + ($parent.maxValue.getValue()/2) + ` - ` + (($parent.maxValue.getValue()/2)-1) + `)`"/>
                    </validation>
                </integer>
                <!-- Value type mapping array: true - signed, false - unsigned -->
                <variable id="intType" value="$configSet.enumItemsOfType(`report_descriptor_features_t`).get($parent.type.getEnumItemValue().toInt()).getLabel()"/>
                <variable id="maxValue" value="$configSet.enumItemsOfType(`report_descriptor_features_t`).get($parent.type.getEnumItemValue().toInt()).getValue().toInt()"/>
                <!-- number of Bytes - bSize code (1=1byte; 2=2bytes; 3=4bytes) -->
                <variable id="bSize" value="
                    ($parent.intType.getValue() == `int`) ?
                    ((($parent.value.getValue() &lt; 2**7) &amp;&amp; ($parent.value.getValue() &gt;= -2**7)) 
                    ? 1
                    : ((($parent.value.getValue() &lt; 2**15) &amp;&amp; ($parent.value.getValue() &gt;= -2**15))
                    ? 2
                    : 3
                    ))
                    : (($parent.intType.getValue() == `uint`) ?
                    (($parent.value.getValue() &lt; 2**8) 
                    ? 1
                    : (($parent.value.getValue() &lt; 2**16)
                    ? 2
                    : 3
                    ))
                    : 0)"/>
                <!-- number of bits -->
                <variable id="sizeInBits" value="
                    ($parent.intType.getValue() == `int`) ?
                    ((($parent.value.getValue() &lt; 2**7) &amp;&amp; ($parent.value.getValue() &gt;= -2**7)) 
                    ? 8
                    : ((($parent.value.getValue() &lt; 2**15) &amp;&amp; ($parent.value.getValue() &gt;= -2**15))
                    ? 16
                    : 32
                    ))
                    : (($parent.intType.getValue() == `uint`) ?
                    (($parent.value.getValue() &lt; 2**8) 
                    ? 8
                    : (($parent.value.getValue() &lt; 2**16)
                    ? 16
                    : 32
                    ))
                    : 0)"/>
                <string id="remarks" label="Remarks"/>
            </struct>
            <enum id="report_descriptor_item_t" from="_report_descriptor_item">
                <item id="kCollection" label="Collection" value="0"/>
                <item id="kDelimiter" label="Delimiter" value="1"/>
                <item id="kDesignator_Index" label="Designator Index" value="2"/>
                <item id="kDesignator_Maximum" label="Designator Maximum" value="3"/>
                <item id="kDesignator_Minimum" label="Designator Minimum"  value="4"/>
                <item id="kEnd_Collection" label="End Collection" value="5"/>
                <item id="kFeature" label="Feature"  value="6"/>
                <item id="kInput" label="Input"  value="7"/>
                <item id="kLogical_Maximum" label="Logical Maximum" value="8"/>
                <item id="kLogical_Minimum" label="Logical Minimum"  value="9"/>
                <item id="kOutput" label="Output"  value="10"/>
                <item id="kPhysical_Maximum" label="Physical Maximum" value="11"/>
                <item id="kPhysical_Minimum" label="Physical Minimum"  value="12"/>
                <item id="kPop" label="Pop"  value="13"/>
                <item id="kPush" label="Push"  value="14"/>
                <item id="kReport_Count" label="Report Count" value="15"/>
                <item id="kReport_Id" label="Report Id" value="16"/>
                <item id="kReport_Size" label="Report Size"  value="17"/>
                <item id="kString_Index" label="String Index" value="18"/>
                <item id="kString_Maximum" label="String Maximum"  value="19"/>
                <item id="kString_Minimum" label="String Minimum"  value="20"/>
                <item id="kUnit" label="Unit"  value="21"/>
                <item id="kUnit_Exponent" label="Unit Exponent" value="22"/>
                <item id="kUsage" label="Usage"  value="23"/>
                <item id="kUsage_Maximum" label="Usage Maximum" value="24"/>
                <item id="kUsage_Minimum" label="Usage Minimum" value="25"/>
                <item id="kUsage_Page" label="Usage Page" value="26"/>
            </enum>
            <enum id="direction_t" from="_direction">
                <item id="kIn" label="In"/>
                <item id="kOut" label="Out"/>
            </enum>
            <enum id="control_max_packet_size_fs_t" from="_control_max_packet_size_fs_t">
                <item id="k0" label="0" value="0"/>
                <item id="k8" label="8" value="8"/>
                <item id="k16" label="16" value="16"/>
                <item id="k32" label="32" value="32"/>
                <item id="k64" label="64" value="64"/>
            </enum>
            <enum id="bulk_max_packet_size_fs_t" from="_bulk_max_packet_size_fs_t">
                <item id="k0" label="0" value="0"/>
                <item id="k8" label="8" value="8"/>
                <item id="k16" label="16" value="16"/>
                <item id="k32" label="32" value="32"/>
                <item id="k64" label="64" value="64"/>
            </enum>
            <enum id="interrupt_max_packet_size_fs_t" from="_interrupt_max_packet_size_fs_t">
                <item id="k0" label="0" value="0"/>
                <item id="k8" label="8" value="8"/>
                <item id="k16" label="16" value="16"/>
                <item id="k32" label="32" value="32"/>
                <item id="k64" label="64" value="64"/>
            </enum>
            <enum id="isochronous_max_packet_size_fs_t" from="_isochronous_max_packet_size_fs_t">
                <item id="k0" label="0" value="0"/>
                <item id="k8" label="8" value="8"/>
                <item id="k16" label="16" value="16"/>
                <item id="k32" label="32" value="32"/>
                <item id="k64" label="64" value="64"/>
                <item id="k128" label="128" value="128"/>
                <item id="k256" label="256" value="256"/>
                <item id="k512" label="512" value="512"/>
                <item id="k1023" label="1023" value="1023"/>
            </enum>
            <enum id="control_max_packet_size_hs_t" from="_control_max_packet_size_hs_t">
                <item id="k0" label="0" value=""/>
                <item id="k64" label="64" value=""/>
            </enum>
            <enum id="bulk_max_packet_size_hs_t" from="_bulk_max_packet_size_hs_t">
                <item id="k0" label="0" value="0"/>
                <item id="k8" label="8" value="8"/>
                <item id="k16" label="16" value="16"/>
                <item id="k32" label="32" value="32"/>
                <item id="k64" label="64" value="64"/>
                <item id="k128" label="128" value="128"/>
                <item id="k256" label="256" value="256"/>
                <item id="k512" label="512" value="512"/>
            </enum>
            <enum id="interrupt_max_packet_size_hs_t" from="_interrupt_max_packet_size_hs_t">
                <item id="k0" label="0" value="0"/>
                <item id="k8" label="8" value="8"/>
                <item id="k16" label="16" value="16"/>
                <item id="k32" label="32" value="32"/>
                <item id="k64" label="64" value="64"/>
                <item id="k128" label="128" value="128"/>
                <item id="k256" label="256" value="256"/>
                <item id="k512" label="512" value="512"/>
                <item id="k1024" label="1024" value="1024"/>
            </enum>
            <enum id="isochronous_max_packet_size_hs_t" from="_isochronous_max_packet_size_hs_t">
                <item id="k0" label="0" value="0"/>
                <item id="k8" label="8" value="8"/>
                <item id="k16" label="16" value="16"/>
                <item id="k32" label="32" value="32"/>
                <item id="k64" label="64" value="64"/>
                <item id="k128" label="128" value="128"/>
                <item id="k256" label="256" value="256"/>
                <item id="k512" label="512" value="512"/>
                <item id="k1024" label="1024" value="1024"/>
            </enum>
            <enum id="transfer_type_t" from="_transfer_type">
                <item id="kBulk" label="Bulk" 
                    available=" $parent.getParent().getParent().getParent().getParent().getParent().getSetting(`interface_class`).getValue() != `kClassHid`"/>
                <item id="kControl" label="Control" 
                    available=" $parent.getParent().getParent().getParent().getParent().getParent().getSetting(`interface_class`).getValue() != `kClassPhdc` &amp;&amp; 
                                $parent.getParent().getParent().getParent().getParent().getParent().getSetting(`interface_class`).getValue() != `kClassPrinter` &amp;&amp; 
                                $parent.getParent().getParent().getParent().getParent().getParent().getSetting(`interface_class`).getValue() != `kClassDic` &amp;&amp; 
                                !isLpcUsbController()"/>
                <item id="kInterrupt" label="Interrupt" 
                    available=" $parent.getParent().getParent().getParent().getParent().getParent().getSetting(`interface_class`).getValue() != `kClassDic` &amp;&amp; 
                                $parent.getParent().getParent().getParent().getParent().getParent().getSetting(`interface_class`).getValue() != `kClassPrinter`"/>
                <item id="kIsochronous" label="Isochronous" 
                    available=" $parent.getParent().getParent().getParent().getParent().getParent().getSetting(`interface_class`).getValue() != `kClassHid` &amp;&amp; 
                                $parent.getParent().getParent().getParent().getParent().getParent().getSetting(`interface_class`).getValue() != `kClassPhdc` &amp;&amp; 
                                $parent.getParent().getParent().getParent().getParent().getParent().getSetting(`interface_class`).getValue() != `kClassMsc` &amp;&amp; 
                                $parent.getParent().getParent().getParent().getParent().getParent().getSetting(`interface_class`).getValue() != `kClassPrinter`"/>
            </enum>
            <enum id="synchronization_type_t" from_source="_isonchronous_endpoint">
                <item id="kNoSynchronization" label="No synchronization" value="0">
                    <description>No synchronization is provided.</description>
                </item>
                <item id="kAsynchronous" label="Asynchronous" value="USB_ENDPOINT_ISOCHRONOUS_ASYNCHRONOUS">
                    <description>Unsynchronized, although sinks provide data rate feedback.</description>
                </item>
                <item id="kSynchronous" label="Synchronous" value="USB_ENDPOINT_ISOCHRONOUS_SYNCHRONOUS">
                    <description>Synchronized to the USB’s SOF</description>
                </item>
                <item id="kAdaptive" label="Adaptive" value="USB_ENDPOINT_ISOCHRONOUS_ADAPTIVE">
                    <description>Synchronized using feedback or feedforward data rate information</description>
                </item>
            </enum>
            <enum id="usage_type_t" from_source="_isonchronous_endpoint">
                <item id="kData" label="Data" value="USB_ENDPOINT_ISOCHRONOUS_DATA">
                    <description>Endpoint is used for normal data transfers</description>
                </item>
                <item id="kFeedback" label="Feedback" value="USB_ENDPOINT_ISOCHRONOUS_FEEDBACK">
                    <description>Endpoint is used to convey explicit feedback information for one or more data endpoints.</description>
                </item>
                <item id="kImplicitFeedback" label="Implicit feedback" value="USB_ENDPOINT_ISOCHRONOUS_IMPLICIT_FEEDBACK_DATA">
                    <description>Endpoint is used as an implicit feedback endpoint for one or more data endpoints.</description>
                </item>
            </enum>
            <enum id="implementation_cic_t" from="_implementation_cic">
                <item id="kImplementationNone" label="Disabled">
                    <description>Interface control functions are not generated in the interface files.</description>
                </item>
                <item id="kImplementationCicVcom" label="Virtual COM port (bare metal)">
                    <description>The Virtual COM project example that is enumerated as a COM port device on host and supports virtual serial communication.</description>
                </item>
            </enum>
            <enum id="implementation_dic_t" from="_implementation_dic">
                <item id="kImplementationNone" label="Disabled">
                    <description>Interface control functions are not generated in the interface files.</description>
                </item>
                <item id="kImplementationDicVcom" label="Virtual COM port (bare metal)">
                    <description>The Virtual COM project example that is generated as part of CIC interface.</description>
                </item>
            </enum>
            <enum id="implementation_hid_t" from="_implementation_hid">
                <item id="kImplementationNone" label="Disabled">
                    <description>Interface control functions are not generated in the interface files.</description>
                </item>
                <item id="kImplementationGeneric" label="Generic (bare metal)">
                    <description>The HID Generic code example that is enumerated as a USB HID-compliant device and returns all received data back.</description>
                </item>
                <item id="kImplementationKeyboard" label="Keyboard (bare metal)">
                    <description>The Keyboard code example that is enumerated as a USB HID-compliant keyboard device.</description>
                </item>
                <item id="kImplementationMouse" label="Mouse (bare metal)">
                    <description>The Mouse code example that is enumerated as a USB HID-compliant mouse device.</description>
                </item>
            </enum>
            <enum id="implementation_msc_t" from="_implementation_msc">
                <item id="kImplementationNone" label="Disabled">
                    <description>Interface control functions are not generated in the interface files.</description>
                </item>
                <item id="kImplementationRamDisk" label="RAM disk (bare metal)">
                    <description>The RAM disk (mass storage device) code example that is enumerated as a storage volume device.</description>
                </item>
            </enum>
            <enum id="implementation_dfu_t" from="_implementation_dfu">
                <item id="kImplementationNone" label="Disabled">
                    <description>Interface control functions are not generated in the interface files.</description>
                </item>
                <item id="kImplementationDfu" label="Device Firmware Upgrade (bare metal)">
                    <description>The Device Firmware Upgrade code example provides demonstration of downloading, writing and running of a the code.</description>
                </item>
            </enum>
            <enum id="implementation_phdc_t" from="_implementation_phdc">
                <item id="kImplementationNone" label="Disabled">
                    <description>Interface control functions are not generated in the interface files.</description>
                </item>
                <item id="kImplementationWeightScale" label="Weight scale (bare metal)" available="$this.getMode() == `device`">
                    <description>The Weight scale code example provides simulating of sending weight and Body Mass Index (BMI) information.</description>
                </item>
                <item id="kImplementationManager" label="Manager (bare metal)" available="$this.getMode() == `host`">
                    <description>The Manager code example supports the USB weight scale device. It prints out the information when a device is attached.</description>
                </item>
            </enum>
            <enum id="implementation_printer_t" from="_implementation_printer">
                <item id="kImplementationNone" label="Disabled">
                    <description>Interface control functions are not generated in the interface files.</description>
                </item>
                <item id="kImplementationPlainTextPrinter" label="Plain text (bare metal)">
                    <description>The Plain text printer code example prints any received raw data to the debug console.</description>
                </item>
            </enum>
            <string id="interface_name_t" validation_expr="x -> x.validateName()">
                <description>Interface identifier for UI and generated filenames and code. Can contain spaces to visually separate each part - these get processed depending on the used notation (snake case, camel case, etc.).</description>
            </string>
            <string id="setting_name_t" validation_expr="x -> x.validateName()">
                <description>Endpoints setting identifier for UI and generated filenames and code. Can contain spaces to visually separate each part - these get processed depending on the used notation (snake case, camel case, etc.).</description>
            </string>
            <array id="endpoints_t" type="endpoint_t" label="Endpoints" options="ShowContentAs=TABS;UI_BORDER_HIDDEN;UI_ARRAY_REORDER;UI_TABLE_COLUMN_WIDTHS=3" key_selector_expr="ep -> ep.getSetting(`direction`).getEnumItemLabel() + ` #` + ep.generateEndpointKey()">
                <validation>
                    <constraint cond_expr="$this.countOccurrences(ep -> (ep.getSetting(`transfer_type`).getValue() == `kIsochronous`) &amp;&amp; ((ep.getSetting(`max_packet_size_fs`).getValue() != `k0`) || (ep.getSetting(`max_packet_size_hs`).getValue() != `k0`))) == 0" when_expr="isFirstSetting()" level="error" description="Setting #0 cannot contain any isochronous endpoints with maximum packet size greater than 0."/>
                    <constraint cond_expr="$this.countOccurrences(ep -> (ep.getSetting(`transfer_type`).getValue() == `kInterrupt`) &amp;&amp; !ep.packetSizeLowerThan128()) == 0" when_expr="isFirstSetting()" level="error" description="Setting #0 cannot contain any interrupt endpoints with maximum packet size greater than 64."/>
                </validation>
                <item_defaults>
                    <set_default id="max_packet_size_fs" value_expr="x -> `k8`"/>
                    <set_default id="max_packet_size_hs" value_expr="x -> `k8`"/>
                </item_defaults>
            </array>
            <!-- Audio streaming data endpoint class specific part of the descriptor (isochronous ednpoint) -->
            <enum id="bLockDelayUnits_t">
                <item id="undefined" label="Undefined" value="0"/>
                <item id="milliseconds" label="Milliseconds" value="1"/>
                <item id="pcmSamples" label="Decoded PCM samples" value="2"/>
            </enum>
            <struct id="isochronous_audio_data_endpoint_t">
                <variable id="bmAttributes"
                    value="($parent.samplingFrequencyControl.getValue() ? 1 : 0) + ($parent.pitchControl.getValue() ? 2 : 0) + ($parent.maxPacketsOnly.getValue() ? 128 : 0)"/>
                <bool id="samplingFrequencyControl" label="Sampling Frequency Control">
                    <description>
Enable/dsiable the sampling frequency control that is used to set the initial sampling frequency for an isochronous audio data endpoint.
This allows the endpoints’ clock recovery system to lock onto the incoming clock much
faster. Adaptive endpoints can benefit from this. The Sampling Frequency Control can support all possible
Control attributes (CUR, MIN, MAX, and RES). The settings for the CUR, MIN, and MAX attributes can
range from 0 Hz (0x000000) to 8388607 Hz (0x7FFFFF) in steps of 1 Hz (0x0001). The Sampling
Frequency Control honors the request to the best of its abilities. If the endpoint operates at a fixed
sampling frequency, setting this Control has no effect. If the endpoint supports a discrete number of
sampling frequencies, setting the tSampleFreq value to a non-supported value causes the Control to
round it to the closest available value.                        
                    </description>
                </bool>
                <bool id="pitchControl" label="Pitch Control">
                    <description>
The Pitch Control enables or disables the ability of an adaptive endpoint to dynamically track its sampling
frequency. The Control is necessary because the clock recovery circuitry must be informed whether it
should allow for relatively large swings in the sampling frequency. 
                    </description>
                </bool>
                <bool id="maxPacketsOnly" label="Allow maximum packets only">
                    <description>
When enabled the endpoint always needs USB packets of maximu packer size length (wMaxPacketSize). If disabled the endpoint can handle short packets. 
In any case, the endpoint is required to support null packets. 
                    </description>
                </bool>
                <reference id="bLockDelayUnits" label="Lock delay units" type="bLockDelayUnits_t">
                    <description>Selection of the lock delay units. The lock delay is used to indicate to the Host how long it takes for the clock recovery circuitry of this endpoint to lock and reliably produce or consume the audio data stream.</description>
                </reference>
                <integer id="wLockDelay" label="Lock delay" type="uint16_t">
                    <description>The lock delay is used to indicate to the Host how long it takes for the clock recovery circuitry of this endpoint to lock and reliably produce or consume the audio data stream.</description>
                </integer>
            </struct>
            <struct id="endpoint_t">
                <reference id="direction" type="direction_t" label="Direction"/>
                <reference id="transfer_type" type="transfer_type_t" label="Transfer type"/>
                <reference id="synchronization" label="Synchronization" type="synchronization_type_t" enable="$parent.transfer_type.getValue() == `kIsochronous`">
                    <description>Synchronization of the isochronous endpoint. This setting is not applicable for other endpoint types.</description>
                </reference>
                <reference id="usage" label="Usage" type="usage_type_t" enable="$parent.transfer_type.getValue() == `kIsochronous`">
                    <description>Uusage of the isochronous endpoint (data, feedback or implicit feedback). This setting is not applicable for other endpoint types.</description>
                </reference>
                <dynamic_enum id="max_packet_size_fs" label="Max packet size (FS)" items="enumItemsOf($parent.transfer_type.getEnumItemId() == `kBulk` ? $configSet.bulk_max_packet_size_fs : ($parent.transfer_type.getEnumItemId() == `kInterrupt` ? $configSet.interrupt_max_packet_size_fs : ($parent.transfer_type.getEnumItemId() == `kIsochronous` ? $configSet.isochronous_max_packet_size_fs : ($parent.transfer_type.getEnumItemId() == `kControl` ? $configSet.control_max_packet_size_fs :-1)))).arrayToEnumItems(
                    enumItem -> true,
                    enumItem -> enumItem.getID(),
                    enumItem -> enumItem.getLabel(),
                    enumItem -> enumItem.getValue())" available="true" options="use_enum_value">
                    <custom_value_support default="0" validation_expr="x -> x.isValidIntegerValue(0, 0xFFFF)"/>
                    <!-- the maximum packet size is specified by the word type of the wMaxPacketSize -->
                </dynamic_enum>
                <integer id="polling_interval_fs" type="uint16_t" label="Interval (FS)" enable="(($parent.transfer_type.getEnumItemId()) != `kBulk` &amp;&amp; ($parent.transfer_type.getEnumItemId() != `kControl`))" min_expr="(($parent.transfer_type.getEnumItemId() == `kBulk`) || ($parent.transfer_type.getEnumItemId() == `kControl`))? 0 : 1" max_expr="(($parent.transfer_type.getEnumItemId() == `kBulk`) || ($parent.transfer_type.getEnumItemId() == `kControl`)) ? 0 : ($parent.transfer_type.getEnumItemId() == `kInterrupt` ? 255 : ($parent.transfer_type.getEnumItemId() == `kIsochronous` ? 16 : -1))">
                    <description>Interval for polling endpoint for data transfers expressed in 1 millisecond frames.
                        For Control endpoints,this value is ignored and set to 0. 
                        For bulk endpoints, this value is ignored and set to 0. 
                        For interrupt endpoints, this value must be in the range from 1 to 255. 
                        For isochronous endpoints, this value must be in the range from 1 to 16.</description>
                </integer>
                <dynamic_enum id="max_packet_size_hs" label="Max packet size (HS)" items="enumItemsOf($parent.transfer_type.getEnumItemId() == `kBulk` ? $configSet.bulk_max_packet_size_hs : ($parent.transfer_type.getEnumItemId() == `kInterrupt` ? $configSet.interrupt_max_packet_size_hs : ($parent.transfer_type.getEnumItemId() == `kIsochronous` ? $configSet.isochronous_max_packet_size_hs : ($parent.transfer_type.getEnumItemId() == `kControl` ? $configSet.control_max_packet_size_fs :-1)))).arrayToEnumItems(
                    enumItem -> true,
                    enumItem -> enumItem.getID(),
                    enumItem -> enumItem.getLabel(),
                    enumItem -> enumItem.getValue())" available="$configSet.high_speed_supported.value()" options="use_enum_value">
                    <custom_value_support default="0" validation_expr="x -> x.isValidIntegerValue(0, 0xFFFF)"/>
                    <!-- the maximum packet size is specified by the word type of the wMaxPacketSize -->
                </dynamic_enum>
                <integer id="polling_interval_hs" type="uint16_t" label="Interval (HS)" enable="!((($parent.transfer_type.getEnumItemId() == `kControl`) || ($parent.transfer_type.getEnumItemId()) == `kBulk`) &amp;&amp; ($parent.direction.getEnumItemId() == `kIn`))" available="$configSet.high_speed_supported.value()" min_expr="($parent.transfer_type.getEnumItemId() == `kBulk` || $parent.transfer_type.getEnumItemId() == `kControl`) ? 0 : 1" max_expr="($parent.transfer_type.getEnumItemId() == `kBulk` || $parent.transfer_type.getEnumItemId() == `kControl`) ? ($parent.direction.getEnumItemId() == `kIn` ? 0 : ($parent.direction.getEnumItemId() == `kOut` ? 255 : -1)) : (($parent.transfer_type.getEnumItemId() == `kInterrupt` || $parent.transfer_type.getEnumItemId() == `kIsochronous`) ? 16 : -1)">
                    <description>Interval for polling endpoint for data transfers expressed in 125µs frames.
                        For Control IN endpoints, this value is ignored and set to 0. 
                        For bulk IN endpoints, this value is ignored and set to 0. 
                        For bulk OUT and Control Out endpoints, this value must be in the range from 0 to 255, where a value of 0 indicates the endpoint never NAKs (other values indicate at most 1 NAK each interval number of microframes). 
                        For isochronous and interrupt endpoints, this value must be in the range from 1 to 16.</description>
                </integer>
                <!-- Reference to the interface class type enum. -->
                <variable id="class_type" value="$parent.getParent().getParent().getParent().getParent().getParent().getSetting(`interface_class`).getValue()"/>
                <integer id="bRefresh" label="Refresh" min_expr="0" max_expr="9" type="uint8_t" enable="($parent.class_type.getValue() == `kClassAudio_1_0`) &amp;&amp; ($parent.transfer_type.getValue() == `kIsochronous`)">
                    <description>This field indicates the rate at which an isochronous synchronization pipe provides new synchronization feedback data. This rate must be a power of 2, therefore only the power is reported back and the range of this field is from 1 (2 ms) to 9 (512 ms). If it is not used set the value to 0.</description>
                </integer>
                <dynamic_enum id="bSynchAddress" label="Synchronization endpoint address" options="use_enum_value"
                    enable="($parent.class_type.getValue() == `kClassAudio_1_0`) &amp;&amp; ($parent.transfer_type.getValue() == `kIsochronous`)"
                    items="createArray().addItemToList(`NoSynchronization`,`No synchronization`,`0`, true).merge( 
                    $instance.filter(item -> (item.isAvailable() &amp;&amp; item.isEnabled() &amp;&amp; (item.getType() == `struct`) &amp;&amp; (item.nodeExists(`endpointAddressLabel`))), true).arrayToEnumItems(
                        enumItem -> (enumItem.getSetting(`endpointAddress`).getValue() != $parent.endpointAddress.getValue()),
                        enumItem -> `Address_` + enumItem.getSetting(`endpointAddress`).getValue(),
                        enumItem -> enumItem.getSetting(`endpointAddressLabel`).getValue(),
                        enumItem -> enumItem.getSetting(`endpointAddress`).getValue()))">
                    <description>
The address of the endpoint used to communicate synchronization information if required by this endpoint. Reset to zero if no synchronization pipe is used.

Note: For adaptive IN endpoints and asynchronous OUT endpoints, the standard endpoint descriptor provides the Synchronization address field to establish 
a link to the associated synch endpoint. It contains the address of the synchronization endpoint. This field of the synchronization standard endpoint descriptor must be set to zero.                        
                    </description>
                </dynamic_enum>
                <!-- Endpoint address that is used for identification of this endpoint including inteface name and ednpoints setting name -->
                <variable id="endpointAddressLabel" value="$parent.getParent().getParent().getParent().getParent().getSetting(`interface_name`).getValue()  + `/` + $parent.getParent().getParent().getSetting(`setting_name`).getValue() + ` (` + (($parent.direction.getValue() == `kIn`) ? `In` : `Out`) + ` #` + $parent.generateEndpointKey() + `)`">
                    <description/>
                </variable>
                <variable id="endpointAddress" value="$parent.generateEndpointKey().toInt() + (($parent.direction.getValue() == `kIn`) ? 128 : 0)">
                    <description>Endpoint address that is used for identification of this endpoint in the descriptor</description>
                </variable>
                <variable id="epIndex" value="$parent.generateEndpointKey()"/>
                <reference id="cs_as_data" label="Class specific audio streaming data endpoint configuration" type="isochronous_audio_data_endpoint_t"
                    available="($parent.transfer_type.getValue() == `kIsochronous`) &amp;&amp; ($parent.usage.getValue() == `kData`) &amp;&amp; ($parent.getParent().hasOption(`audio_stream_interface`)) &amp;&amp; ($parent.getParent().getOptionValue(`audio_stream_interface`))"/>
                <reference id="cs_as_data_2_0" label="Class specific audio streaming data endpoint configuration" type="isochronous_audio_2_0_data_endpoint_t"
                    available="($parent.transfer_type.getValue() == `kIsochronous`) &amp;&amp; ($parent.usage.getValue() == `kData`) &amp;&amp; ($parent.getParent().hasOption(`audio_stream_interface_2_0`)) &amp;&amp; ($parent.getParent().getOptionValue(`audio_stream_interface_2_0`))"/>
            </struct>
            <variable id="starting_in_ep_nr_t" value="getStartingInEpNumber($parent.getParent().getParent(), $parent.getParent().getId().toInt())"/>
            <variable id="starting_out_ep_nr_t" value="getStartingOutEpNumber($parent.getParent().getParent(), $parent.getParent().getId().toInt())"/>
            <variable id="in_ep_count_t" value="$parent.endpoints_settings.reduce(0, (max, endpointsSetting) -> max &lt; getEndpointsCount(endpointsSetting, `kIn`) ? getEndpointsCount(endpointsSetting, `kIn`) : max)"/>
            <variable id="out_ep_count_t" value="$parent.endpoints_settings.reduce(0, (max, endpointsSetting) -> max &lt; getEndpointsCount(endpointsSetting, `kOut`) ? getEndpointsCount(endpointsSetting, `kOut`) : max)"/>
            <struct id="endpoints_setting_hid_t">
                <reference id="setting_name" type="setting_name_t" label="Custom setting name"/>
                <reference id="endpoints" type="endpoints_t">
                    <validation>
                        <constraint cond_expr="$this.countEndpoints(`kInterrupt`, `kIn`) &gt; 0" level="error" description="At least one interrupt IN is required"/>
                        <constraint cond_expr="$this.countEndpoints(`kInterrupt`, `kOut`) &gt; 0" when_expr="(getImplementationFromEpSettings() == `kImplementationGeneric`) &amp;&amp; isFirstSetting()" level="error" description="One interrupt Out endpoint is required for generated implementation code"/>
                        <constraint cond_expr="($this.getSize() &lt; 3)" when_expr="(getImplementationFromEpSettings() == `kImplementationGeneric`) &amp;&amp; isFirstSetting()" level="warning" description="Only the first In and first Out interrupt endpoints will be used in the generated implementation code"/>
                        <constraint cond_expr="$this.getSize() &lt; 2" when_expr="((getImplementationFromEpSettings() == `kImplementationKeyboard`) || (getImplementationFromEpSettings() == `kImplementationMouse`)) &amp;&amp; isFirstSetting()" level="warning" description="Only the first In endpoint will be used in the generated implementation code"/>
                    </validation>
                </reference>
            </struct>
            <struct id="endpoints_setting_cic_t">
                <reference id="setting_name" type="setting_name_t" label="Custom setting name"/>
                <reference id="endpoints" type="endpoints_t">
                    <validation>
                        <constraint cond_expr="$this.getSize() &lt; 2" when_expr="(getImplementationFromEpSettings() == `kImplementationCicVcom`) &amp;&amp; isFirstSetting()" level="warning" description="Only the first endpoint will be used in the generated implementation code"/>
                        <constraint cond_expr="$this.getSize() != 0" level="error" description="At least 1 endpoint is required"/>
                        <constraint cond_expr="($this.getSize() != 0) &amp;&amp; $this.get(0).checkEndpoint(`kInterrupt`, `kIn`)" when_expr="(getImplementationFromEpSettings() == `kImplementationCicVcom`) &amp;&amp; isFirstSetting()" level="error" description="Need exactly one interrupt IN endpoint as the first one for the generated implementation code"/>
                    </validation>
                </reference>
            </struct>
            <struct id="endpoints_setting_dic_t">
                <reference id="setting_name" type="setting_name_t" label="Custom setting name"/>
                <reference id="endpoints" type="endpoints_t">
                    <validation>
                        <constraint cond_expr="$this.getSize() &lt;= 2" when_expr="(getImplementationFromEpSettings() == `kImplementationDicVcom`) &amp;&amp; isFirstSetting()" level="warning" description="Only the first two endpoints will be used in the generated implementation code"/>
                        <constraint cond_expr="$this.getSize() != 0" level="error" description="At least 1 endpoint is required"/>
                        <constraint cond_expr="$this.checkEndpointDirectionSymmetry()" level="warning" description="Endpoints belonging to DIC are expected to exist in pairs of the same type (one IN and one OUT)"/>
                        <constraint cond_expr="($this.getSize() == 0) || (($this.getSize() > 1) &amp;&amp; $this.get(0).checkEndpoint(`kBulk`, `kIn`) &amp;&amp; $this.get(1).checkEndpoint(`kBulk`, `kOut`))" when_expr="(getImplementationFromEpSettings() == `kImplementationDicVcom`) &amp;&amp; isFirstSetting()" level="error" description="Need exactly one IN and one OUT bulk endpoints as the first two for the generated implementation code"/>
                    </validation>
                </reference>
            </struct>
            <struct id="endpoints_setting_msc_t">
                <reference id="setting_name" type="setting_name_t" label="Custom setting name"/>
                <reference id="endpoints" type="endpoints_t">
                    <validation>
                        <constraint cond_expr="$this.countEndpoints(`kBulk`, `kIn`) &gt; 0" when_expr="getProtocolFromEpSettings() == `kProtocolBbb`" level="error" description="At least one bulk IN is required for bulk-only transport protocol."/>
                        <constraint cond_expr="$this.countEndpoints(`kBulk`, `kOut`) &gt; 0" when_expr="getProtocolFromEpSettings() == `kProtocolBbb`" level="error" description="At least one bulk OUT is required for bulk-only transport protocol."/>
                        <!-- Commented due to limitation of SDK driver
                        <constraint cond_expr="$this.getSize() &lt;= 2" when_expr="(getImplementationFromEpSettings() == `kImplementationRamDisk`) &amp;&amp; isFirstSetting()" level="warning" description="Only the first IN and OUT bulk endpoints will be used in the generated implementation code"/>
                        -->
                        <!-- After the SDK driver update remove the line below and uncommnet the line above -->
                        <constraint cond_expr="$this.getSize() &lt;= 2" when_expr="getProtocolFromEpSettings() == `kProtocolBbb`" level="error" description="Only one bulk IN and one bulk OUT endpoint are allowed in bulk-only transport protocol."/>
                    </validation>
                </reference>
            </struct>
            <struct id="endpoints_setting_dfu_t">
                <reference id="setting_name" type="setting_name_t" label="Custom setting name"/>
                <reference id="endpoints" type="endpoints_t">
                    <validation>
                        <constraint cond_expr="$this.getSize() == 0" level="error" description="DFU uses only the control endpoint."/>
                    </validation>
                </reference>
            </struct>
            <struct id="endpoints_setting_phdc_t">
                <reference id="setting_name" type="setting_name_t" label="Custom setting name"/>
                <reference id="endpoints" type="endpoints_t">
                    <validation>
                        <constraint cond_expr="$this.countEndpoints(`kBulk`,`kIn`) &gt; 0" level="error" description="PHDC class must implement at least one Bulk IN endpoint"/>
                        <constraint cond_expr="$this.countEndpoints(`kBulk`,`kOut`) &gt; 0" level="error" description="PHDC class must implement at least one Bulk OUT endpoint"/>
                        <constraint cond_expr="$this.countEndpoints(`kInterrupt`,`kIn`) &gt; 0" when_expr="(getImplementationFromEpSettings() == `kImplementationWeightScale`) &amp;&amp; isFirstSetting()" level="error" description="Selected implementation requires one Interrupt IN endpoint"/>
                        <constraint cond_expr="$this.getSize() &lt; 4" when_expr="(getImplementationFromEpSettings() == `kImplementationWeightScale`) &amp;&amp; isFirstSetting()" level="warning" description="Only the first Bulk IN, Bulk OUT and Interrupt IN endpoints will be used in the generated implementation code"/>
                    </validation>
                </reference>
            </struct>
            <struct id="endpoints_setting_printer_t">
                <reference id="setting_name" type="setting_name_t" label="Custom setting name"/>
                <reference id="endpoints" type="endpoints_t">
                    <validation>
                        <constraint cond_expr="$this.getSize() &lt; 3" level="error" description="Only one OUT and one IN endpoint are supported by the printer class"/>
                        <constraint cond_expr="!($this.countEndpoints(`kBulk`,`kOut`) == 0)" level="error" description="At least one OUT endpoint is required for the printer class."/>
                        <constraint cond_expr="($this.countEndpoints(`kBulk`,`kOut`) &lt;= 1)" level="error" description="Only one OUT endpoint is supported by the printer class."/>
                        <constraint cond_expr="($this.countEndpoints(`kBulk`,`kIn`) == 1)" when_expr="(getProtocolFromEpSettings() == `kProtocolBiDirectional`) &amp;&amp; ($this.countEndpoints(`kBulk`,`kOut`) == 1) &amp;&amp; ($this.getSize() &lt; 3)" level="error" description="One IN and one OUT endpoint are required for bi-directional printer"/>
                    </validation> 
                </reference>
            </struct>
            <!-- AUDIO STREAM structures -->
            <!-- Type I Format Type Descriptor is supported only for the Audio-->
            <enum id="audio_data_format_t">
                <item id="kUndefined" label="Undefined type I" value="0">
                    <description>Undefined format of data (type I)</description>
                </item>
                <item id="kPCM" label="PCM" value="1">
                    <description>Pulse Coded Modulation format of data.</description>
                </item>
                <item id="kPCM8" label="PCM 8" value="2">
                    <description>Pulse Coded Modulation format of data (8 bits unsigned).</description>
                </item>
                <item id="kIeeeFloat" label="IEEE Float" value="3">
                    <description>The IEEE Float format based on the ANSI/IEEE-754 floating-point standard. Audio data is represented using the basic single-precision format. The basic single-precision number is 32 bits wide and has an 8-bit exponent and a 24-bit mantissa.</description>
                </item>
                <item id="kAlaw" label="ALAW" value="4">
                    <description>The compressed audio data (ALAW compresioin algorithm) uses 8 bits per sample (bBitsPerSample = 8). Data is signed fixed point, left-justified in the subframe, Msb first.</description>
                </item>
                <item id="kMulaw" label="MULAW" value="5">
                    <description>The compressed audio data (MULAW compresioin algorithm) uses 8 bits per sample (bBitsPerSample = 8). Data is signed fixed point, left-justified in the subframe, Msb first.</description>
                </item>
            </enum>
            <struct id="audio_stream_header_t">
                <!-- bTermialLink contains all terminals in the audio control interface - loop through all interfaces is used -->
                <dynamic_enum id="bTerminalLink" label="Link to terminal"
                    options="use_enum_value"
                    items="$parent.getParent().getParent().getParent().getParent().getParent().filter(item -> (item.isAvailable() &amp;&amp; item.isEnabled() &amp;&amp; (item.getType() == `integer`) &amp;&amp; (item.getId() == `bTerminalID`)), true).arrayToEnumItems(
                        enumItem -> true,
                        enumItem -> `bTerminalID_` + enumItem.getValue(),
                        enumItem -> enumItem.getValue(),
                        enumItem -> enumItem.getValue())">
                    <description>>The Terminal ID of the Terminal to which the endpoint of this interface is connected.</description>
                    <custom_value_support default="0" validation_expr="x -> x.isValidIntegerValue(0, 0xFFFF)"/>
                </dynamic_enum>
                <integer id="bDelay" label="Delay [frames]" type="uint8_t">
                    <description>Delay introduced by the data path. Value is expressed in number of frames.</description>
                </integer>
                <reference id="wFormatTag" label="Format" type="audio_data_format_t">
                    <description>Audio Data Format that should be used when exchanging data with this endpoint.3</description>
                </reference>
            </struct>
            <enum id="format_types_t">
                <item id="kFormat_i" label="Format I" value="USB_AUDIO_FORMAT_TYPE_I"/>
            </enum>
            <enum id="sampling_frequency_type_t">
                <item id="kContinuous" label="Continuous range" value="0">
                    <description>Continuous range of frequencies defined by the low and the upper freqeuncy bound.</description>
                </item>
                <item id="kList" label="List of frequencies" value="1">
                    <description>List of supported sampling frequencies is defined.</description>
                </item>
            </enum>
            <integer id="sample_frequency_t" label="Sample freqeuncy" type="uint32_t" min_expr="0" max_expr="16777215">
                <description>Sample frequency in Hz of the data.</description>
            </integer>
            <!-- Audio data format type -->
            <struct id="audio_format_t">
                <reference id="bFormatType" label="Audio data format type" type="format_types_t">
                    <description>Audio data format type of the data.</description>
                </reference>
                <integer id="bNrChannels" label="Number of channels" type="uint8_t">
                    <description>The number of physical channels in the audio data stream.</description>
                    <validation>
                        <constraint when_expr="$parent.getParent().getParent().getParent().getParent().getParent().anyMatch(i -> (i.getSetting(`interface_class`).getEnumItemId() == `kClassAudio_1_0`) &amp;&amp;
                                                (i.getSetting(`setting_audio_1_0.subclass`).getEnumItemId() == `kSubclassAudioControl`))"
                            cond_expr="!(($parent.getParent().getParent().getParent().getParent().getParent().findFirst(i -> (i.getSetting(`interface_class`).getEnumItemId() == `kClassAudio_1_0`) &amp;&amp;
                                        (i.getSetting(`setting_audio_1_0.subclass`).getEnumItemId() == `kSubclassAudioControl`)).getSetting(`setting_audio_1_0.implementation`).getEnumItemId() == `kImplementationAudioSpeaker`) &amp;&amp; $this.getValue() == 0)"
                            level="error"
                            description="Number of channels must be grater than 0 for the Audio speaker (bare metal) example."/>
                    </validation>
                </integer>
                <integer id="bSubframeSize" label="Subframe size" min_expr="1" max_expr="4" type="uint8_t">
                    <description>The number of bytes occupied by one audio subframe.</description>
                </integer>
                <integer id="bBitResolution" label="Resolution" type="uint8_t">
                    <description>The number of effectively used bits from the available bits in an audio subframe.</description>
                </integer>
                <info id="separation_line" label=" " value="`Sampling configuration`" options="UI_LINE_BREAK"/>
                <reference id="sampleFreqSel" label="Sampling frequencies" options="UI_LABEL_BOLD" type="sampling_frequency_type_t">
                    <description>This setting allow selection of the definition of supported sampling frequencies. There can be defined a range of frequencies or a list of discrete supported frequencies.</description>
                </reference>
                <!-- The bSamFreqType is the value of the descriptor item. -->
                <variable id="bSamFreqType" value="($parent.sampleFreqSel.getValue() == `kContinuous`) ? 0 : $parent.tSamFreqList.getSize()"/>
                <reference id="tLowerSamFreq" label="Lower bound" type="sample_frequency_t" enable="$parent.sampleFreqSel.getValue() == `kContinuous`">
                    <description>The lower frequency boumd of the sampling freqeuncy range in Hz.</description>
                </reference>
                <reference id="tUpperSamFreq" label="Upper bound" type="sample_frequency_t" enable="$parent.sampleFreqSel.getValue() == `kContinuous`">
                    <description>The upper frequency boumd of the sampling freqeuncy range in Hz.</description>
                </reference>
                <array id="tSamFreqList" label="Sampling frequencies" type="sample_frequency_t" min_expr="1" max_expr="255"
                    enable="$parent.sampleFreqSel.getValue() == `kList`"
                    options="UI_SHOW_CONTENT_AS=TABLE;UI_ARRAY_REORDER;UI_BORDER_HIDDEN;UI_ARRAY_INDICES_HIDDEN">
                    <description>List of supported sampling frequencies in Hz.</description>
                </array>
            </struct>
            <struct id="endpoints_setting_audio_stream_t">
                <reference id="setting_name" type="setting_name_t" label="Custom setting name"/>
                <reference id="endpoints" type="endpoints_t">
                    <options_expr>
                        <option id="audio_stream_interface" expr="$parent.getParent().getParent().getSetting(`subclass`).getValue() == `kSubclassAudioStream`"/>
                    </options_expr>
                    <validation>
                        <!-- Validations are also provided on the interface setting level (array of endpoints)  -->
                        <constraint when_expr="($parent.getParent().getParent().getSetting(`subclass`).getValue() == `kSubclassAudioStream`) &amp;&amp; ($this.getSize() == 1)"
                            cond_expr="($this.get(0).getSetting(`transfer_type`).getValue() == `kIsochronous`)"
                            level="warning"
                            description="The audio streaming subclass supports one isochronous data endpoint (first) and one isochronous feedback endpoint (second) for each interface setting."/>
                        
                        <constraint when_expr="($parent.getParent().getParent().getSetting(`subclass`).getValue() == `kSubclassAudioStream`) &amp;&amp; ($this.getSize() &gt; 1)"
                            cond_expr="($this.getSize() &lt;= 2) &amp;&amp; ($this.get(0).getSetting(`transfer_type`).getValue() == `kIsochronous`) &amp;&amp; ($this.get(1).getSetting(`transfer_type`).getValue() == `kIsochronous`) &amp;&amp; (($this.get(1).getSetting(`usage`).getValue() == `kImplicitFeedback`) || ($this.get(1).getSetting(`usage`).getValue() == `kFeedback`))"
                            level="warning"
                            description="The audio streaming subclass supports one isochronous data endpoint (first) and one isochronous feedback endpoint (second) for each interface setting."/>
                    </validation>                
                </reference>
                <info id="audio_stream_info" label="Audio stream interface specific settings" value="($parent.endpoints.getSize() == 0) ? `No endpoints are available - configuration is disabled` : ``" options="UI_LABEL_BOLD" available="$parent.getParent().getParent().getSetting(`subclass`).getValue() == `kSubclassAudioStream`"/>
                <reference id="header" label="Audio format settings" type="audio_stream_header_t" options="UI_LABEL_HIDDEN" enable="($parent.endpoints.getSize() &gt; 0)" available="$parent.getParent().getParent().getSetting(`subclass`).getValue() == `kSubclassAudioStream`">
                    <description>Audio streaming interface format settings - format and \.</description>
                </reference>
                <reference id="format" label="Audio data format" type="audio_format_t" enable="($parent.endpoints.getSize() &gt; 0)" available="$parent.getParent().getParent().getSetting(`subclass`).getValue() == `kSubclassAudioStream`">
                    <description>Configuration of the audio data format.</description>
                </reference>
            </struct>
            <struct id="setting_cic_t" from="_setting_cic_t">
                <quick_selections>
                    <quick_selection id="QS_INTERFACE_CIC_NONE" label="None">
                        <set id="interface_name">CIC</set>
                        <set id="implementation">kImplementationNone</set>
                        <set id="subclass">kSubclassAcm</set>
                        <set id="protocol">kProtocolNone</set>
                        <set id="data_interface_count">0</set>
                        <set id="endpoints_settings.0"></set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_CIC_VCOM" label="Virtual COM port (bare metal)" available="$this.getMode() == `device`">
                        <set id="interface_name">CIC VCOM</set>
                        <set id="implementation">kImplementationCicVcom</set>
                        <set id="subclass">kSubclassAcm</set>
                        <set id="protocol">kProtocolNone</set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                        <set id="endpoints_settings.0.endpoints.0.direction">kIn</set>
                        <set id="endpoints_settings.0.endpoints.0.transfer_type">kInterrupt</set>
                        <set id="endpoints_settings.0.endpoints.0.max_packet_size_fs">k16</set>
                        <set id="endpoints_settings.0.endpoints.0.polling_interval_fs">8</set>
                        <set id="endpoints_settings.0.endpoints.0.max_packet_size_hs">k16</set>
                        <set id="endpoints_settings.0.endpoints.0.polling_interval_hs">7</set>
                        <set id="data_interface_count">1</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_CIC_VCOM" label="Virtual COM port (bare metal)" available="$this.getMode() == `host`">
                        <set id="interface_name">CIC VCOM</set>
                        <set id="implementation">kImplementationCicVcom</set>
                        <set id="subclass">kSubclassAcm</set>
                        <set id="protocol">kProtocolNone</set>
                        <set id="data_interface_count">1</set>
                    </quick_selection>
                    <default>QS_INTERFACE_CIC_VCOM</default>
                </quick_selections>
                <reference id="interface_name" type="interface_name_t" label="Custom interface name"/>
                <reference id="subclass" type="subclass_cic_t" label="Subclass"/>
                <reference id="protocol" type="protocol_cic_t" label="Protocol"/>
                <info id="classImplementationBegin" label="Class implementation code" value="`Class implementation code for interface (` + $parent.interface_name.getValue() + `)`" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"/>
                <reference id="implementation" type="implementation_cic_t" label="Generate code example">
                    <options_expr>
                        <option id="UI_OPEN_DOCUMENTATION" expr="`workflow.md`"/>
                    </options_expr>
                    <description>This setting allows generating of the example code for the USB CIC class.</description>
                </reference>
                <info id="classImplementationInfo" label=" " value="$parent.implementation.enumItemsOf().findFirst(x -> (x.getId() == $parent.implementation.getEnumItemId())).getDescription()"/>
                <info id="classImplementationEnd" label="Class implementation code" value="``" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"/>
                <reference id="starting_in_ep_nr" type="starting_in_ep_nr_t" available="$this.getMode() == `device`"/>
                <reference id="starting_out_ep_nr" type="starting_out_ep_nr_t" available="$this.getMode() == `device`"/>
                <array id="endpoints_settings" type="endpoints_setting_cic_t" label="Interface setting" min_expr="1" options="ShowContentAs=TABS;UI_ARRAY_REORDER" key_selector_expr="setting -> setting.generateSettingKey()" available="$this.getMode() == `device`">
                    <description>Setting 0 is the default setting. Others are alternate setting.</description>
                    <validation>
                        <constraint cond_expr="$this.getSize() &lt; 2" when_expr="isSomeImplementationSelectedFromEpsSettings()" level="warning" description="Selected implementation expects only one endpoints setting"/>
                    </validation>
                </array>
                <reference id="in_ep_count" type="in_ep_count_t" available="$this.getMode() == `device`"/>
                <reference id="out_ep_count" type="out_ep_count_t" available="$this.getMode() == `device`"/>
                <integer id="data_interface_count" type="uint8_t" label="Succeeding data transmission interfaces">
                    <description>Number of interfaces to use for data transmission. These must succeed CIC interface.</description>
                    <validation>
                        <constraint cond_expr="$this.value() == 1" level="warning" description="CIC implementation expects exactly one DIC as a data transmission interface"/>
                        <constraint cond_expr="$this.value() &lt;= $parent.getParent().getParent().getSize() - $parent.getParent().getId().toInt() - 1" level="error" description="Not enough data transmission interfaces"/>
                    </validation>
                </integer>
                <info id="data_interfaces" value="$parent.getParent().getParent().enumerateSucceedingInterfaceKeys($parent.getParent().getId().toInt(), $parent.data_interface_count.value()).join(`, `)" label="Data transmission interfaces">
                    <description>List of interfaces used by CIC for data transmission.</description>
                    <validation>
                        <constraint cond_expr="$parent.getParent().getParent().countDataTransmissionInterfaces($parent.getParent().getId().toInt(), $parent.data_interface_count.value()) == $parent.getParent().getParent().enumerateSucceedingInterfaceKeys($parent.getParent().getId().toInt(), $parent.data_interface_count.value()).size()" when_expr="$parent.getParent().getParent().enumerateSucceedingInterfaceKeys($parent.getParent().getId().toInt(), $parent.data_interface_count.value()).size() != 0" level="warning" description="Only DIC interfaces are supported for data transmission"/>
                    </validation>
                </info>
            </struct>
            <struct id="setting_dic_t" from="_setting_dic_t">
                <validation>
                    <constraint cond_expr="!$parent.getParent().isStandaloneDataTransmissionInterface($parent.getId().toInt())" level="error" description="DIC interface must be used for data transmission in a CIC interface"/>
                </validation>
                <quick_selections>
                    <quick_selection id="QS_INTERFACE_DIC_NONE" label="None">
                        <set id="interface_name">DIC</set>
                        <set id="implementation">kImplementationNone</set>
                        <set id="subclass">kSubclassNone</set>
                        <set id="protocol">kProtocolNone</set>
                        <set id="endpoints_settings.0"></set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_DIC_VCOM" label="Virtual COM port (bare metal)" available="$this.getMode() == `device`">
                        <set id="interface_name">DIC VCOM</set>
                        <set id="implementation">kImplementationDicVcom</set>
                        <set id="subclass">kSubclassNone</set>
                        <set id="protocol">kProtocolNone</set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                        <set id="endpoints_settings.0.endpoints.0.direction">kIn</set>
                        <set id="endpoints_settings.0.endpoints.0.transfer_type">kBulk</set>
                        <set id="endpoints_settings.0.endpoints.0.max_packet_size_fs">k64</set>
                        <set id="endpoints_settings.0.endpoints.0.polling_interval_fs">0</set>
                        <set id="endpoints_settings.0.endpoints.0.max_packet_size_hs">k512</set>
                        <set id="endpoints_settings.0.endpoints.0.polling_interval_hs">0</set>
                        <set id="endpoints_settings.0.endpoints.1.direction">kOut</set>
                        <set id="endpoints_settings.0.endpoints.1.transfer_type">kBulk</set>
                        <set id="endpoints_settings.0.endpoints.1.max_packet_size_fs">k64</set>
                        <set id="endpoints_settings.0.endpoints.1.polling_interval_fs">0</set>
                        <set id="endpoints_settings.0.endpoints.1.max_packet_size_hs">k512</set>
                        <set id="endpoints_settings.0.endpoints.1.polling_interval_hs">0</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_DIC_VCOM" label="Virtual COM port (bare metal)" available="$this.getMode() == `host`">
                        <set id="interface_name">DIC VCOM</set>
                        <set id="implementation">kImplementationDicVcom</set>
                        <set id="subclass">kSubclassNone</set>
                        <set id="protocol">kProtocolNone</set>
                    </quick_selection>
                    <default>QS_INTERFACE_DIC_VCOM</default>
                </quick_selections>
                <reference id="interface_name" type="interface_name_t" label="Custom interface name"/>
                <!-- this setting enables/disables the generating of the template interface file when the implementation is None -->
                <variable id="generateTemplateInterface" value="false"></variable>
                <reference id="subclass" type="subclass_dic_t" label="Subclass"/>
                <reference id="protocol" type="protocol_dic_t" label="Protocol"/>
                <info id="classImplementationBegin" label="Class implementation code" value="`Class implementation code for interface (` + $parent.interface_name.getValue() + `)`" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"/>
                <reference id="implementation" type="implementation_dic_t" label="Generate code example">
                    <options_expr>
                        <option id="UI_OPEN_DOCUMENTATION" expr="`workflow.md`"/>
                    </options_expr>
                    <description>This setting allows generating of the example code for the USB DIC class.</description>
                </reference>
                <info id="classImplementationInfo" label=" " value="$parent.implementation.enumItemsOf().findFirst(x -> (x.getId() == $parent.implementation.getEnumItemId())).getDescription()"/>
                <info id="classImplementationEnd" label="Class implementation code" value="``" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"/>
                <reference id="starting_in_ep_nr" type="starting_in_ep_nr_t" available="$this.getMode() == `device`"/>
                <reference id="starting_out_ep_nr" type="starting_out_ep_nr_t" available="$this.getMode() == `device`"/>
                <array id="endpoints_settings" type="endpoints_setting_dic_t" label="Interface setting" min_expr="1" options="ShowContentAs=TABS;UI_ARRAY_REORDER" key_selector_expr="setting -> setting.generateSettingKey()" available="$this.getMode() == `device`">
                    <description>Setting 0 is the default setting. Others are alternate setting.</description>
                    <validation>
                        <constraint cond_expr="$this.getSize() &lt; 2" when_expr="isSomeImplementationSelectedFromEpsSettings()" level="warning" description="Selected implementation expects only one endpoints setting"/>
                    </validation>
                </array>
                <reference id="in_ep_count" type="in_ep_count_t" available="$this.getMode() == `device`"/>
                <reference id="out_ep_count" type="out_ep_count_t" available="$this.getMode() == `device`"/>
            </struct>
            <struct id="setting_hid_t" from="_setting_hid_t">
                <quick_selections>
                    <quick_selection id="QS_INTERFACE_HID_NONE" label="None">
                        <set id="interface_name">HID None</set>
                        <set id="implementation">kImplementationNone</set>
                        <set id="subclass">kSubclassBootInterface</set>
                        <set id="protocol">kProtocolNone</set>
                        <set id="endpoints_settings.0"></set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_HID_GENERIC" label="Generic (bare metal)" available="$this.getMode() == `device`">
                        <set id="interface_name">HID Generic</set>
                        <set id="implementation">kImplementationGeneric</set>
                        <set id="subclass">kSubclassBootInterface</set>
                        <set id="protocol">kProtocolNone</set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                        <set id="endpoints_settings.0.endpoints.0.direction">kIn</set>
                        <set id="endpoints_settings.0.endpoints.0.transfer_type">kInterrupt</set>
                        <set id="endpoints_settings.0.endpoints.0.max_packet_size_fs">k8</set>
                        <set id="endpoints_settings.0.endpoints.0.polling_interval_fs">1</set>
                        <set id="endpoints_settings.0.endpoints.0.max_packet_size_hs">k8</set>
                        <set id="endpoints_settings.0.endpoints.0.polling_interval_hs">1</set>
                        <set id="endpoints_settings.0.endpoints.1.direction">kOut</set>
                        <set id="endpoints_settings.0.endpoints.1.transfer_type">kInterrupt</set>
                        <set id="endpoints_settings.0.endpoints.1.max_packet_size_fs">k8</set>
                        <set id="endpoints_settings.0.endpoints.1.polling_interval_fs">1</set>
                        <set id="endpoints_settings.0.endpoints.1.max_packet_size_hs">k8</set>
                        <set id="endpoints_settings.0.endpoints.1.polling_interval_hs">1</set>
                        <set id="report_descriptor.0.type">kUsage_Page</set>
                        <set id="report_descriptor.0.value">0x81</set>
                        <set id="report_descriptor.0.remarks">Usage Page (Vendor defined)</set>
                        <set id="report_descriptor.1.type">kUsage</set>
                        <set id="report_descriptor.1.value">0x82</set>
                        <set id="report_descriptor.1.remarks">Usage (Vendor defined)</set>
                        <set id="report_descriptor.2.type">kCollection</set>
                        <set id="report_descriptor.2.value">0x01</set>
                        <set id="report_descriptor.2.remarks">Collection (Application)</set>
                        <set id="report_descriptor.3.type">kUsage</set>
                        <set id="report_descriptor.3.value">0x83</set>
                        <set id="report_descriptor.3.remarks">Usage (Vendor defined)</set>
                        <set id="report_descriptor.4.type">kUsage</set>
                        <set id="report_descriptor.4.value">0x84</set>
                        <set id="report_descriptor.4.remarks">Usage (Vendor defined)</set>
                        <set id="report_descriptor.5.type">kLogical_Minimum</set>
                        <set id="report_descriptor.5.value">-128</set>
                        <set id="report_descriptor.5.remarks">Logical Minimum (-128)</set>
                        <set id="report_descriptor.6.type">kLogical_Maximum</set>
                        <set id="report_descriptor.6.value">0x7F</set>
                        <set id="report_descriptor.6.remarks">Logical Maximum (127)</set>
                        <set id="report_descriptor.7.type">kReport_Size</set>
                        <set id="report_descriptor.7.value">0x08</set>
                        <set id="report_descriptor.7.remarks">Report Size (8U)</set>
                        <set id="report_descriptor.8.type">kReport_Count</set>
                        <set id="report_descriptor.8.value">0x08</set>
                        <set id="report_descriptor.8.remarks">Report Count (8U)</set>
                        <set id="report_descriptor.9.type">kInput</set>
                        <set id="report_descriptor.9.value">0x02</set>
                        <set id="report_descriptor.9.remarks">Input(Data, Variable, Absolute)</set>
                        <set id="report_descriptor.10.type">kUsage</set>
                        <set id="report_descriptor.10.value">0x84</set>
                        <set id="report_descriptor.10.remarks">Usage (Vendor defined)</set>
                        <set id="report_descriptor.11.type">kLogical_Minimum</set>
                        <set id="report_descriptor.11.value">-128</set>
                        <set id="report_descriptor.11.remarks">Logical Minimum (-128)</set>
                        <set id="report_descriptor.12.type">kLogical_Maximum</set>
                        <set id="report_descriptor.12.value">0x7F</set>
                        <set id="report_descriptor.12.remarks">Logical Maximum (127)</set>
                        <set id="report_descriptor.13.type">kReport_Size</set>
                        <set id="report_descriptor.13.value">0x08</set>
                        <set id="report_descriptor.13.remarks">Report Size (8U)</set>
                        <set id="report_descriptor.14.type">kReport_Count</set>
                        <set id="report_descriptor.14.value">0x08</set>
                        <set id="report_descriptor.14.remarks">Report Count (8U)</set>
                        <set id="report_descriptor.15.type">kOutput</set>
                        <set id="report_descriptor.15.value">0x02</set>
                        <set id="report_descriptor.15.remarks">Output(Data, Variable, Absolute)</set>
                        <set id="report_descriptor.16.type">kEnd_Collection</set>
                        <set id="report_descriptor.16.remarks">End collection,</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_HID_GENERIC" label="Generic (bare metal)" available="$this.getMode() == `host`">
                        <set id="interface_name">HID Generic</set>
                        <set id="implementation">kImplementationGeneric</set>
                        <set id="subclass">kSubclassBootInterface</set>
                        <set id="protocol">kProtocolNone</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_HID_KEYBOARD" label="Keyboard (bare metal)" available="$this.getMode() == `device`">
                        <set id="interface_name">HID Keyboard</set>
                        <set id="implementation">kImplementationKeyboard</set>
                        <set id="subclass">kSubclassBootInterface</set>
                        <set id="protocol">kProtocolKeyboard</set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                        <set id="endpoints_settings.0.endpoints.0.direction">kIn</set>
                        <set id="endpoints_settings.0.endpoints.0.transfer_type">kInterrupt</set>
                        <set id="endpoints_settings.0.endpoints.0.max_packet_size_fs">k8</set>
                        <set id="endpoints_settings.0.endpoints.0.polling_interval_fs">4</set>
                        <set id="endpoints_settings.0.endpoints.0.max_packet_size_hs">k8</set>
                        <set id="endpoints_settings.0.endpoints.0.polling_interval_hs">6</set>
                        <set id="report_descriptor.0.type">kUsage_Page</set>
                        <set id="report_descriptor.0.value">0x01</set>
                        <set id="report_descriptor.0.remarks">Usage Page (Generic Desktop)</set>
                        <set id="report_descriptor.1.type">kUsage</set>
                        <set id="report_descriptor.1.value">0x06</set>
                        <set id="report_descriptor.1.remarks">Usage (Keyboard)</set>
                        <set id="report_descriptor.2.type">kCollection</set>
                        <set id="report_descriptor.2.value">0x01</set>
                        <set id="report_descriptor.2.remarks">Collection (Application)</set>
                        <set id="report_descriptor.3.type">kReport_Size</set>
                        <set id="report_descriptor.3.value">0x01</set>
                        <set id="report_descriptor.3.remarks">Report Size (1U)</set>
                        <set id="report_descriptor.4.type">kReport_Count</set>
                        <set id="report_descriptor.4.value">0x08</set>
                        <set id="report_descriptor.4.remarks">Report Count (8U)</set>
                        <set id="report_descriptor.5.type">kUsage_Page</set>
                        <set id="report_descriptor.5.value">0x07</set>
                        <set id="report_descriptor.5.remarks">Usage Page(Key Codes)</set>
                        <set id="report_descriptor.6.type">kUsage_Minimum</set>
                        <set id="report_descriptor.6.value">0xE0</set>
                        <set id="report_descriptor.6.remarks">Usage Minimum (224U)</set>
                        <set id="report_descriptor.7.type">kUsage_Maximum</set>
                        <set id="report_descriptor.7.value">0xE7</set>
                        <set id="report_descriptor.7.remarks">Usage Maximum (231U)</set>
                        <set id="report_descriptor.8.type">kLogical_Minimum</set>
                        <set id="report_descriptor.8.value">0x00</set>
                        <set id="report_descriptor.8.remarks">Logical Minimum (0U)</set>
                        <set id="report_descriptor.9.type">kLogical_Maximum</set>
                        <set id="report_descriptor.9.value">0x01</set>
                        <set id="report_descriptor.9.remarks">Logical Maximum (1U)</set>
                        <set id="report_descriptor.10.type">kInput</set>
                        <set id="report_descriptor.10.value">0x02</set>
                        <set id="report_descriptor.10.remarks">Input(Data, Variable, Absolute) Modifier byte</set>
                        <set id="report_descriptor.11.type">kReport_Count</set>
                        <set id="report_descriptor.11.value">0x01</set>
                        <set id="report_descriptor.11.remarks">Report Count (1U)</set>
                        <set id="report_descriptor.12.type">kReport_Size</set>
                        <set id="report_descriptor.12.value">0x08</set>
                        <set id="report_descriptor.12.remarks">Report Size (8U)</set>
                        <set id="report_descriptor.13.type">kInput</set>
                        <set id="report_descriptor.13.value">0x01</set>
                        <set id="report_descriptor.13.remarks">Input(Constant), Reserved byte</set>
                        <set id="report_descriptor.14.type">kReport_Count</set>
                        <set id="report_descriptor.14.value">0x05</set>
                        <set id="report_descriptor.14.remarks">Report Count (5U)</set>
                        <set id="report_descriptor.15.type">kReport_Size</set>
                        <set id="report_descriptor.15.value">0x01</set>
                        <set id="report_descriptor.15.remarks">Report Size (1U)</set>
                        <set id="report_descriptor.16.type">kUsage_Page</set>
                        <set id="report_descriptor.16.value">0x08</set>
                        <set id="report_descriptor.16.remarks">Usage Page (Page# for LEDs)</set>
                        <set id="report_descriptor.17.type">kUsage_Minimum</set>
                        <set id="report_descriptor.17.value">0x01</set>
                        <set id="report_descriptor.17.remarks">Usage Minimum (1U)</set>
                        <set id="report_descriptor.18.type">kUsage_Maximum</set>
                        <set id="report_descriptor.18.value">0x05</set>
                        <set id="report_descriptor.18.remarks">Usage Maximum (5U)</set>
                        <set id="report_descriptor.19.type">kOutput</set>
                        <set id="report_descriptor.19.value">0x02</set>
                        <set id="report_descriptor.19.remarks">Output (Data, Variable, Absolute) LED report</set>
                        <set id="report_descriptor.20.type">kReport_Count</set>
                        <set id="report_descriptor.20.value">0x01</set>
                        <set id="report_descriptor.20.remarks">Report Count (1U)</set>
                        <set id="report_descriptor.21.type">kReport_Size</set>
                        <set id="report_descriptor.21.value">0x03</set>
                        <set id="report_descriptor.21.remarks">Report Size (3U)</set>
                        <set id="report_descriptor.22.type">kOutput</set>
                        <set id="report_descriptor.22.value">0x03</set>
                        <set id="report_descriptor.22.remarks">Output (Constant), LED report padding</set>
                        <set id="report_descriptor.23.type">kReport_Count</set>
                        <set id="report_descriptor.23.value">0x06</set>
                        <set id="report_descriptor.23.remarks">Report Count (6U)</set>
                        <set id="report_descriptor.24.type">kReport_Size</set>
                        <set id="report_descriptor.24.value">0x08</set>
                        <set id="report_descriptor.24.remarks">Report Size (8U)</set>
                        <set id="report_descriptor.25.type">kLogical_Minimum</set>
                        <set id="report_descriptor.25.value">0x00</set>
                        <set id="report_descriptor.25.remarks">Logical Minimum (0U)</set>
                        <set id="report_descriptor.26.type">kLogical_Maximum</set>
                        <set id="report_descriptor.26.value">0xFF</set>
                        <set id="report_descriptor.26.remarks">Logical Maximum (255U)</set>
                        <set id="report_descriptor.27.type">kUsage_Page</set>
                        <set id="report_descriptor.27.value">0x07</set>
                        <set id="report_descriptor.27.remarks">Usage Page (Key Codes)</set>
                        <set id="report_descriptor.28.type">kUsage_Minimum</set>
                        <set id="report_descriptor.28.value">0x00</set>
                        <set id="report_descriptor.28.remarks">Usage Minimum (0U)</set>
                        <set id="report_descriptor.29.type">kUsage_Maximum</set>
                        <set id="report_descriptor.29.value">0xFF</set>
                        <set id="report_descriptor.29.remarks">Usage Maximum (255U)</set>
                        <set id="report_descriptor.30.type">kInput</set>
                        <set id="report_descriptor.30.value">0x00</set>
                        <set id="report_descriptor.30.remarks">Input(Data, Array), Key arrays(6U bytes)</set>
                        <set id="report_descriptor.31.type">kEnd_Collection</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_HID_KEYBOARD" label="Keyboard (bare metal)" available="$this.getMode() == `host`">
                        <set id="interface_name">HID Keyboard</set>
                        <set id="implementation">kImplementationKeyboard</set>
                        <set id="subclass">kSubclassBootInterface</set>
                        <set id="protocol">kProtocolKeyboard</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_HID_MOUSE" label="Mouse (bare metal)" available="$this.getMode() == `device`">
                        <set id="interface_name">HID Mouse</set>
                        <set id="implementation">kImplementationMouse</set>
                        <set id="subclass">kSubclassBootInterface</set>
                        <set id="protocol">kProtocolMouse</set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                        <set id="endpoints_settings.0.endpoints.0.direction">kIn</set>
                        <set id="endpoints_settings.0.endpoints.0.transfer_type">kInterrupt</set>
                        <set id="endpoints_settings.0.endpoints.0.max_packet_size_fs">k8</set>
                        <set id="endpoints_settings.0.endpoints.0.polling_interval_fs">4</set>
                        <set id="endpoints_settings.0.endpoints.0.max_packet_size_hs">k8</set>
                        <set id="endpoints_settings.0.endpoints.0.polling_interval_hs">6</set>
                        <set id="report_descriptor.0.type">kUsage_Page</set>
                        <set id="report_descriptor.0.value">0x01</set>
                        <set id="report_descriptor.0.remarks">Usage Page (Generic Desktop)</set>
                        <set id="report_descriptor.1.type">kUsage</set>
                        <set id="report_descriptor.1.value">0x02</set>
                        <set id="report_descriptor.1.remarks">Usage (Mouse)</set>
                        <set id="report_descriptor.2.type">kCollection</set>
                        <set id="report_descriptor.2.value">0x01</set>
                        <set id="report_descriptor.2.remarks">Collection (Application)</set>
                        <set id="report_descriptor.3.type">kUsage</set>
                        <set id="report_descriptor.3.value">0x01</set>
                        <set id="report_descriptor.3.remarks">Usage (Pointer)</set>
                        <set id="report_descriptor.4.type">kCollection</set>
                        <set id="report_descriptor.4.value">0x00</set>
                        <set id="report_descriptor.4.remarks">Collection (Physical)</set>
                        <set id="report_descriptor.5.type">kUsage_Page</set>
                        <set id="report_descriptor.5.value">0x09</set>
                        <set id="report_descriptor.5.remarks">Usage Page (Buttons)</set>
                        <set id="report_descriptor.6.type">kUsage_Minimum</set>
                        <set id="report_descriptor.6.value">0x01</set>
                        <set id="report_descriptor.6.remarks">Usage Minimum (01U)</set>
                        <set id="report_descriptor.7.type">kUsage_Maximum</set>
                        <set id="report_descriptor.7.value">0x07</set>
                        <set id="report_descriptor.7.remarks">Usage Maximum (07U)</set>
                        <set id="report_descriptor.8.type">kLogical_Minimum</set>
                        <set id="report_descriptor.8.value">0x00</set>
                        <set id="report_descriptor.8.remarks">Logical Minimum</set>
                        <set id="report_descriptor.9.type">kLogical_Maximum</set>
                        <set id="report_descriptor.9.value">0x01</set>
                        <set id="report_descriptor.9.remarks">Logical Maximum (1U)</set>
                        <set id="report_descriptor.10.type">kReport_Count</set>
                        <set id="report_descriptor.10.value">0x03</set>
                        <set id="report_descriptor.10.remarks">Report Count (3U)</set>
                        <set id="report_descriptor.11.type">kReport_Size</set>
                        <set id="report_descriptor.11.value">0x01</set>
                        <set id="report_descriptor.11.remarks">Report Size (1U)</set>
                        <set id="report_descriptor.12.type">kInput</set>
                        <set id="report_descriptor.12.value">0x02</set>
                        <set id="report_descriptor.12.remarks">Input(Data, Variable, Absolute) 3U button bit fields</set>
                        <set id="report_descriptor.13.type">kReport_Count</set>
                        <set id="report_descriptor.13.value">0x01</set>
                        <set id="report_descriptor.13.remarks">Report Count (1U)</set>
                        <set id="report_descriptor.14.type">kReport_Size</set>
                        <set id="report_descriptor.14.value">0x05</set>
                        <set id="report_descriptor.14.remarks">Report Size (5U)</set>
                        <set id="report_descriptor.15.type">kInput</set>
                        <set id="report_descriptor.15.value">0x01</set>
                        <set id="report_descriptor.15.remarks">Input (Constant), 5U constant field</set>
                        <set id="report_descriptor.16.type">kUsage_Page</set>
                        <set id="report_descriptor.16.value">0x01</set>
                        <set id="report_descriptor.16.remarks">Usage Page (Generic Desktop)</set>
                        <set id="report_descriptor.17.type">kUsage</set>
                        <set id="report_descriptor.17.value">0x30</set>
                        <set id="report_descriptor.17.remarks">Usage (X)</set>
                        <set id="report_descriptor.18.type">kUsage</set>
                        <set id="report_descriptor.18.value">0x31</set>
                        <set id="report_descriptor.18.remarks">Usage (Y)</set>
                        <set id="report_descriptor.19.type">kUsage</set>
                        <set id="report_descriptor.19.value">0x38</set>
                        <set id="report_descriptor.19.remarks">Usage (Z)</set>
                        <set id="report_descriptor.20.type">kLogical_Minimum</set>
                        <set id="report_descriptor.20.value">-127</set>
                        <set id="report_descriptor.20.remarks">Logical Minimum (-127)</set>
                        <set id="report_descriptor.21.type">kLogical_Maximum</set>
                        <set id="report_descriptor.21.value">0x7F</set>
                        <set id="report_descriptor.21.remarks">Logical Maximum (127)</set>
                        <set id="report_descriptor.22.type">kReport_Size</set>
                        <set id="report_descriptor.22.value">0x08</set>
                        <set id="report_descriptor.22.remarks">Report Size (8U)</set>
                        <set id="report_descriptor.23.type">kReport_Count</set>
                        <set id="report_descriptor.23.value">0x03</set>
                        <set id="report_descriptor.23.remarks">Report Count (3U)</set>
                        <set id="report_descriptor.24.type">kInput</set>
                        <set id="report_descriptor.24.value">0x06</set>
                        <set id="report_descriptor.24.remarks">Input(Data, Variable, Relative), Three position bytes (X, Y, Z)</set>
                        <set id="report_descriptor.25.type">kEnd_Collection</set>
                        <set id="report_descriptor.25.remarks">End collection, Close Pointer collection</set>
                        <set id="report_descriptor.26.type">kEnd_Collection</set>
                        <set id="report_descriptor.26.remarks">End collection, Close Mouse collection</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_HID_MOUSE" label="Mouse (bare metal)" available="$this.getMode() == `host`">
                        <set id="interface_name">HID Mouse</set>
                        <set id="implementation">kImplementationMouse</set>
                        <set id="subclass">kSubclassBootInterface</set>
                        <set id="protocol">kProtocolMouse</set>
                    </quick_selection>
                    <default>QS_INTERFACE_HID_MOUSE</default>
                </quick_selections>
                <reference id="interface_name" type="interface_name_t" label="Custom interface name"/>
                <reference id="subclass" type="subclass_hid_t" label="Subclass"/>
                <reference id="protocol" type="protocol_hid_t" label="Protocol"/>
                <info id="classImplementationBegin" label="Class implementation code" value="`Class implementation code for interface (` + $parent.interface_name.getValue() + `)`" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"/>
                <reference id="implementation" type="implementation_hid_t" label="Generate code example">
                    <options_expr>
                        <option id="UI_OPEN_DOCUMENTATION" expr="`workflow.md`"/>
                    </options_expr>
                    <description>This setting allows generating of the example code for the USB HID class.</description>
                </reference>
                <info id="classImplementationInfo" label=" " value="$parent.implementation.enumItemsOf().findFirst(x -> (x.getId() == $parent.implementation.getEnumItemId())).getDescription()"/>
                <info id="classImplementationEnd" label="Class implementation code" value="``" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"/>
                <reference id="starting_in_ep_nr" type="starting_in_ep_nr_t" available="$this.getMode() == `device`"/>
                <reference id="starting_out_ep_nr" type="starting_out_ep_nr_t" available="$this.getMode() == `device`"/>
                <array id="endpoints_settings" type="endpoints_setting_hid_t" label="Interface setting" min_expr="1" options="ShowContentAs=TABS;UI_ARRAY_REORDER" key_selector_expr="setting -> setting.generateSettingKey()" available="$this.getMode() == `device`">
                    <description>Setting 0 is the default setting. Others are alternate setting.</description>
                    <validation>
                        <constraint cond_expr="$this.getSize() &lt; 2" when_expr="isSomeImplementationSelectedFromEpsSettings()" level="warning" description="Selected implementation expects only one endpoints setting"/>
                    </validation>
                    <item_defaults>
                        <set_default id="setting_name" value_expr="x -> `Setting`"/>
                    </item_defaults>
                </array>
                <reference id="in_ep_count" type="in_ep_count_t" available="$this.getMode() == `device`"/>
                <reference id="out_ep_count" type="out_ep_count_t" available="$this.getMode() == `device`"/>
                <array id="report_descriptor" type="report_descriptor_entry_t" label="Report descriptor" options="ShowContentAs=TABLE;UI_BORDER_HIDDEN;UI_TABLE_COLUMN_WIDTHS=-1,12,-1,33;UI_ARRAY_REORDER" available="$this.getMode() == `device`">
                    <validation>
                        <constraint cond_expr="$this.getSize() != 0" level="error" description="Report descriptor cannot be empty"/>
                    </validation>
                </array>
            </struct>
            <struct id="setting_msc_t" from="_setting_msc_t">
                <quick_selections>
                    <quick_selection id="QS_INTERFACE_MSC_NONE" label="None">
                        <set id="interface_name">MSC</set>
                        <set id="implementation">kImplementationNone</set>
                        <set id="subclass">kSubclassScsi</set>
                        <set id="protocol">kProtocolBbb</set>
                        <set id="endpoints_settings.0"></set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_MSC_RAM_DISK" label="RAM disk (bare metal)" available="$this.getMode() == `device`">
                        <set id="interface_name">MSC RAM Disk</set>
                        <set id="implementation">kImplementationRamDisk</set>
                        <set id="subclass">kSubclassScsi</set>
                        <set id="protocol">kProtocolBbb</set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                        <set id="endpoints_settings.0.endpoints.0.direction">kIn</set>
                        <set id="endpoints_settings.0.endpoints.0.transfer_type">kBulk</set>
                        <set id="endpoints_settings.0.endpoints.0.max_packet_size_fs">k64</set>
                        <set id="endpoints_settings.0.endpoints.0.polling_interval_fs">0</set>
                        <set id="endpoints_settings.0.endpoints.0.max_packet_size_hs">k512</set>
                        <set id="endpoints_settings.0.endpoints.0.polling_interval_hs">0</set>
                        <set id="endpoints_settings.0.endpoints.1.direction">kOut</set>
                        <set id="endpoints_settings.0.endpoints.1.transfer_type">kBulk</set>
                        <set id="endpoints_settings.0.endpoints.1.max_packet_size_fs">k64</set>
                        <set id="endpoints_settings.0.endpoints.1.polling_interval_fs">0</set>
                        <set id="endpoints_settings.0.endpoints.1.max_packet_size_hs">k512</set>
                        <set id="endpoints_settings.0.endpoints.1.polling_interval_hs">0</set>
                    </quick_selection>
                    <default>QS_INTERFACE_MSC_RAM_DISK</default>
                </quick_selections>
                <reference id="interface_name" type="interface_name_t" label="Custom interface name"/>
                <reference id="subclass" type="subclass_msc_t" label="Subclass"/>
                <reference id="protocol" type="protocol_msc_t" label="Protocol"/>
                <info id="classImplementationBegin" label="Class implementation code" value="`Class implementation code for interface (` + $parent.interface_name.getValue() + `)`" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"/>
                <reference id="implementation" type="implementation_msc_t" label="Generate code example">
                    <options_expr>
                        <option id="UI_OPEN_DOCUMENTATION" expr="`workflow.md`"/>
                    </options_expr>
                    <description>This setting allows generating of the example code for the USB MSC class.</description>
                </reference>
                <info id="classImplementationInfo" label=" " value="$parent.implementation.enumItemsOf().findFirst(x -> (x.getId() == $parent.implementation.getEnumItemId())).getDescription()"/>
                <info id="classImplementationEnd" label="Class implementation code" value="``" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"/>
                <reference id="starting_in_ep_nr" type="starting_in_ep_nr_t" available="$this.getMode() == `device`"/>
                <reference id="starting_out_ep_nr" type="starting_out_ep_nr_t" available="$this.getMode() == `device`"/>
                <array id="endpoints_settings" type="endpoints_setting_msc_t" label="Interface setting" min_expr="1" options="ShowContentAs=TABS;UI_ARRAY_REORDER" key_selector_expr="setting -> setting.generateSettingKey()" available="$this.getMode() == `device`">
                    <description>Setting 0 is the default setting. Others are alternate setting.</description>
                    <validation>
                        <constraint cond_expr="$this.getSize() &lt; 2" when_expr="isSomeImplementationSelectedFromEpsSettings()" level="warning" description="Selected implementation expects only one endpoints setting"/>
                    </validation>
                </array>
                <reference id="in_ep_count" type="in_ep_count_t" available="$this.getMode() == `device`"/>
                <reference id="out_ep_count" type="out_ep_count_t" available="$this.getMode() == `device`"/>
            </struct>
            <struct id="setting_dfu_t" from="_setting_dfu_t">
                <quick_selections>
                    <quick_selection id="QS_INTERFACE_DFU_NONE" label="None" available="$this.getMode() == `device`">
                        <set id="interface_name">DFU</set>
                        <set id="implementation">kImplementationNone</set>
                        <set id="subclass">kSubclassDfu</set>
                        <set id="protocol">kProtocolDfuIdle</set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                        <set id="programming_mode_pid">0x00AC</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_DFU_APP" label="DFU (initial mode: app-idle) (bare metal)" available="$this.getMode() == `device`">
                        <set id="interface_name">DFU</set>
                        <set id="implementation">kImplementationDfu</set>
                        <set id="subclass">kSubclassDfu</set>
                        <set id="protocol">kProtocolAppIdle</set>
                        <set id="dfu_mode_pid">0x00A1</set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_DFU_DFU" label="DFU (initial mode: dfu-idle) (bare metal)" available="$this.getMode() == `device`">
                        <set id="interface_name">DFU</set>
                        <set id="implementation">kImplementationDfu</set>
                        <set id="subclass">kSubclassDfu</set>
                        <set id="protocol">kProtocolDfuIdle</set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                    </quick_selection>
                    <default>QS_INTERFACE_DFU_APP</default>
                </quick_selections>
                <reference id="interface_name" type="interface_name_t" label="Custom interface name"/>
                <reference id="subclass" type="subclass_appspecific_t" label="Subclass"/> 
                <reference id="protocol" type="protocol_dfu_t" label="Protocol"/>
                <info id="classImplementationBegin" label="Class implementation code" value="`Class implementation code for interface (` + $parent.interface_name.getValue() + `)`" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"/>
                <reference id="implementation" type="implementation_dfu_t" label="Generate code example">
                    <options_expr>
                        <option id="UI_OPEN_DOCUMENTATION" expr="`workflow.md`"/>
                    </options_expr>
                    <description>This setting allows generating of the example code for the USB DFU class.</description>
                </reference>
                <info id="classImplementationInfo" label=" " value="$parent.implementation.enumItemsOf().findFirst(x -> (x.getId() == $parent.implementation.getEnumItemId())).getDescription()"/>
                <info id="classImplementationEnd" label="Class implementation code" value="``" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"/>
                <integer id="dfu_mode_pid" type="uint16_t" label="DFU mode Product ID" available="$parent.protocol.getValue() == `kProtocolAppIdle`" >
                    <description>This is Product ID that device sends when re-enumerating in DFU-mode.</description>
                    <validation>
                        <constraint cond_expr="$configSet.product_id.getValue() != $this.getValue()" level="error" description="DFU mode Product ID cannot match standard Product ID."/>
                    </validation>
                </integer>
                <reference id="starting_in_ep_nr" type="starting_in_ep_nr_t" available="$this.getMode() == `device`"/>
                <reference id="starting_out_ep_nr" type="starting_out_ep_nr_t" available="$this.getMode() == `device`"/>
                <array id="endpoints_settings" type="endpoints_setting_dfu_t" label="Interface setting" min_expr="1" options="ShowContentAs=TABS;UI_ARRAY_REORDER" key_selector_expr="setting -> setting.generateSettingKey()" available="$this.getMode() == `device`">
                    <description>Setting 0 is the default setting. Others are alternate setting.</description>
                    <validation>
                        <constraint cond_expr="$this.getSize() &lt; 2" when_expr="isSomeImplementationSelectedFromEpsSettings()" level="warning" description="Selected implementation expects only one endpoints setting"/>
                    </validation>
                </array>
                <reference id="in_ep_count" type="in_ep_count_t" available="$this.getMode() == `device`"/>
                <reference id="out_ep_count" type="out_ep_count_t" available="$this.getMode() == `device`"/>
                <integer id="firmware_address" type="uint32_t" label="Firmware destination address" >
                    <description>Starting address of memory location where downloaded firmware will be stored in. Selected memory location should not overlap with firmware currenlty being run by device MCU. The manifestation code generated by this tool requires targeted memory location to be executable.</description>
                </integer>
                <integer id="firmware_size" type="uint32_t" label="Firmware maximum size">
                    <description>Maximum size of firmware that can be written in memory.</description>
                    <validation>
                        <constraint cond_expr="$this.getValue() != 0" level="error" description="Firmware maximum size must be greater than 0." />
                    </validation>
                </integer>          
            </struct>
            <struct id="setting_phdc_t" from="_setting_phdc_t">
                <quick_selections>
                    <quick_selection id="QS_INTERFACE_PHDC_NONE" label="None">
                        <set id="interface_name">PHDC</set>
                        <set id="implementation">kImplementationNone</set>
                        <set id="subclass">kSubclassNone</set>
                        <set id="protocol">kProtocolNone</set>
                        <set id="endpoints_settings.0"></set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_PHDC_WEIGHT_SCALE" label="Weight scale (bare metal)" available="$this.getMode() == `device`">
                        <set id="interface_name">PHDC Weight scale</set>
                        <set id="implementation">kImplementationWeightScale</set>
                        <set id="subclass">kSubclassNone</set>
                        <set id="protocol">kProtocolNone</set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                        <set id="endpoints_settings.0.endpoints.0.direction">kIn</set>
                        <set id="endpoints_settings.0.endpoints.0.transfer_type">kBulk</set>
                        <set id="endpoints_settings.0.endpoints.0.max_packet_size_fs">k64</set>
                        <set id="endpoints_settings.0.endpoints.0.polling_interval_fs">0</set>
                        <set id="endpoints_settings.0.endpoints.0.max_packet_size_hs">k64</set>
                        <set id="endpoints_settings.0.endpoints.0.polling_interval_hs">0</set>
                        <set id="endpoints_settings.0.endpoints.1.direction">kOut</set>
                        <set id="endpoints_settings.0.endpoints.1.transfer_type">kBulk</set>
                        <set id="endpoints_settings.0.endpoints.1.max_packet_size_fs">k64</set>
                        <set id="endpoints_settings.0.endpoints.1.polling_interval_fs">0</set>
                        <set id="endpoints_settings.0.endpoints.1.max_packet_size_hs">k64</set>
                        <set id="endpoints_settings.0.endpoints.1.polling_interval_hs">0</set>
                        <set id="endpoints_settings.0.endpoints.2.transfer_type">kInterrupt</set>
                        <set id="endpoints_settings.0.endpoints.2.max_packet_size_fs">k8</set>
                        <set id="endpoints_settings.0.endpoints.2.polling_interval_fs">1</set>
                        <set id="endpoints_settings.0.endpoints.2.max_packet_size_hs">k8</set>
                        <set id="endpoints_settings.0.endpoints.2.polling_interval_hs">4</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_PHDC_MANAGER" label="Manager (bare metal)" available="$this.getMode() == `host`">
                        <set id="interface_name">PHDC Manager</set>
                        <set id="implementation">kImplementationManager</set>
                        <set id="subclass">kSubclassNone</set>
                        <set id="protocol">kProtocolNone</set>
                    </quick_selection>
                </quick_selections>
                <reference id="interface_name" type="interface_name_t" label="Custom interface name"/>
                <reference id="subclass" type="subclass_phdc_t" label="Subclass"/>
                <reference id="protocol" type="protocol_phdc_t" label="Protocol"/>
                <info id="classImplementationBegin" label="Class implementation code" value="`Class implementation code for interface (` + $parent.interface_name.getValue() + `)`" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"/>
                <reference id="implementation" type="implementation_phdc_t" label="Generate code example">
                    <options_expr>
                        <option id="UI_OPEN_DOCUMENTATION" expr="`workflow.md`"/>
                    </options_expr>
                    <description>This setting allows generating of the example code for the USB PHDC class.</description>
                </reference>
                <info id="classImplementationInfo" label=" " value="$parent.implementation.enumItemsOf().findFirst(x -> (x.getId() == $parent.implementation.getEnumItemId())).getDescription()"/>
                <info id="classImplementationEnd" label="Class implementation code" value="``" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"/>
                <reference id="starting_in_ep_nr" type="starting_in_ep_nr_t" available="$this.getMode() == `device`"/>
                <reference id="starting_out_ep_nr" type="starting_out_ep_nr_t" available="$this.getMode() == `device`"/>
                <array id="endpoints_settings" type="endpoints_setting_phdc_t" label="Interface setting" min_expr="1" options="ShowContentAs=TABS;UI_ARRAY_REORDER" key_selector_expr="setting -> setting.generateSettingKey()" available="$this.getMode() == `device`">
                    <description>Setting 0 is the default setting. Others are alternate setting.</description>
                    <validation>
                        <constraint cond_expr="$this.getSize() &lt; 2" when_expr="isSomeImplementationSelectedFromEpsSettings()" level="warning" description="Selected implementation expects only one endpoints setting"/>
                    </validation>
                </array>
                <reference id="in_ep_count" type="in_ep_count_t" available="$this.getMode() == `device`"/>
                <reference id="out_ep_count" type="out_ep_count_t" available="$this.getMode() == `device`"/>
            </struct>
            <struct id="setting_printer_t" from="_setting_printer_t">
                <quick_selections>
                    <quick_selection id="QS_INTERFACE_PRINTER_NONE" label="None">
                        <set id="interface_name">Printer</set>
                        <set id="implementation">kImplementationNone</set>
                        <set id="subclass">kSubclassPrinters</set>
                        <set id="protocol">kProtocolBiDirectional</set>
                        <set id="endpoints_settings.0"></set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_PRINTER_PLAIN_TEXT" label="Plain text (bare metal)">
                        <set id="interface_name">Printer</set>
                        <set id="implementation">kImplementationPlainTextPrinter</set>
                        <set id="subclass">kSubclassPrinters</set>
                        <set id="protocol">kProtocolBiDirectional</set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                        <set id="endpoints_settings.0.endpoints.0.direction">kOut</set>
                        <set id="endpoints_settings.0.endpoints.0.transfer_type">kBulk</set>
                        <set id="endpoints_settings.0.endpoints.0.max_packet_size_fs">k64</set>
                        <set id="endpoints_settings.0.endpoints.0.polling_interval_fs">4</set>
                        <set id="endpoints_settings.0.endpoints.0.max_packet_size_hs">k64</set>
                        <set id="endpoints_settings.0.endpoints.0.polling_interval_hs">6</set>
                        <set id="endpoints_settings.0.endpoints.1.direction">kIn</set>
                        <set id="endpoints_settings.0.endpoints.1.transfer_type">kBulk</set>
                        <set id="endpoints_settings.0.endpoints.1.max_packet_size_fs">k64</set>
                        <set id="endpoints_settings.0.endpoints.1.polling_interval_fs">4</set>
                        <set id="endpoints_settings.0.endpoints.1.max_packet_size_hs">k64</set>
                        <set id="endpoints_settings.0.endpoints.1.polling_interval_hs">6</set>
                    </quick_selection>
                    <default>QS_INTERFACE_PRINTER_PLAIN_TEXT</default>
                </quick_selections>
                <reference id="interface_name" type="interface_name_t" label="Custom interface name"/>
                <reference id="subclass" type="subclass_printer_t" label="Subclass"/>
                <reference id="protocol" type="protocol_printer_t" label="Protocol"/>
                <info id="classImplementationBegin" label="Class implementation code" value="`Class implementation code for interface (` + $parent.interface_name.getValue() + `)`" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"/>
                <reference id="implementation" type="implementation_printer_t" label="Generate code example">
                    <options_expr>
                        <option id="UI_OPEN_DOCUMENTATION" expr="`workflow.md`"/>
                    </options_expr>
                    <description>This setting allows generating of the example code for the USB Printer class.</description>
                </reference>
                <info id="classImplementationInfo" label=" " value="$parent.implementation.enumItemsOf().findFirst(x -> (x.getId() == $parent.implementation.getEnumItemId())).getDescription()"/>
                <info id="classImplementationEnd" label="Class implementation code" value="``" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"/>
                <reference id="starting_in_ep_nr" type="starting_in_ep_nr_t" available="$this.getMode() == `device`"/>
                <reference id="starting_out_ep_nr" type="starting_out_ep_nr_t" available="$this.getMode() == `device`"/>
                <array id="endpoints_settings" type="endpoints_setting_printer_t" label="Interface setting" min_expr="1" options="ShowContentAs=TABS;UI_ARRAY_REORDER" key_selector_expr="setting -> setting.generateSettingKey()" available="$this.getMode() == `device`">
                    <description>Setting 0 is the default setting. Others are alternate setting.</description>
                    <validation>
                        <constraint cond_expr="$this.getSize() &lt; 2" when_expr="isSomeImplementationSelectedFromEpsSettings()" level="warning" description="Selected implementation expects only one endpoints setting"/>
                    </validation>
                </array>
                <reference id="in_ep_count" type="in_ep_count_t" available="$this.getMode() == `device`"/>
                <reference id="out_ep_count" type="out_ep_count_t" available="$this.getMode() == `device`"/>
            </struct>
            <!-- AUDIO CLASS TYPES -->
            <enum id="audio_unit_t">
                <item id="kInputTerminal" label="Input terminal" value="USB_INTERFACE_SUBTYPE_AUDIO_CONTROL_INPUT_TERMINAL">
                    <description>
The Input Terminal (IT) is used to interface between the audio function’s ‘outside world’ and other Units in the audio function. 
It serves as a receptacle for audio information flowing into the audio function. Its function is to represent a source of incoming audio 
data after this data has been properly extracted from the original audio stream into the separate logical channels that are embedded in this 
stream (the decoding process). The logical channels are grouped into an audio channel cluster and leave the Input Terminal through a single Output Pin.
                    </description>
                </item>
                <item id="kOutputTerminal" label="Output terminal" value="USB_INTERFACE_SUBTYPE_AUDIO_CONTROL_OUTPUT_TERMINAL">
                    <description>
The Output Terminal (OT) is used to interface between Units inside the audio function and the ‘outside world’. 
It serves as an outlet for audio information, flowing out of the audio function. Its function is to represent a sink of outgoing audio data 
before this data is properly packed from the original separate logical channels into the outgoing audio stream (the encoding process). 
The audio channel cluster enters the Output Terminal through a single Input Pin.
                    </description>
                </item>
                <item id="kFeatureUnit" label="Feature unit" value="USB_INTERFACE_SUBTYPE_AUDIO_CONTROL_FEATURE_UNIT">
                    <description>
The Feature Unit (FU) provides basic manipulation of multiple single-parameter Audio Controls on the incoming logical channels. 
It supports the following features: Mute, Volumne, Tone Control, Graphic Equalizer, Automatic Gain Control, Delay, Bass Boost and Loudness.
                    </description>
                </item>
            </enum>
            <enum id="input_terminal_t">
                <!-- USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_UNDEFINED -->
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_UNDEFINED" label="Undefined" value="0x0100">
                    <description>USB Terminal, undefined Type.</description>
                </item>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_STREAMING" label="Streaming" value="0x0101">
                    <description>A Terminal dealing with a signal carried over an endpoint in an audio streaming interface. The audio streaming interface descriptor points to the associated Terminal through the Terminal Link field.</description>
                </item>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_VENDOR_SPECIFIC" label="Vendor specific" value="0x01FF">
                    <description>A Terminal dealing with a signal carried over a vendor-specific interface. The vendor-specific interface descriptor must contain a field that references the Terminal.</description>
                </item>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_UNDEFINED" label="Input undefined" value="0x0200">
                    <description>Input Terminal, undefined Type.</description>
                </item>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_MICROPHONE" label="Microphone" value="0x0201">
                    <description>A generic microphone that does not fit under any of the other classifications.</description>
                </item>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_DESKTOP_MICROPHONE" label="Desktop microphone" value="0x0202">
                    <description>A microphone normally placed on the desktop or integrated into the monitor.</description>
                </item>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_PERSONAL_MICROPHONE" label="Personal microphone" value="0x0203">
                    <description>A head-mounted or clip-on microphone.</description>
                </item>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_OMNI_DIRECTION_MICROPHONE" label="Omni-directional microphone" value="0x0204">
                    <description>A microphone designed to pick up voice from more than one speaker at relatively long ranges.</description>
                </item>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_MICROPHONE_ARRAY" label="Microphone array" value="0x0205">
                    <description>An array of microphones designed for directional processing using host-based signal processing algorithms.</description>
                </item>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_PROCESSING_MICROPHONE_ARRAY" label="Processing microphone array" value="0x0206">
                    <description>An array of microphones with an embedded signal processor.</description>
                </item>
            </enum>
            <enum id="output_terminal_t">
                <item id="kUSBUndefined" label="Undefined" value="0x0100">
                    <description>USB Terminal, undefined Type.</description>
                </item>
                <item id="kUSBStreaming" label="Streaming" value="0x0101">
                    <description>A Terminal dealing with a signal carried over an endpoint in an audio streaming interface. The audio streaming interface descriptor points to the associated Terminal through the Terminal Link field.</description>
                </item>
                <item id="kUSBVendorSpecific" label="Vendor specific" value="0x01FF">
                    <description>A Terminal dealing with a signal carried over a vendor-specific interface. The vendor-specific interface descriptor must contain a field that references the Terminal.</description>
                </item>
                <item id="kInputUndefined" label="Output undefined" value="0x0300">
                    <description>Output Terminal, undefined Type.</description>
                </item>
                <item id="kSpeaker" label="Speaker" value="0x0301">
                    <description>A generic speaker or set of speakers that does not fit under any classifications.</description>
                </item>
                <item id="kHeadphones" label="Headphones" value="0x0302">
                    <description>A head-mounted audio output device.</description>
                </item>
                <item id="kHeadMountedDisplayAudio" label="Head Mounted Display Audio" value="0x0303">
                    <description>The audio part of a virtual reality head mounted display. The Associated Interfaces descriptor can be used to reference the HID interface used to report the position and orientation of the Head Mounted Display.</description>
                </item>
                <item id="kDesktoSpeaker" label="Desktop speaker" value="0x0304">
                    <description>Relatively small speaker or set of speakers normally placed on the desktop or integrated into the monitor. These speakers are close to the user and have limited stereo separation.</description>
                </item>
                <item id="kRoomSpeaker" label="Room speaker" value="0x0305">
                    <description>Larger speaker or set of speakers that are heard well anywhere in the room.</description>
                </item>
                <item id="kCommunicationSpeaker" label="Communication speaker" value="0x0306">
                    <description>Speaker or set of speakers designed for voice communication.</description>
                </item>
                <item id="kLowFrequencyEffectsSpeaker" label="Low frequency effects speaker" value="0x0307">
                    <description>Speaker designed for low frequencies (subwoofer). Not capable of reproducing speech or music.</description>
                </item>
            </enum>
            <set id="channel_config_t">
                <description>Spatial location configuration of the logical channels.</description>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_L" label="Left Front (L)" value="0x1"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_R" label="Right Front (R)" value="0x2"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_C" label="Center Front (C)" value="0x4"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_LFE" label="Low Frequency Enhancement (LFE)" value="0x8"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_LS" label="Left Surround (LS)" value="0x10"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_RS" label="Right Surround (RS)" value="0x20"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_LC" label="Left of Center (LC)" value="0x40"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_RC" label="Right of Center (RC)" value="0x80"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_S" label="Surround (S)" value="0x100"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_SL" label="Side Left (SL)" value="0x200"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_SR" label="Side Right (SR)" value="0x400"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_T" label="Top (T)" value="0x800"/>
            </set>
            <set id="audio_control_t">
                <item id="kMute" label="Mute" value="0x1">
                    <description>Mute control</description>
                </item>
                <item id="kVolume" label="Volume" value="0x2">
                    <description>Volume control</description>
                </item>
                <item id="kBass" label="Bass" value="0x4">
                    <description>Bass control</description>
                </item>
                <item id="kMid" label="Mid" value="0x8">
                    <description>Mid control</description>
                </item>
                <item id="kTreble" label="Treble" value="0x10">
                    <description>Treble control</description>
                </item>
                <item id="kGraphicEqualizer" label="Graphic equalizer" value="0x20">
                    <description>Graphic Equalizer control</description>
                </item>
                <item id="kAutomaticGain" label="Automatic gain" value="0x40">
                    <description>Automatic gain control</description>
                </item>
                <item id="kDelay" label="Delay" value="0x80">
                    <description>Delay control</description>
                </item>
                <item id="kBassBoost" label="Bass boost" value="0x100">
                    <description>Bass boost control</description>
                </item>
                <item id="kLoudness" label="Loudness" value="0x200">
                    <description>control</description>
                </item>
            </set>
            <!-- Input terminal descriptor settings -->
            <struct id="input_terminal_config_t">
                <variable id="key_name" value="$parent.bTerminalID.getValue() + ` - Input teminal`"/>
                <integer id="bTerminalID" label="Terminal ID" type="uint8_t" options="audio_unit_id" min_expr="1" max_expr="255">
                    <description>Each terminal (any unit) within the audio function is assigned a unique identification that is used for addressing. The value 0x00 is reserved for undefined ID.</description>
                    <validation>
                        <constraint cond_expr="$parent.getParent().getParent().countOccurrences(item -> (item.isAvailable() &amp;&amp; item.isEnabled() &amp;&amp; item.hasOption(`audio_unit_id`) &amp;&amp; (item.getValue() == $this.getValue())), true) == 1" level="error" description_expr="`Duplicated ID ` + $this.getValue() + `of an audio unit/terminal is used. Select different ID.`"/>
                    </validation>
                </integer>
                <reference id="_wTerminalType" label="Terminal type" type="input_terminal_t" available="false"/>
                <dynamic_enum id="wTerminalType" label="Terminal type" items="enumItemsOf($parent._wTerminalType).arrayToEnumItems(
                               enumItem -> true,
                               enumItem -> enumItem.getID(),
                               enumItem -> enumItem.getLabel(),
                               enumItem -> enumItem.getValue(),
                               enumItem -> enumItem.getDescription())">
                    <description>This setting provides pertinent information about the physical entity that the input terminal represents. This could be a USB OUT endpoint, an external Line In connection, a microphone, etc. A complete list of Terminal Type codes is provided in USB Audio Terminal Types specification.</description>
                    <custom_value_support default="0x01FF" validation_expr="x -> x.isValidIntegerValue(0, 0xFFFF)"/>
                </dynamic_enum>
                <!-- Associated output terminal is not supported -->
                <!-- <dynamic_enum id="bAssocTerminal" label="Associated output terminal" items="createArray().addItemToList(`noAssociation`, `No association`, `0`, true)">
                    <description>This setting is used to associate an output terminal to this input terminal, effectively implementing a bi-directional Terminal pair. The ID (number) of the associated output terminal must be set. 
                        If used, both associated terminals must belong to the bi-directional Terminal Type group. If no association exists, the setting must be set to zero (no association).</description>
                    <custom_value_support default="0" validation_expr="x -> x.isValidIntegerValue(0, 0xFF)"/>
                </dynamic_enum>-->
                <integer id="bNrChannels" label="Number of channels" type="uint8_t">
                    <description>Number of logical output channels in the terminal’s output audio channel cluster.</description>
                </integer>
                <reference id="wChannelConfig" label="Spatial location" type="channel_config_t">
                    <description>Spatial location of the logical channels.</description>
                </reference>
            </struct>
            <!-- Output terminal descriptor settings -->
            <struct id="output_terminal_config_t">
                <variable id="key_name" value="$parent.bTerminalID.getValue() + ` - Output teminal`"/>
                <integer id="bTerminalID" label="Terminal ID" type="uint8_t" options="audio_unit_id" min_expr="1" max_expr="255">
                    <description>Each terminal (any unit) within the audio function is assigned a unique identification that is used for addressing. The value 0x00 is reserved for undefined ID.</description>
                    <validation>
                        <constraint cond_expr="$parent.getParent().getParent().countOccurrences(item -> (item.isAvailable() &amp;&amp; item.isEnabled() &amp;&amp; item.hasOption(`audio_unit_id`) &amp;&amp; (item.getValue() == $this.getValue())), true) == 1" level="error" description_expr="`Duplicated ID ` + $this.getValue() + `of an audio unit/terminal is used. Select different ID.`"/>
                    </validation>
                </integer>
                <reference id="_wTerminalType" label="Terminal type" type="output_terminal_t" available="false"></reference>
                <dynamic_enum id="wTerminalType" label="Terminal type" items="enumItemsOf($parent._wTerminalType).arrayToEnumItems(
                               enumItem -> true,
                               enumItem -> enumItem.getID(),
                               enumItem -> enumItem.getLabel(),
                               enumItem -> enumItem.getValue(),
                               enumItem -> enumItem.getDescription())">
                    <description>This setting provides pertinent information about the physical entity that the output terminal represents. This could be a USB OUT endpoint, an external Line Out connection, a speaker, etc. A complete list of Terminal Type codes is provided in USB Audio Terminal Types specification.</description>
                    <custom_value_support default="0x01FF" validation_expr="x -> x.isValidIntegerValue(0, 0xFFFF)"/>
                </dynamic_enum>
                <!-- Associated input terminal is not supported -->
                <!-- <dynamic_enum id="bAssocTerminal" label="Associated input terminal" items="createArray().addItemToList(`noAssociation`, `No association`, `0`, true)">
                    <description>This setting is used to associate an input terminal to this output terminal, effectively implementing a bi-directional Terminal pair. The ID (number) of the associated input terminal must be set. 
                        If used, both associated terminals must belong to the bi-directional Terminal Type group. If no association exists, the setting must be set to zero (no association).</description>
                    <custom_value_support default="0" validation_expr="x -> x.isValidIntegerValue(0, 0xFF)"/>
                </dynamic_enum>-->
                <integer id="bSourceID" label="Source ID" type="uint8_t" min_expr="1" max_expr="255">
                    <description>ID of the unit or terminal to which this output terminal is connected.</description>
                </integer>
            </struct>
            <!-- Feature Unit descriptor settings -->
            <struct id="feature_unit_config_t">
                <!-- ITEMS -->
                <variable id="key_name" value="$parent.bUnitID.getValue() + ` - Feature unit`"/>
                <integer id="bUnitID" label="Unit ID" type="uint8_t" options="audio_unit_id" min_expr="1" max_expr="255">
                    <description>Each unit within the audio function is assigned a unique identification that is used for addressing. The value 0x00 is reserved for undefined ID.</description>
                    <validation>
                        <constraint cond_expr="$parent.getParent().getParent().countOccurrences(item -> (item.isAvailable() &amp;&amp; item.isEnabled() &amp;&amp; item.hasOption(`audio_unit_id`) &amp;&amp; (item.getValue() == $this.getValue())), true) == 1" level="error" description_expr="`Duplicated ID ` + $this.getValue() + `of an audio unit/terminal is used. Select different ID.`"/>
                    </validation>
                </integer>
                <integer id="bSourceID" label="Source ID" type="uint8_t" min_expr="1" max_expr="255">
                    <description>ID of the unit or terminal to which this output terminal is connected.</description>
                </integer>
                <!-- bControlSize specify the size of each element of the array -->
                <variable id="bControlSize" value="($parent.bmaControls.countOccurrences(item -> ((item.getSetting(`kBassBoost`).getValue()) || (item.getSetting(`kLoudness`).getValue())) ) &gt; 0) ? 2 : 1"/>
                <array id="bmaControls" label="Controls" type="audio_control_t" min_expr="1" key_selector_expr="x -> ((x.getID() == 0) ? `Master channel` : `Channel ` + x.getID())"/>
                <!-- Length of the feature unit descriptor - calculation is based on the bmaControls array length -->
                <variable id="bLength" value="7 + ($parent.bmaControls.getLength() * $parent.bControlSize.getValue())"/>
            </struct>
            <struct id="audio_unit_config_t">
                <reference id="audio_unit" label="Audio Unit" type="audio_unit_t"/>
                <variable id="unit_ref"
                    value="($parent.audio_unit.getValue() == `kInputTerminal`) 
                    ? $parent.input_terminal 
                    : ($parent.audio_unit.getValue() == `kOutputTerminal`)
                    ? $parent.output_terminal
                    : $parent.feature_unit"/>
                <reference id="input_terminal" label="Input terminal" type="input_terminal_config_t" available="$parent.audio_unit.getValue() == `kInputTerminal`">
                    <description>
The Input Terminal (IT) is used to interface between the audio function’s "outside world" and other Units in the audio function. It serves as a receptacle for audio information flowing into the audio function. 
Its function is to represent a source of incoming audio data after this data has been properly extracted from the original audio stream into the separate logical channels that are embedded in this stream.</description>
                </reference>
                <reference id="output_terminal" label="Output terminal" type="output_terminal_config_t" available="$parent.audio_unit.getValue() == `kOutputTerminal`">
                    <description>
The Output Terminal (OT) is used to interface between Units inside the audio function and the "outside world". It serves as an outlet for audio information, flowing out of the audio function. 
Its function is to represent a sink of outgoing audio data before this data is properly packed from the original separate logical channels into the outgoing audio stream.                       
                    </description>
                </reference>
                <reference id="feature_unit" label="Feature unit" type="feature_unit_config_t" available="$parent.audio_unit.getValue() == `kFeatureUnit`">
                    <description>
The Feature Unit (FU) is essentially a at provides basic manipulation of multiple single-parameter Audio Controls on the incoming logical channels. 
It supports the following features: Mute, Volumne, Tone Control, Graphic Equalizer, Automatic Gain Control, Delay, Bass Boost and Loudness.
                    </description>
                </reference>
            </struct>
            <enum id="subclass_audio_t" from="_subclass_audio">
                <item id="kSubclassAudioControl" label="Audio control" value="1"/>
                <item id="kSubclassAudioStream" label="Audio stream" value="2"/>
            </enum>
            <enum id="protocol_audio_t" from="_protocol_audio">
                <item id="kProtocolNone" label="None"/>
            </enum>
            <enum id="implementation_audio_t" from="_implementation_audio">
                <item id="kImplementationNone" label="Disabled">
                    <description>Interface control functions are not generated in the interface files.</description>
                </item>
                <item id="kImplementationAudioSpeaker" label="Audio speaker (bare metal)" available="$parent.subclass.getValue() != `kSubclassAudioStream`">
                    <description>Audio speaker code example that is enumerated as a playback device.</description>
                </item>
                <item id="kImplementationAudioGenerator" label="Audio generator (bare metal)" available="$parent.subclass.getValue() != `kSubclassAudioStream` &amp;&amp; $parent.getParent().getSetting(`interface_class`).getValue() == `kClassAudio_2_0`">
                    <description>Audio generator code example that is enumerated as a microphone device.</description>
                </item>
                <item id="kImplementationAudioUnified" label="Audio unified (bare metal)" available="$parent.subclass.getValue() != `kSubclassAudioStream` &amp;&amp; $parent.getParent().getSetting(`interface_class`).getValue() == `kClassAudio_2_0`">
                    <description>Audio speaker and microphone code example that is enumerated as a headset (unified) device.</description>
                </item>
            </enum>
            <!-- USB Audio 1.0 control and streaming structure -->
            <struct id="setting_audio_t" from="_setting_audio_t">
                <quick_selections>
                    <quick_selection id="QS_INTERFACE_AUDIO_CLASS" label="Audio default">
                        <set id="interface_name">Audio 1_0</set>
                        <set id="implementation">kImplementationNone</set>
                        <set id="subclass">kSubclassAudioControl</set>
                        <set id="protocol">kProtocolNone</set>
                        <set id="data_interface_count">0</set>
                        <set id="endpoints_settings.0"></set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_AUDIO_CONTROL_SPEAKER" label="Audio control - speaker">
                        <set id="interface_name">Audio control</set>
                        <set id="implementation">kImplementationAudioSpeaker</set>
                        <set id="subclass">kSubclassAudioControl</set>
                        <set id="protocol">kProtocolNone</set>
                        <set id="audio_units.0"></set>
                        <set id="audio_units.0.audio_unit">kInputTerminal</set>
                        <!-- Input terminal -->
                        <set id="audio_units.0.input_terminal.bTerminalID">1</set>
                        <set id="audio_units.0.input_terminal.wTerminalType">USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_STREAMING</set>
                        <set id="audio_units.0.input_terminal.bNrChannels">2</set>
                        <set id="audio_units.0.input_terminal.wChannelConfig.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_L">true</set>
                        <set id="audio_units.0.input_terminal.wChannelConfig.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_R">true</set>
                        <!-- Feature unit -->
                        <set id="audio_units.1"></set>
                        <set id="audio_units.1.audio_unit">kFeatureUnit</set>
                        <set id="audio_units.1.feature_unit.bUnitID">2</set>
                        <set id="audio_units.1.feature_unit.bSourceID">1</set>
                        <set id="audio_units.1.feature_unit.bmaControls.0"></set>
                        <set id="audio_units.1.feature_unit.bmaControls.0.kMute">true</set>
                        <set id="audio_units.1.feature_unit.bmaControls.0.kVolume">true</set>
                        <set id="audio_units.1.feature_unit.bmaControls.1"></set>
                        <set id="audio_units.1.feature_unit.bmaControls.2"></set>
                        <!-- Output terminal -->
                        <set id="audio_units.2"></set>
                        <set id="audio_units.2.audio_unit">kOutputTerminal</set>
                        <set id="audio_units.2.output_terminal.bTerminalID">3</set>
                        <set id="audio_units.2.output_terminal.wTerminalType">kSpeaker</set>
                        <set id="audio_units.2.output_terminal.bSourceID">2</set>
                        <!-- Interrupt endpoint settings -->
                        <set id="endpoints_settings.0.setting_name">Data input</set>
                        <set id="endpoints_settings.0.endpoints.0"></set>
                        <set id="endpoints_settings.0.endpoints.0.direction">kIn</set>
                        <set id="endpoints_settings.0.endpoints.0.transfer_type">kInterrupt</set>
                        <set id="endpoints_settings.0.endpoints.0.max_packet_size_fs">k8</set>
                        <set id="endpoints_settings.0.endpoints.0.polling_interval_fs">8</set>
                        <set id="endpoints_settings.0.endpoints.0.max_packet_size_hs">k8</set>
                        <set id="endpoints_settings.0.endpoints.0.polling_interval_hs">7</set>
                        <set id="endpoints_settings.0.endpoints.0.bRefresh">0</set>
                        <set id="endpoints_settings.0.endpoints.0.bSynchAddress">NoSynchronization</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_AUDIO_STREAM_SPEAKER" label="Audio stream - speaker">
                        <set id="interface_name">Audio streaming</set>
                        <set id="implementation">kImplementationNone</set>
                        <set id="subclass">kSubclassAudioStream</set>
                        <set id="protocol">kProtocolNone</set>
                        <set id="endpoints_settings.0.setting_name">Zero bandwidth</set>
                        <set id="endpoints_settings.1.setting_name">Data output</set>
                        <!-- Data endpoint -->
                        <set id="endpoints_settings.1.endpoints.0"></set>
                        <set id="endpoints_settings.1.endpoints.0.direction">kOut</set>
                        <set id="endpoints_settings.1.endpoints.0.transfer_type">kIsochronous</set>
                        <set id="endpoints_settings.1.endpoints.0.synchronization">kAsynchronous</set>
                        <set id="endpoints_settings.1.endpoints.0.usage">kData</set>
                        <set id="endpoints_settings.1.endpoints.0.max_packet_size_fs">custom:196</set>
                        <set id="endpoints_settings.1.endpoints.0.polling_interval_fs">1</set>
                        <set id="endpoints_settings.1.endpoints.0.max_packet_size_hs">custom:196</set>
                        <set id="endpoints_settings.1.endpoints.0.polling_interval_hs">4</set>
                        <set id="endpoints_settings.1.endpoints.0.bRefresh">0</set>
                        <set id="endpoints_settings.1.endpoints.0.bSynchAddress">Address_130</set>
                        <!-- Feedback endpoint -->
                        <set id="endpoints_settings.1.endpoints.1"></set>
                        <set id="endpoints_settings.1.endpoints.1.direction">kIn</set>
                        <set id="endpoints_settings.1.endpoints.1.transfer_type">kIsochronous</set>
                        <set id="endpoints_settings.1.endpoints.1.synchronization">kAsynchronous</set>
                        <set id="endpoints_settings.1.endpoints.1.usage">kFeedback</set>
                        <set id="endpoints_settings.1.endpoints.1.max_packet_size_fs">custom:3</set>
                        <set id="endpoints_settings.1.endpoints.1.polling_interval_fs">1</set>
                        <set id="endpoints_settings.1.endpoints.1.max_packet_size_hs">custom:3</set>
                        <set id="endpoints_settings.1.endpoints.1.polling_interval_hs">4</set>
                        <set id="endpoints_settings.1.endpoints.1.bRefresh">5</set>
                        <set id="endpoints_settings.1.endpoints.1.bSynchAddress">NoSynchronization</set>
                        <!-- Audio stream and data format setting -->
                        <set id="endpoints_settings.1.header.bTerminalLink">bTerminalID_1</set>
                        <set id="endpoints_settings.1.header.bDelay">1</set>
                        <set id="endpoints_settings.1.header.wFormatTag">kPCM</set>
                        <set id="endpoints_settings.1.format.bFormatType">kFormat_i</set>
                        <set id="endpoints_settings.1.format.bNrChannels">2</set>
                        <set id="endpoints_settings.1.format.bSubframeSize">2</set>
                        <set id="endpoints_settings.1.format.bBitResolution">16</set>
                        <set id="endpoints_settings.1.format.sampleFreqSel">kList</set>
                        <set id="endpoints_settings.1.format.tSamFreqList.0">48000</set>
                    </quick_selection>
                    <default>QS_INTERFACE_AUDIO_CLASS</default>
                </quick_selections>
                <reference id="interface_name" type="interface_name_t" label="Custom interface name"/>
                <reference id="subclass" type="subclass_audio_t" label="Subclass">
                    <validation>
                        <constraint when_expr="$this.getValue() == `kSubclassAudioControl`" cond_expr="$parent.getParent().getParent().countOccurrences(x -> (x.isAvailable() &amp;&amp; x.isEnabled() &amp;&amp; (x.getId() == `subclass`) &amp;&amp; (x.getValue() == `kSubclassAudioControl`)), true) == 1" level="error" 
                            description="This USB component supports one audio control interface only. All audio units shall be configured in the only one Audio control interface configuration."/>
                        <constraint when_expr="$this.getValue() == `kSubclassAudioStream`" cond_expr="($parent.getParent().getID() != `0`) &amp;&amp; ($parent.getParent().getParent().get($parent.getParent().getID().toInt() - 1).getSetting(`interface_class`).getValue() == `kClassAudio_1_0`) &amp;&amp;
                            (($parent.getParent().getParent().get($parent.getParent().getID().toInt() - 1).getSetting(`setting_audio_1_0.subclass`).getValue() == `kSubclassAudioControl`) || ($parent.getParent().getParent().get($parent.getParent().getID().toInt() - 1).getSetting(`setting_audio_1_0.subclass`).getValue() == `kSubclassAudioStream`))" level="error" 
                            description="The audio streaming interfaces (the Audio stream subclasses) must be placed just behind the USB audio control interface (the Audio control subclass) in the Supported interface list to provide the interface association descriptor (use the Move Up/Down buttons to fix the order of interfaces)."/>
                        <constraint when_expr="$this.getValue() == `kSubclassAudioStream`" cond_expr="$parent.getParent().getParent().countOccurrences(x -> (x.isAvailable() &amp;&amp; x.isEnabled() &amp;&amp; (x.getId() == `subclass`) &amp;&amp; (x.getValue() == `kSubclassAudioControl`)), true) &gt;= 1" level="error" 
                            description="The audio stream interface is a part of the audio function and it cannot be used alone. It must be used together with audio control interface."/> 
                        <constraint when_expr="$this.getValue() == `kSubclassAudioControl`" cond_expr="$parent.getParent().getParent().countOccurrences(x -> (x.isAvailable() &amp;&amp; x.isEnabled() &amp;&amp; (x.getId() == `subclass`) &amp;&amp; (x.getValue() == `kSubclassAudioStream`)), true) &gt;= 1" level="error" 
                            description="The audio control interface is a part of the audio function and it cannot be used alone. It must be used together with audio stream interface(s)."/> 
                    </validation>
                </reference>
                <reference id="protocol" type="protocol_audio_t" label="Protocol"/>
                <info id="classImplementationBegin" label="Class implementation code" value="`Class implementation code for interface (` + $parent.interface_name.getValue() + `)`" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"/>
                <reference id="implementation" type="implementation_audio_t" label="Generate code example">
                    <options_expr>
                        <option id="UI_OPEN_DOCUMENTATION" expr="`workflow.md`"/>
                    </options_expr>
                    <description>This setting allows generating of the example code. This seeting is enabled for the audio control subclass only. The audio streaming subclass is generated as a part of the audio example automatically.</description>
                </reference>
                <info id="classImplementationInfo" label=" " value="$parent.implementation.enumItemsOf().findFirst(x -> (x.getId() == $parent.implementation.getEnumItemId())).getDescription()"/>
                <info id="classImplementationEnd" label="Class implementation code" value="``" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"/>
                <!-- this setting enables/disables the generating of the template interface file when the implementation is None -->
                <variable id="generateTemplateInterface" value="($parent.subclass.getValue() == `kSubclassAudioStream`) ? false : true"></variable>
                <reference id="starting_in_ep_nr" type="starting_in_ep_nr_t" available="$this.getMode() == `device`"/>
                <reference id="starting_out_ep_nr" type="starting_out_ep_nr_t" available="$this.getMode() == `device`"/>
                <!-- Number of audio streaming interfaces for the header -->
                <variable id="number_of_audio_interfaces" value="$parent.getParent().getParent().countOccurrences(x -> (x.isAvailable() &amp;&amp; x.isEnabled() &amp;&amp; (x.getId() == `subclass`) &amp;&amp; (x.getValue() == `kSubclassAudioStream`)), true)"/>
                <!-- Array of audio streaming interface for the header -->
                <variable id="list_of_audio_interfaces" value="$parent.getParent().getParent().filter(x -> (x.isAvailable() &amp;&amp; x.isEnabled() &amp;&amp; (x.nodeExists(`subclass`)) &amp;&amp; (x.getSetting(`subclass`).getValue() == `kSubclassAudioStream`)), true).map(x -> x.getParent().getId())"/>
                <array id="endpoints_settings" label="Interface setting" type="endpoints_setting_audio_stream_t" min_expr="1" options="ShowContentAs=TABS;UI_ARRAY_REORDER" key_selector_expr="setting -> setting.generateSettingKey()" available="$this.getMode() == `device`">
                    <description>Audio control/streaming interface configuration including endpoints. Setting 0 is the default setting that should provide the zero bandwidth. Other interface configurations are alternate settings for streaming of audio data.</description>
                    <validation>
                        <constraint when_expr="($parent.subclass.getValue() == `kSubclassAudioControl`) &amp;&amp; ($this.getSize() &gt; 0) &amp;&amp; ($this.get(0).getSetting(`endpoints`).getSize() &gt; 0)"
                            cond_expr="($this.get(0).getSetting(`endpoints`).getSize() &lt; 2) &amp;&amp; (($this.get(0).getSetting(`endpoints`).getSize() == 0) || ($this.get(0).getSetting(`endpoints`).get(0).getSetting(`transfer_type`).getValue() == `kInterrupt`))"
                            level="warning" description="The audio control subclass support one optional interrupt endpoint only."/>
                        <constraint when_expr="($parent.subclass.getValue() == `kSubclassAudioControl`)"
                            cond_expr="($this.getSize() &lt;= 1)" level="warning"
                            description="The audio control subclass support one interrupt setting (alternate interfaces are not supported)."/>
                        <!-- Audio streaming interface - zero bandwidth interface must be first if used, one isochronous data endpoint only plus the optional isochronous feedback endpoint -->
                        <constraint when_expr="($parent.subclass.getValue() == `kSubclassAudioStream`) &amp;&amp; ($this.getSize() &gt; 0) &amp;&amp; ($this.countOccurrences(item -> item.getSetting(`endpoints`).getSize() == 0) &gt; 0)"
                            cond_expr="($this.get(0).getSetting(`endpoints`).getSize() == 0)"
                            level="warning" description="When the zero bandwidth interface setting is used it must be first interface setting according to the USB audio specification 1.0."/>
                    </validation>
                </array>
                <array id="audio_units" label="Audio control interface configuration" type="audio_unit_config_t"
                    available="$parent.subclass.getValue() == `kSubclassAudioControl`"
                    options="ShowContentAs=TABS;UI_ARRAY_REORDER"
                    key_selector_expr="setting -> setting.getSetting(`unit_ref`).getValue().getSetting(`key_name`).getValue()"
                    enable="$parent.subclass.getValue() == `kSubclassAudioControl`">
                    <description>Configuration of audio control units that the system consists from. This setting is available for the Audio control subclass only</description>
                    <validation>
                        <constraint cond_expr="($this.countOccurrences(item -> (item.getSetting(`audio_unit`).getValue() == `kInputTerminal`)) &gt; 0) &amp;&amp;
                                               ($this.countOccurrences(item -> (item.getSetting(`audio_unit`).getValue() == `kOutputTerminal`)) &gt; 0)" level="error"
                                    description="Audio control interface shall contain at least one input terminal and one output terminal."/>
                    </validation>
                    <item_defaults>
                        <set_default id="input_terminal.bTerminalID"
                            value_expr="x -> (x.getID()==`0`) ? 1 : (getAudioUnitID(x.getParent().get(x.getID().toInt() - 1)) + 1)"/>
                        <set_default value_expr=""/>
                    </item_defaults>
                </array>
                <reference id="in_ep_count" type="in_ep_count_t" available="$this.getMode() == `device`"/>
                <reference id="out_ep_count" type="out_ep_count_t" available="$this.getMode() == `device`"/>
            </struct>
            <!-- USB Audio 2.0 -->
            <!-- Audio 2.0 Descriptors -->
            <!-- Audio 2.0 settings -->
            <enum id="bmControl_audio_2_0_t">
                <item id="kNone" label="Not present" value="0x00"/>
                <item id="kReadOnly" label="Read-Only" value="0x01"/>
                <item id="kHostProgrammable" label="Host programmable" value="0x03" available="!$this.hasOption(`not_host_programmable`)"/> 
            </enum>
            <integer id="bID_t" label="ID" type="uint8_t" min_expr="1" max_expr="255">
                <validation>
                    <constraint cond_expr="$parent.getParent().getParent().countOccurrences(item -> (item.isAvailable() &amp;&amp; item.isEnabled() &amp;&amp; item.hasOption(`audio_unit_id`) &amp;&amp; (item.getValue() == $this.getValue())), true) == 1" 
                                level="error" 
                                description_expr="`Duplicated ID ` + $this.getValue() + `of an audio clock entity / unit / terminal is used. Select different ID.`"/>
                </validation>
            </integer>
            <dynamic_enum id="wTerminalType_t" label="Terminal type" items="enumItemsOf($parent._wTerminalType).arrayToEnumItems(
                           enumItem -> true,
                           enumItem -> enumItem.getID(),
                           enumItem -> enumItem.getLabel(),
                           enumItem -> enumItem.getValue(),
                           enumItem -> enumItem.getDescription())">                
                <custom_value_support default="0x01FF" validation_expr="x -> x.isValidIntegerValue(0, 0xFFFF)"/>
            </dynamic_enum>
            <dynamic_enum id="bCSourceID_t" label="Clock entity ID"
                options="use_enum_value"
                items="$parent.getParent().getParent().filter(item -> (item.isAvailable() &amp;&amp; item.isEnabled() &amp;&amp; (item.getType() == `integer`) &amp;&amp; item.hasOption(`audio_unit_id`) &amp;&amp; item.hasOption(`audio_clock_unit_id`)  &amp;&amp; ((!$this.hasOption(`audio_clock_unit_id`)) || (item.getValue() != $parent.bClockID.getValue()))), true).arrayToEnumItems(
                    enumItem -> true,
                    enumItem -> `bClockID_` + enumItem.getValue(),
                    enumItem -> enumItem.getValue(),
                    enumItem -> enumItem.getValue())">
                <custom_value_support default="0" validation_expr="x -> x.isValidIntegerValue(0, 0xFFFF)"/>
            </dynamic_enum>
            <dynamic_enum id="bSourceID_t" label="Source ID"
                options="use_enum_value"
                items="$parent.getParent().getParent().filter(item -> (item.isAvailable() &amp;&amp; item.isEnabled() &amp;&amp; (item.getType() == `integer`) &amp;&amp; item.hasOption(`audio_unit_id`) &amp;&amp; !item.hasOption(`audio_clock_unit_id`) &amp;&amp; !item.hasOption(`audio_output_terminal_id`) &amp;&amp; (item.getValue() != ($this.hasOption(`audio_terminal`) ? $parent.bTerminalID.getValue() : $parent.bUnitID.getValue()))), true).arrayToEnumItems(
                    enumItem -> true,
                    enumItem -> `bTerminalID_` + enumItem.getValue(),
                    enumItem -> enumItem.getValue(),
                    enumItem -> enumItem.getValue())">
                <custom_value_support default="0" validation_expr="x -> x.isValidIntegerValue(0, 0xFFFF)"/>
            </dynamic_enum>
            <!-- Interface Descriptor settings -->
            <enum id="subClass_audio_2_0_t">
                <item id="kSubclassNone" label="None" value="0x00" available="$this.getMode() == `host`"/>
                <item id="kSubclassAudioControl" label="Audio control" value="0x01" available="$this.getMode() == `device`"/>
                <item id="kSubclassAudioStream" label="Audio stream" value="0x02" available="$this.getMode() == `device`"/>
                <item id="kSubclassMidiStream" label="Midi stream" value="0x03" available="false &amp;&amp; $this.getMode() == `device`"/>
            </enum>
            <enum id="protocol_audio_2_0_t">
                <item id="kProtocolNone" label="None" value="0x00" available="$this.getMode() == `host`"/>
                <item id="kProtocolIPV20" label="Version 2.00" value="0x20" available="$this.getMode() == `device`">
                    <description>Indicates the current version of the specification.</description>
                </item>
            </enum>
            <!-- Class-Specific AC Interface Descriptor - Header settings -->
            <enum id="bCategoryCodes_audio_2_0_t">
                <item id="kNone" label="None" value="0x00" available="false"/>
                <item id="kDesktopSpeaker" label="Desktop speaker" value="0x01"/>
                <item id="kHomeTheater" label="Home theater" value="0x02"/>
                <item id="kMicrophone" label="Microphone" value="0x03"/>
                <item id="kHeadset" label="Headset" value="0x04"/>
                <item id="kTelephone" label="Telephone" value="0x05"/>
                <item id="kConverter" label="Converter" value="0x06"/>
                <item id="kVoiceRecorder" label="Voice / sound recorder" value="0x07"/>
                <item id="kIOBox" label="I / O box" value="0x08"/>
                <item id="kMusicalInstrument" label="Musical instrument" value="0x09"/>
                <item id="kProAudio" label="Pro-audio" value="0x0A"/>
                <item id="kAudioVideo" label="Audio / Video" value="0x0B"/>
                <item id="kControlPanel" label="Control panel" value="0x0C"/>
                <item id="kOther" label="Other" value="0xFF"/>
            </enum>
            <!-- Clock Source Descriptor settings -->
            <enum id="clockType_audio_2_0_t">
                <item id="kExternalClock" label="External clock" value="0x00"/>
                <item id="kInternalFixedClock" label="Internal fixed clock" value="0x01"/>
                <item id="kInternalVariableClock" label="Internal variable clock" value="0x02"/>
                <item id="kInternalProgrammableClock" label="Internal programmable clock" value="0x03"/>
            </enum>
            <enum id="internalClockMode_audio_2_0_t">
                <item id="kFreeRunning" label="Free running" value="0x00"/>
                <item id="kSynchronized" label="Synchronized to Start of Frame" value="0x01"/>
            </enum>
            <!-- Clock Selector Descriptor settings -->
            <dynamic_enum id="baCSourceID_t" label="Clock entity ID"
                    options="use_enum_value"
                    items="$parent.getParent().getParent().getParent().filter(item -> (item.isAvailable() &amp;&amp; item.isEnabled() &amp;&amp; (item.getType() == `integer`) &amp;&amp; item.hasOption(`audio_unit_id`) &amp;&amp; item.hasOption(`audio_clock_unit_id`) &amp;&amp; (item.getValue() != $parent.getParent().getSetting(`bClockID`).getValue())), true).arrayToEnumItems(
                        enumItem -> true,
                        enumItem -> `bClockID_` + enumItem.getValue(),
                        enumItem -> enumItem.getValue(),
                        enumItem -> enumItem.getValue())">
                    <description>ID of the Clock Entity to which this Output Terminal is connected.</description>
                    <custom_value_support default="0" validation_expr="x -> x.isValidIntegerValue(0, 0xFFFF)"/>
            </dynamic_enum>
            <!-- Input Terminal descriptor settings -->
            <enum id="inputTerminal_audio_2_0_t">
                <item id="kUndefined" label="Undefined" value="0x0100">
                    <description>USB terminal, undefined type.</description>
                </item>
                <item id="kStreaming" label="Streaming" value="0x0101">
                    <description>A terminal dealing with a signal carried over an endpoint in an audio streaming interface. The audio streaming interface descriptor points to the associated terminal through the Link to terminal field.</description>
                </item>
                <item id="kVendorSpecific" label="Vendor specific" value="0x01FF">
                    <description>A terminal dealing with a signal carried over a vendor-specific interface. The vendor-specific interface descriptor must contain a field that references the terminal.</description>
                </item>
                <item id="kInputUndefined" label="Input Undefined" value="0x0200">
                    <description>Input terminal, undefined type.</description>
                </item>
                <item id="kMicrophone" label="Microphone" value="0x0201">
                    <description>A generic microphone that does not fit under any of the other classifications.</description>
                </item>
                <item id="kDesktopMicrophone" label="Desktop microphone" value="0x0202">
                    <description>A microphone normally placed on the desktop or integrated into the monitor.</description>
                </item>
                <item id="kPersonalMicrophone" label="Personal microphone" value="0x0203">
                    <description>A head-mounted or clip-on microphone.</description>
                </item>
                <item id="kOmniDirectionalMicrophone" label="Omni-directional microphone" value="0x0204">
                    <description>A microphone designed to pick up voice from more than one speaker at relatively long ranges.</description>
                </item>
                <item id="kMicrophoneArray" label="Microphone array" value="0x0205">
                    <description>An array of microphones designed for directional processing using host-based signal processing algorithms.</description>
                </item>
                <item id="kProcessingMicrophoneArray" label="Processing microphone array" value="0x0206">
                    <description>An array of microphones with an embedded signal processor.</description>
                </item>
            </enum>
            <set id="channelConfig_audio_2_0_t">
                <description>Spatial location configuration of the logical channels.</description>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FL" label="Front Left (FL)" value="0x1"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FR" label="Front Right (FR)" value="0x2"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FC" label="Front Center (FC)" value="0x4"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_LFE" label="Low Frequency Effects (LFE)" value="0x8"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_BL" label="Back Left (BL)" value="0x10"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_BR" label="Back Right (BR)" value="0x20"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FLC" label="Front Left of Center (FLC)" value="0x40"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FRC" label="Front Right of Center (RC)" value="0x80"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_BC" label="Back Center (BC)" value="0x100"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_SL" label="Side Left (SL)" value="0x200"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_SR" label="Side Right (SR)" value="0x400"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_TC" label="Top Center (TC)" value="0x800"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_TFL" label="Top Front Left (TFL)" value="0x1000"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_TFC" label="Top Front Center (TFC)" value="0x2000"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_TFR" label="Top Front Right (TFR)" value="0x4000"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_TBL" label="Top Back Left (TBL)" value="0x8000"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_TBC" label="Top Back Center (TBC)" value="0x10000"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_TBR" label="Top Back Right (TBR)" value="0x20000"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_TFLC" label="Top Front Left of Center (TFLC)" value="0x40000"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_TFRC" label="Top Front Rifht of Center (TFRC)" value="0x80000"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_LLFE" label="Left Low Frequency Effects (LLFE)" value="0x100000"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_RLFE" label="Right Low Frequency Effects (RLFE)" value="0x200000"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_TSL" label="Top Side Left (TSL)" value="0x400000"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_TSR" label="Top Side Right (TSR)" value="0x800000"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_BTC" label="Bottom Center (BC)" value="0x1000000"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_BLC" label="Back Left of Center (BLC)" value="0x2000000"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_BRC" label="Back Right of Center (BRC)" value="0x4000000"/>
                <item id="USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_RD" label="Raw Data (RD)" value="0x80000000"/>
            </set>
            <!-- Output Terminal descriptor settings -->
            <enum id="outputTerminal_audio_2_0_t">
                <item id="kUndefined" label="Undefined" value="0x0100">
                    <description>USB terminal, undefined type.</description>
                </item>
                <item id="kStreaming" label="Streaming" value="0x0101">
                    <description>A terminal dealing with a signal carried over an endpoint in an audio streaming interface. The audio streaming interface descriptor points to the associated terminal through the Link to terminal field.</description>
                </item>
                <item id="kVendorSpecific" label="Vendor specific" value="0x01FF">
                    <description>A terminal dealing with a signal carried over a vendor-specific interface. The vendor-specific interface descriptor must contain a field that references the terminal.</description>
                </item>
                <item id="kOutputUndefined" label="Output Undefined" value="0x0300">
                    <description>Output terminal, undefined Type.</description>
                </item>
                <item id="kSpeaker" label="Speaker" value="0x0301">
                    <description>A generic speaker or set of speakers that does not fit under any of the other classifications.</description>
                </item>
                <item id="kHeadphones" label="Headphones" value="0x0302">
                    <description>A head-mounted audio output device.</description>
                </item>
                <item id="kHeadMountedDisplayAudio" label="Head mounted display audio" value="0x0303">
                    <description>The audio part of a VR head mounted display. The associated interfaces descriptor can be used to reference the HID interface used to report the position and orientation of the HMD.</description>
                </item>
                <item id="kDesktopSpeaker" label="Desktop speaker" value="0x0304">
                    <description>Relatively small speaker or set of speakers normally placed on the desktop or integrated into the monitor. These speakers are close to the user and have limited stereo separation.</description>
                </item>
                <item id="kRoomSpeaker" label="Room speaker" value="0x0305">
                    <description>Larger speaker or set of speakers that are heard well anywhere in the room.</description>
                </item>
                <item id="kCommunicationSpeaker" label="Communication speaker" value="0x0306">
                    <description>Speaker or set of speakers designed for voice communication.</description>
                </item>
                <item id="kLowFrequencyEffectsSpeaker" label="Low frequency effects speaker" value="0x0307">
                    <description>Speaker designed for low frequencies (subwoofer). Not capable of reproducing speech or music.</description>
                </item>
            </enum>
            <!-- Feature Unit descriptor settings -->
            <struct id="bmaControls_audio_2_0_t">
                <reference id="bmControls_0_1bit" type="bmControl_audio_2_0_t" label="Mute Control"/>
                <reference id="bmControls_2_3bit" type="bmControl_audio_2_0_t" label="Volume Control"/>
                <reference id="bmControls_4_5bit" type="bmControl_audio_2_0_t" label="Bass Control"/>
                <reference id="bmControls_6_7bit" type="bmControl_audio_2_0_t" label="Mid Control"/>
                <reference id="bmControls_8_9bit" type="bmControl_audio_2_0_t" label="Treble Control"/> 
                <reference id="bmControls_10_11bit" type="bmControl_audio_2_0_t" label="Graphic Equalizer Control"/>
                <reference id="bmControls_12_13bit" type="bmControl_audio_2_0_t" label="Automatic Gain Control"/>
                <reference id="bmControls_14_15bit" type="bmControl_audio_2_0_t" label="Delay Control"/>
                <reference id="bmControls_16_17bit" type="bmControl_audio_2_0_t" label="Bass Boost Control"/>
                <reference id="bmControls_18_19bit" type="bmControl_audio_2_0_t" label="Loudness Control"/>
                <reference id="bmControls_20_21bit" type="bmControl_audio_2_0_t" label="Input Gain Control"/>
                <reference id="bmControls_22_23bit" type="bmControl_audio_2_0_t" label="Input Gain Pad Control"/>
                <reference id="bmControls_24_25bit" type="bmControl_audio_2_0_t" label="Phase Inverter Control"/>
                <reference id="bmControls_26_27bit" type="bmControl_audio_2_0_t" label="Underflow Control"/>
                <reference id="bmControls_28_29bit" type="bmControl_audio_2_0_t" label="Overflow Control"/>
                <variable id="bmaControls" value="($parent.bmControls_28_29bit.getEnumItemValue().toInt() &lt;&lt; 28) | ($parent.bmControls_26_27bit.getEnumItemValue().toInt() &lt;&lt; 26) | ($parent.bmControls_24_25bit.getEnumItemValue().toInt() &lt;&lt; 24) | ($parent.bmControls_22_23bit.getEnumItemValue().toInt() &lt;&lt; 22) | ($parent.bmControls_20_21bit.getEnumItemValue().toInt() &lt;&lt; 20) | ($parent.bmControls_18_19bit.getEnumItemValue().toInt() &lt;&lt; 18) | ($parent.bmControls_16_17bit.getEnumItemValue().toInt() &lt;&lt; 16) | ($parent.bmControls_14_15bit.getEnumItemValue().toInt() &lt;&lt; 14) | ($parent.bmControls_12_13bit.getEnumItemValue().toInt() &lt;&lt; 12) | ($parent.bmControls_10_11bit.getEnumItemValue().toInt() &lt;&lt; 10) | ($parent.bmControls_8_9bit.getEnumItemValue().toInt() &lt;&lt; 8) | ($parent.bmControls_6_7bit.getEnumItemValue().toInt() &lt;&lt; 6) | ($parent.bmControls_4_5bit.getEnumItemValue().toInt() &lt;&lt; 4) | ($parent.bmControls_2_3bit.getEnumItemValue().toInt() &lt;&lt; 2) | $parent.bmControls_0_1bit.getEnumItemValue().toInt()" />
            </struct>            
            <!-- AC descriptors -->
            <struct id="acHeader_descriptor_audio_2_0_t">
                <variable id="bLength" value="0x09"/>
                <variable id="bDescriptorType" value="0x24"/>
                <variable id="bDescriptorSubtype" value="0x01"/>
                <variable id="bcdADC" value="0x0200"/>
                <reference id="bCategory" type="bCategoryCodes_audio_2_0_t" label="Audio Function Category"/>
                <!-- <variable id="wTotalLength" value="0x00"/> It is calculated in codegenerator -->
                <reference id="bmControls" type="bmControl_audio_2_0_t" label="Latency Control"/>
            </struct>
            <struct id="clockSource_descriptor_audio_2_0_t">
                <variable id="bLength" value="0x08"/>
                <variable id="bDescriptorType" value="0x24"/>
                <variable id="bDescriptorSubtype" value="0x0A"/>
                <reference id="bClockID" label="Clock ID" type="bID_t" options="audio_unit_id;audio_clock_unit_id">
                    <description>Constant uniquely identifying the clock source entity within the audio function. This value is used in all requests to address this entity.</description>                    
                </reference>
                <reference id="bmAttributesLow" type="clockType_audio_2_0_t" label="Clock type"/>
                <reference id="bmAttributesHigh" type="internalClockMode_audio_2_0_t" label="Internal clock mode">
                    <validation>
                        <constraint when_expr="$parent.bmAttributesLow.getEnumItemId() == `kExternalClock`"
                            cond_expr="$this.getEnumItemId() == `kFreeRunning`"
                            level="error"
                            description="If external clock is selected, free running mode must be also selected"/>
                    </validation>
                </reference>
                <variable id="bmAttributes" value="($parent.bmAttributesHigh.getEnumItemValue().toInt() &lt;&lt; 2) | $parent.bmAttributesLow.getEnumItemValue().toInt()"/>
                <info value="`Controls`" id="controlsLine" options="UI_LINE_BREAK;UI_LABEL_HIDDEN"></info>
                <reference id="bmControlsLow" type="bmControl_audio_2_0_t" label="Clock frequency"/>
                <reference id="bmControlsHigh" type="bmControl_audio_2_0_t" label="Clock validity"/>
                <variable id="bmControls" value="($parent.bmControlsHigh.getEnumItemValue().toInt() &lt;&lt; 2) | $parent.bmControlsLow.getEnumItemValue().toInt()"/>
                <!-- Associated terminals are not supported -->
                <variable id="bAssocTerminal" value="0x00"/>
                <variable id="iClockSelector" value="0x00"/> <!-- No string description -->
                <!-- Other settings -->
                <variable id="key_name" value="$parent.bClockID.getValue() + ` - Clock Source`"/>
            </struct>
            <struct id="clockSelector_descriptor_audio_2_0_t">
                <variable id="bLength" value="7 + $parent.bNrInPins.getValue()"/>
                <variable id="bDescriptorType" value="0x24"/>
                <variable id="bDescriptorSubtype" value="0x0B"/>
                <reference id="bClockID" label="Clock ID" type="bID_t" options="audio_unit_id;audio_clock_unit_id">
                    <description>Constant uniquely identifying the clock selector entity within the audio function. This value is used in all requests to address this entity.</description>                    
                </reference>               
                <variable id="bNrInPins" value="$parent.baCSourceID.getLength()"/> 
                <array id="baCSourceID" label="Input pins" type="baCSourceID_t" options="ShowContentAs=Table;UI_BORDER_HIDDEN;UI_ARRAY_LAYOUT_HORIZONTAL;UI_TABLE_COLUMN_WIDTHS=-1,5" min_expr="1" key_selector_expr="x -> (`Pin ` + x.getID())">
                    <validation>
                        <constraint cond_expr="$this.getLength() &gt; 0" level="error" description="The clock selector must have at least one input pin."/>
                    </validation>
                </array>
                <reference id="bmControls" type="bmControl_audio_2_0_t" label="Clock Selector Control"/>
                <variable id="iClockSelector" value="0x00"/>  <!-- No string description -->
            <!-- Other settings -->
            <variable id="key_name" value="$parent.bClockID.getValue() + ` - Clock Selector`"/>
            </struct>
            <struct id="clockMultiplier_descriptor_audio_2_0_t">
                <variable id="bLength" value="0x07"/>
                <variable id="bDescriptorType" value="0x24"/>
                <variable id="bDescriptorSubtype" value="0x0C"/>
                <reference id="bClockID" label="Clock ID" type="bID_t" options="audio_unit_id;audio_clock_unit_id">
                    <description>Constant uniquely identifying the clock multiplier entity within the audio function. This value is used in all requests to address this entity.</description>                    
                </reference>   
                <reference id="bCSourceID" label="Clock entity ID" type="bCSourceID_t" options="audio_clock_unit_id">
                    <description>ID of the clock entity to which this clock multiplier is connected.</description>
                </reference>
                <info value="`Controls`" id="controlsLine" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"></info>
                <reference id="bmControlsLow" type="bmControl_audio_2_0_t" label="Clock numerator" options="not_host_programmable"/>
                <reference id="bmControlsHigh" type="bmControl_audio_2_0_t" label="Clock denominator"  options="not_host_programmable"/>
                <variable id="bmControls" value="($parent.bmControlsHigh.getEnumItemValue().toInt() &lt;&lt; 2) | $parent.bmControlsLow.getEnumItemValue().toInt()"/>
                <variable id="iClockMultiplier" value="0x00"/>  <!-- No string description -->
                <!-- Other settings -->
                <variable id="key_name" value="$parent.bClockID.getValue() + ` - Clock Multiplier`"/>
            </struct>
            <struct id="inputTerminal_descriptor_audio_2_0_t">
                <variable id="bLength" value="0x11"/>
                <variable id="bDescriptorType" value="0x24"/>
                <variable id="bDescriptorSubtype" value="0x02"/>
                <reference id="bTerminalID" label="Terminal ID" type="bID_t" options="audio_unit_id">
                    <description>Each terminal (any unit) within the audio function is assigned a unique identification that is used for addressing. The value 0x00 is reserved for undefined ID.</description>
                </reference>
                <reference id="wTerminalType" label="Terminal type" type="wTerminalType_t">
                    <description>This setting provides pertinent information about the physical entity that the input terminal represents. This could be a USB OUT endpoint, an external Line In connection, a microphone, etc. A complete list of terminal type codes is provided in USB audio terminal types specification.</description>
                </reference>
                <!-- Associated terminals are not supported -->
                <variable id="bAssocTerminal" value="0x00"/> 
                <reference id="bCSourceID" label="Clock entity ID" type="bCSourceID_t">
                    <description>ID of the clock entity to which this input terminal is connected.</description>
                </reference>
                <info value="`Channel cluster descriptor`" id="channelClusterDescriptorLine" options="UI_LINE_BREAK;UI_LABEL_HIDDEN"></info>
                <integer id="bNrChannels" label="Number of channel" type="uint8_t" min_expr="1" max_expr="255">
                    <description>Number of logical output channels in the terminal’s output audio channel cluster.</description>
                </integer>
                <reference id="bmChannelConfig" label="Spatial location" type="channelConfig_audio_2_0_t">
                    <description>Spatial location of the logical channels.</description>
                    <validation>
                        <constraint when_expr="$this.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_RD.getValue() == true" 
                                    cond_expr="$parent.bNrChannels.getValue() == 0"
                                    level="error" 
                                    description="When the cluster is carrying Raw Data, Number of channel must be set to zero"/>                      
                    </validation>
                </reference>
                <variable id="iChannelNames" value="0x00"/> <!-- No string description -->
                <info value="`Controls`" id="controlsLine" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"></info>
                <reference id="bmControls_0_1bit" type="bmControl_audio_2_0_t" label="Copy protect"/>
                <reference id="bmControls_2_3bit" type="bmControl_audio_2_0_t" label="Connector"/>
                <reference id="bmControls_4_5bit" type="bmControl_audio_2_0_t" label="Overload"/>
                <reference id="bmControls_6_7bit" type="bmControl_audio_2_0_t" label="Cluster"/>
                <reference id="bmControls_8_9bit" type="bmControl_audio_2_0_t" label="Underflow"/> 
                <reference id="bmControls_10_11bit" type="bmControl_audio_2_0_t" label="Overflow"/>
                <variable id="bmControls" value="($parent.bmControls_10_11bit.getEnumItemValue().toInt() &lt;&lt; 10) | ($parent.bmControls_8_9bit.getEnumItemValue().toInt() &lt;&lt; 8) | ($parent.bmControls_6_7bit.getEnumItemValue().toInt() &lt;&lt; 6) | ($parent.bmControls_4_5bit.getEnumItemValue().toInt() &lt;&lt; 4) | ($parent.bmControls_2_3bit.getEnumItemValue().toInt() &lt;&lt; 2) | $parent.bmControls_0_1bit.getEnumItemValue().toInt()" />
                <variable id="iTerminal" value="0x00"/> <!-- No string description -->
                <!-- Other settings -->
                <variable id="key_name" value="$parent.bTerminalID.getValue() + ` - Input Terminal`"/>
                <reference id="_wTerminalType" type="inputTerminal_audio_2_0_t" label="Terminal type" available="false"/>             
            </struct>
            <struct id="outputTerminal_descriptor_audio_2_0_t">
                <variable id="bLength" value="0x0C"/>
                <variable id="bDescriptorType" value="0x24"/>
                <variable id="bDescriptorSubtype" value="0x03"/>
                <reference id="bTerminalID" label="Terminal ID" type="bID_t" options="audio_unit_id;audio_output_terminal_id">
                    <description>Each terminal (any unit) within the audio function is assigned a unique identification that is used for addressing. The value 0x00 is reserved for undefined ID.</description>
                </reference>     
                <reference id="wTerminalType" label="Terminal type" type="wTerminalType_t">
                    <description>This setting provides pertinent information about the physical entity that the output terminal represents. This could be a USB OUT endpoint, an external Line Out connection, a speaker, etc. A complete list of Terminal Type codes is provided in USB Audio Terminal Types specification.</description>
                </reference>                
                <!-- Associated terminals are not supported -->
                <variable id="bAssocTerminal" value="0x00"/>
                <reference id="bSourceID" type="bSourceID_t" label="Source ID" options="audio_terminal">
                    <description>ID of the unit or terminal to which this terminal is connected.</description>
                </reference>
                <reference id="bCSourceID" label="Clock entity ID" type="bCSourceID_t">
                    <description>ID of the clock entity to which this output terminal is connected.</description>
                </reference>                           
                <info value="`Controls`" id="controlsLine" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"></info>
                <reference id="bmControls_0_1bit" type="bmControl_audio_2_0_t" label="Copy protect"/>
                <reference id="bmControls_2_3bit" type="bmControl_audio_2_0_t" label="Connector"/>
                <reference id="bmControls_4_5bit" type="bmControl_audio_2_0_t" label="Overload"/>
                <reference id="bmControls_6_7bit" type="bmControl_audio_2_0_t" label="Underflow"/>
                <reference id="bmControls_8_9bit" type="bmControl_audio_2_0_t" label="Overflow"/> 
                <variable id="bmControls" value="($parent.bmControls_8_9bit.getEnumItemValue().toInt() &lt;&lt; 8) | ($parent.bmControls_6_7bit.getEnumItemValue().toInt() &lt;&lt; 6) | ($parent.bmControls_4_5bit.getEnumItemValue().toInt() &lt;&lt; 4) | ($parent.bmControls_2_3bit.getEnumItemValue().toInt() &lt;&lt; 2) | $parent.bmControls_0_1bit.getEnumItemValue().toInt()" />
                <variable id="iTerminal" value="0x00"/> <!-- No string description -->
                <!-- Other settings -->
                <variable id="key_name" value="$parent.bTerminalID.getValue() + ` - Output Terminal`"/>  
                <reference id="_wTerminalType" type="outputTerminal_audio_2_0_t" label="Terminal type" available="false"/>       
            </struct>
            <struct id="featureUnit_descriptor_audio_2_0_t">
                <variable id="bLength" value="6 + 4 * $parent.bmaControls.getLength()"/>
                <variable id="bDescriptorType" value="0x24"/>
                <variable id="bDescriptorSubtype" value="0x06"/>
                <reference id="bUnitID" label="Unit ID" type="bID_t" options="audio_unit_id">
                    <description>Each terminal (any unit) within the audio function is assigned a unique identification that is used for addressing. The value 0x00 is reserved for undefined ID.</description>
                </reference>   
                <reference id="bSourceID" type="bSourceID_t" label="Source ID">                                
                    <description>ID of the unit or terminal to which this feature unit is connected.</description>
                </reference>
                <array id="bmaControls" label="Controls bitmap" type="bmaControls_audio_2_0_t" options="ShowContentAs=TABS;UI_ARRAY_REORDER"
                    key_selector_expr="x -> ((x.getID() == 0) ? `Master channel` : `Channel ` + x.getID())">
                    <description>The controls bitmap for the logical channel.</description>
                </array>
                <variable id="iFeature" value="0x00"/> <!-- No string description -->
                <!-- Other settings -->
                <variable id="key_name" value="$parent.bUnitID.getValue() + ` - Feature Unit`"/>                
            </struct>
            <!-- AS Interface_descriptor settings -->
            <enum id="bFormatType_audio_2_0_t">
                <item id="kFormatNone" label="Undefined format" value="0x00" available="false">
                    <description>Format type undefined</description>
                </item>
                <item id="kFormatI" label="Format I" value="0x01">
                    <description>Format type I</description>
                </item>
                <item id="kFormatII" label="Format II" value="0x02" available="false"> <!-- Not supported by SDK -->
                    <description>Format type II</description>
                </item>
                <item id="kFormatIII" label="Format III" value="0x03" available="false"> <!-- Not supported by SDK -->
                    <description>Format type III</description>
                </item>
                <item id="kFormatIV" label="Format IV" value="0x04" available="false"> <!-- Not supported by SDK -->
                    <description>Format type IV</description>
                </item>
                <item id="kExtFormatI" label="Ext Format I" value="0x81" available="false"> <!-- Not supported by SDK -->
                    <description>Format type I</description>
                </item>
                <item id="kExtFormatII" label="Ext Format II" value="0x82" available="false"> <!-- Not supported by SDK -->
                    <description>Format type II</description>
                </item>
                <item id="kExtFormatIII" label="Ext Format III" value="0x83" available="false"> <!-- Not supported by SDK -->
                    <description>Format type III</description>
                </item>
            </enum>
            <enum id="dataFormat_audio_2_0_t">
                <item id="kUndefined" label="Undefined type I" value="0x00" available="$this.hasOption(`dataFormatI_audio_2_0`) &amp;&amp; $this.getOptionValue(`dataFormatI_audio_2_0`)">
                    <description>Undefined format of data (type I)</description>
                </item>
                <item id="kPCM" label="PCM" value="0x01" available="$this.hasOption(`dataFormatI_audio_2_0`) &amp;&amp; $this.getOptionValue(`dataFormatI_audio_2_0`)">
                    <description>Pulse coded modulation format of data.</description>
                </item>
                <item id="kPCM8" label="PCM 8" value="0x02" available="$this.hasOption(`dataFormatI_audio_2_0`) &amp;&amp; $this.getOptionValue(`dataFormatI_audio_2_0`)">
                    <description>Pulse coded modulation format of data (8 bits unsigned).</description>
                </item>
                <item id="kIeeeFloat" label="IEEE Float" value="0x04" available="$this.hasOption(`dataFormatI_audio_2_0`) &amp;&amp; $this.getOptionValue(`dataFormatI_audio_2_0`)">
                    <description>The IEEE float format based on the ANSI/IEEE-754 floating-point standard. Audio data is represented using the basic single-precision format. The basic single-precision number is 32 bits wide and has an 8-bit exponent and a 24-bit mantissa.</description>
                </item>
                <item id="kAlaw" label="ALAW" value="0x08" available="$this.hasOption(`dataFormatI_audio_2_0`) &amp;&amp; $this.getOptionValue(`dataFormatI_audio_2_0`)">
                    <description>The compressed audio data (ALAW compresioin algorithm) uses 8 bits per sample (bBitsPerSample = 8). Data is signed fixed point, left-justified in the subframe, MSB first.</description>
                </item>
                <item id="kMulaw" label="MULAW" value="0x10" available="$this.hasOption(`dataFormatI_audio_2_0`) &amp;&amp; $this.getOptionValue(`dataFormatI_audio_2_0`)">
                    <description>The compressed audio data (MULAW compresioin algorithm) uses 8 bits per sample (bBitsPerSample = 8). Data is signed fixed point, left-justified in the subframe, MSB first.</description>
                </item>
                <item id="kRawData" label="Type I Raw Data" value="0x80000000" available="$this.hasOption(`dataFormatI_audio_2_0`) &amp;&amp; $this.getOptionValue(`dataFormatI_audio_2_0`)">
                    <description>To allow transport of data (audio or other) over a USB audio streaming interface in the form of PCM-like audio slots when the actual format or even the meaning of the transported data is unknown. The USB pipe simply acts as a pass-through.</description>
                </item>
            </enum>
            <!-- Type I format descriptor settings -->
            <enum id="bSubslotSize_t">
                <item id="kOne" label="1" value="0x01"/>
                <item id="kTwo" label="2" value="0x02"/>
                <item id="kThree" label="3" value="0x03"/>
                <item id="kFour" label="4" value="0x04"/>
            </enum>
            <!-- AS descriptors -->
            <struct id="asInterface_descriptor_audio_2_0_t">
                <variable id="bLength" value="0x20"/>
                <variable id="bDescriptorType" value="0x24"/>
                <variable id="bDescriptorSubtype" value="0x01"/>
                <dynamic_enum id="bTerminalLink" label="Link to terminal"
                    options="use_enum_value"
                    items="$parent.getParent().getParent().getParent().getParent().getParent().filter(item -> (item.isAvailable() &amp;&amp; item.isEnabled() &amp;&amp; (item.getType() == `integer`) &amp;&amp; (item.getId() == `bTerminalID`)), true).arrayToEnumItems(
                        enumItem -> true,
                        enumItem -> `bTerminalID_` + enumItem.getValue(),
                        enumItem -> enumItem.getValue(),
                        enumItem -> enumItem.getValue())">
                    <description>The terminal ID of the terminal to which the endpoint of this interface is connected.</description>
                    <custom_value_support default="0" validation_expr="x -> x.isValidIntegerValue(0, 0xFFFF)"/>
                </dynamic_enum>
                <reference id="bmControlsLow" type="bmControl_audio_2_0_t" options="not_host_programmable" label="Active Alternate Setting"/>
                <reference id="bmControlsHigh" type="bmControl_audio_2_0_t" options="not_host_programmable" label="Valid Alternate Settings"/>
                <variable id="bmControls" value="($parent.bmControlsHigh.getEnumItemValue().toInt() &lt;&lt; 2) | $parent.bmControlsLow.getEnumItemValue().toInt()"/>
                <reference id="bFormatType" label="Format type" type="bFormatType_audio_2_0_t">
                    <description>The setting identifying the format type the audio streaming interface is using.</description>
                    <validation>
                        <constraint when_expr="$this.getEnumItemId() == `kFormatI` || $this.getEnumItemId() == `kFormatII` || $this.getEnumItemId() == `kFormatIII`" 
                                    cond_expr="$parent.getParent().getSetting(`endpoints`).anyMatch(item -> (item.getSetting(`transfer_type`).getValue() == `kIsochronous`))"
                                    level="error"                                    
                                    description="This format type can be used when the interface has a USB isochronous endpoint associated with it."/>
                    </validation>
                </reference>
                <reference id="bmFormats" label="Audio data format" type="dataFormat_audio_2_0_t">
                    <options_expr>
                        <option id="dataFormatNone_audio_2_0" expr="$parent.bFormatType.getEnumItemId() == `kFormatNone`"/>
                        <option id="dataFormatI_audio_2_0" expr="$parent.bFormatType.getEnumItemId() == `kFormatI`"/>
                        <option id="dataFormatII_audio_2_0" expr="$parent.bFormatType.getEnumItemId() == `kFormatII`"/>
                        <option id="dataFormatIII_audio_2_0" expr="$parent.bFormatType.getEnumItemId() == `kFormatIII`"/>
                        <option id="dataFormatIV_audio_2_0" expr="$parent.bFormatType.getEnumItemId() == `kFormatIV`"/>
                        <option id="dataExtFormatI_audio_2_0" expr="$parent.bFormatType.getEnumItemId() == `kExtFormatI`"/>
                        <option id="dataExtFormatII_audio_2_0" expr="$parent.bFormatType.getEnumItemId() == `kExtFormatII`"/>
                        <option id="dataExtFormatIII_audio_2_0" expr="$parent.bFormatType.getEnumItemId() == `kExtFormatIII`"/>
                    </options_expr>
                    <description>The setting identifying the format type the audio streaming interface is using.</description>
                </reference>
                <info value="`Channel cluster descriptor`" id="channelClusterDescriptorLine" options="UI_LINE_BREAK;UI_LABEL_HIDDEN"></info>
                <integer id="bNrChannels" label="Number of channel" type="uint8_t" min_expr="1" max_expr="255">
                    <description>Number of physical channels in the AS interface audio channel cluster.</description>
                </integer>
                <reference id="bmChannelConfig" label="Spatial location" type="channelConfig_audio_2_0_t">
                    <description>Spatial location of the logical channels.</description>
                    <validation>
                        <constraint when_expr="$this.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_RD.getValue() == true" 
                                    cond_expr="$parent.bNrChannels.getValue() == 0"
                                    level="error" 
                                    description="When the cluster is carrying Raw Data, Number of channel must be set to zero"/>                      
                    </validation>
                </reference>
                <variable id="iChannelNames" value="0x00"/> <!-- No string description -->
            </struct>
            <struct id="typeIFormat_descriptor_audio_2_0_t">
                <variable id="bLength" value="0x06"/>
                <variable id="bDescriptorType" value="0x24"/>
                <variable id="bDescriptorSubtype" value="0x02"/>
                <variable id="bFormatType" value="0x01"/>
                <reference id="bSubslotSize" type="bSubslotSize_t" label="Sub-slot size">
                    <description>The number of bytes occupied by one audio sub-slot.</description>
                </reference>
                <integer id="bBitResolution" label="Resolution" type="uint8_t" max_expr="255">
                    <description>The number of effectively used bits from the available bits in an audio sub-slot.</description>
                    <validation>
                        <constraint cond_expr="$this.getValue() &lt;= $parent.bSubslotSize.getEnumItemValue().toInt() * 8" 
                                    level="error" 
                                    description_expr="`Only ` + $parent.bSubslotSize.getEnumItemValue().toInt() * 8 + ` bits are available.`"/>
                    </validation>
                </integer>
            </struct>
            <!-- Encoder descriptors - not supported by the SDK -->
            <!-- Decoder descriptors - not supported by the SDK -->
            <struct id="isochronous_audio_2_0_data_endpoint_t">
                <variable id="bLength" value="0x08"/>
                <variable id="bDescriptorType" value="0x24"/>
                <variable id="bDescriptorSubtype" value="0x01"/>
                <variable id="bmAttributes" value="false"/> <!-- Setting is available for Format type II only -->
                <info value="`Controls`" id="controlsLine" options="UI_LINE_BREAK;UI_LABEL_HIDDEN"></info>
                <reference id="bmControls_0_1bit" type="bmControl_audio_2_0_t" label="Pitch"/>
                <reference id="bmControls_2_3bit" type="bmControl_audio_2_0_t" label="Data Overrun"/>
                <reference id="bmControls_4_5bit" type="bmControl_audio_2_0_t" label="Data Underrun"/>
                <variable id="bmControls" value="($parent.bmControls_4_5bit.getEnumItemValue().toInt() &lt;&lt; 4) | ($parent.bmControls_2_3bit.getEnumItemValue().toInt() &lt;&lt; 2) | $parent.bmControls_0_1bit.getEnumItemValue().toInt()" />
                <info value="``" id="controlsLineEnd" options="UI_LINE_BREAK;UI_LABEL_HIDDEN"></info>
                <reference id="bLockDelayUnits" label="Lock delay units" type="bLockDelayUnits_t">
                    <description>Selection of the lock delay units. The lock delay is used to indicate to the Host how long it takes for the clock recovery circuitry of this endpoint to lock and reliably produce or consume the audio data stream.</description>
                    <validation>
                        <constraint when_expr="!($parent.getParent().getSetting(`synchronization`).getValue() == `kSynchronous` || $parent.getParent().getSetting(`synchronization`).getValue() == `kAdaptive`)" 
                                    cond_expr="$this.getEnumItemId() == `undefined`"
                                    level="error" 
                                    description="The Lock delay units must be set to Undefined, because it is only applicable for synchronous and adaptive endpoints. For asynchronous endpoints, the clock is generated internally in the audio function and is completely independent on this setting." />
                    </validation>
                </reference>
                <integer id="wLockDelay" label="Lock delay" type="uint16_t">
                    <description>The lock delay is used to indicate to the Host how long it takes for the clock recovery circuitry of this endpoint to lock and reliably produce or consume the audio data stream.</description>
                    <validation>
                        <constraint when_expr="!($parent.getParent().getSetting(`synchronization`).getValue() == `kSynchronous` || $parent.getParent().getSetting(`synchronization`).getValue() == `kAdaptive`)" 
                                    cond_expr="$this.getValue() == 0"
                                    level="error" 
                                    description="The Lock delay must be set to zero because it is only applicable for synchronous and adaptive endpoints. For asynchronous endpoints, the clock is generated internally in the audio function and is completely independent on this setting." />
                    </validation>
                </integer>
            </struct>
            <!-- Other settings and structures -->
            <enum id="units_audio_2_0_t">
                <item id="kClockSource" label="Clock source" value="USB_INTERFACE_SUBTYPE_AUDIO_CONTROL_CLOCK_SOURCE">
                    <description>
The clock source (CS) provides sampling clock frequency to all or part of the audio function. A clock source can represent an internal sampling frequency generator, but it can also represent an external sampling clock signal input to the audio function.       
The clock source has a single clock output pin that carries the sampling clock signal, represented by the clock source. The clock output pin number is always one.
                    </description>
                </item>
                <item id="kClockSelector" label="Clock selector" value="USB_INTERFACE_SUBTYPE_AUDIO_CONTROL_CLOCK_SELECTOR" available="false"> <!-- Not supported by SDK -->
                    <description>
The clock selector (CX) is used to select between multiple sampling clock signals that might be available inside an audio function. It has multiple Clock Input Pins and a single Clock Output pin. clock input pins are numbered starting from one up to the total number of clock input pins on the clock selector. The clock output pin number is always one.
                    </description>
                </item>
                <item id="kClockMultiplier" label="Clock multiplier" value="USB_INTERFACE_SUBTYPE_AUDIO_CONTROL_CLOCK_MULTIPLIER" available="false"> <!-- Not supported by SDK -->
                    <description>
The clock multiplier (CM) is used to derive a new clock signal with a different frequency from the clock signal at its single clock input pin. It does this by multiplying that clock signal frequency by a numerator P and then dividing it by a denominator Q. The values P and Q are fixed for a given Clock Multiplier. The new clock signal is guaranteed to be synchronous with the input clock signal. A clock multiplier has one Input Pin and one Output Pin and their numbers are always one.
                    </description>
                </item>
                <item id="kInputTerminal" label="Input terminal" value="USB_INTERFACE_SUBTYPE_AUDIO_CONTROL_INPUT_TERMINAL">
                    <description>
The input terminal (IT) is used to interface between the audio function’s ‘outside world’ and other units in the audio function. 
It serves as a receptacle for audio information flowing into the audio function. Its function is to represent a source of incoming audio 
data after this data has been properly extracted from the original audio stream into the separate logical channels that are embedded in this 
stream (the decoding process). The logical channels are grouped into an audio channel cluster and leave the input terminal through a single output pin.
                   </description>
                </item>
                <item id="kOutputTerminal" label="Output terminal" value="USB_INTERFACE_SUBTYPE_AUDIO_CONTROL_OUTPUT_TERMINAL">
                    <description>
The output terminal (OT) is used to interface between Units inside the audio function and the ‘outside world’. 
It serves as an outlet for audio information, flowing out of the audio function. Its function is to represent a sink of outgoing audio data 
before this data is properly packed from the original separate logical channels into the outgoing audio stream (the encoding process). 
The audio channel cluster enters the output terminal through a single input pin.
                    </description>
                </item>
                <item id="kFeatureUnit" label="Feature unit" value="USB_INTERFACE_SUBTYPE_AUDIO_CONTROL_FEATURE_UNIT">
                    <description>
The feature unit (FU) provides basic manipulation of multiple single-parameter audio controls on the incoming logical channels. 
It supports the following features: Mute, Volumne, Tone Control, Graphic Equalizer, Automatic Gain Control, Delay, Bass Boost and Loudness.                    
                    </description>
                </item>
            </enum>
            <struct id="unit_audio_2_0_config_t">
                <reference id="audio_unit" label="Audio Unit" type="units_audio_2_0_t"/>
                <variable id="unit_ref"
                    value="($parent.audio_unit.getValue() == `kClockSource`) 
                    ? $parent.clock_source 
                    : ($parent.audio_unit.getValue() == `kClockSelector`)
                    ? $parent.clock_selector
                    : ($parent.audio_unit.getValue() == `kClockMultiplier`)
                    ? $parent.clock_multiplier
                    : ($parent.audio_unit.getValue() == `kInputTerminal`)
                    ? $parent.input_terminal
                    : ($parent.audio_unit.getValue() == `kOutputTerminal`)
                    ? $parent.output_terminal
                    : $parent.feature_unit"/>
                <reference id="clock_source" label="Clock source" type="clockSource_descriptor_audio_2_0_t" available="$parent.audio_unit.getValue() == `kClockSource`">
                    <description>
The clock source (CS) provides sampling clock frequency to all or part of the audio function. A clock source can represent an internal sampling frequency generator, but it can also represent an external sampling clock signal input to the audio function.       
The clock source has a single clock output pin that carries the sampling clock signal, represented by the clock source. The clock output pin number is always one.
                    </description>
                </reference>
                <reference id="clock_selector" label="Clock selector" type="clockSelector_descriptor_audio_2_0_t" available="$parent.audio_unit.getValue() == `kClockSelector`">
                    <description>
The clock selector (CX) is used to select between multiple sampling clock signals that might be available inside an audio function. It has multiple clock input pins and a single clock output pin. clock input pins are numbered starting from one up to the total number of clock input pins on the clock selector. The clock output pin number is always one.
                    </description>
                </reference>
                <reference id="clock_multiplier" label="Clock multiplier" type="clockMultiplier_descriptor_audio_2_0_t" available="$parent.audio_unit.getValue() == `kClockMultiplier`">
                    <description>
The clock multiplier (CM) is used to derive a new clock signal with a different frequency from the clock signal at its single Clock Input Pin. It does this by multiplying that clock signal frequency by a numerator P and then dividing it by a denominator Q. The values P and Q are fixed for a given clock multiplier. The new clock signal is guaranteed to be synchronous with the input clock signal. A clock multiplier has one input pin and one output pin and their numbers are always one.
                    </description>
                </reference>
                <reference id="input_terminal" label="Input terminal" type="inputTerminal_descriptor_audio_2_0_t" available="$parent.audio_unit.getValue() == `kInputTerminal`">
                    <description>
The input terminal (IT) is used to interface between the audio function’s ‘outside world’ and other units in the audio function. 
It serves as a receptacle for audio information flowing into the audio function. Its function is to represent a source of incoming audio 
data after this data has been properly extracted from the original audio stream into the separate logical channels that are embedded in this 
stream (the decoding process). The logical channels are grouped into an audio channel cluster and leave the input terminal through a single output pin.
                    </description>
                </reference>
                <reference id="output_terminal" label="Output terminal" type="outputTerminal_descriptor_audio_2_0_t" available="$parent.audio_unit.getValue() == `kOutputTerminal`">
                    <description>
The output terminal (OT) is used to interface between Units inside the audio function and the ‘outside world’. 
It serves as an outlet for audio information, flowing out of the audio function. Its function is to represent a sink of outgoing audio data 
before this data is properly packed from the original separate logical channels into the outgoing audio stream (the encoding process). 
The audio channel cluster enters the output terminal through a single input pin.
                    </description>
                </reference>
                <reference id="feature_unit" label="Feature unit" type="featureUnit_descriptor_audio_2_0_t" available="$parent.audio_unit.getValue() == `kFeatureUnit`">
                    <description>
The feature unit (FU) provides basic manipulation of multiple single-parameter audio controls on the incoming logical channels. 
It supports the following features: Mute, Volumne, Tone Control, Graphic Equalizer, Automatic Gain Control, Delay, Bass Boost and Loudness.   
                    </description>
                </reference>
            </struct>
            <struct id="endpoints_setting_audio_2_0_t">
                <variable id="zeroBandwidthCondition" value="($parent.getParent().getParent().getSetting(`subclass`).getValue() == `kSubclassAudioStream`) &amp;&amp; ($parent.getId().toInt() == 0)" />
                <reference id="setting_name" type="setting_name_t" label="Custom setting name"/>
                <reference id="endpoints" type="endpoints_t">
                    <options_expr>
                        <option id="audio_stream_interface_2_0" expr="$parent.getParent().getParent().getSetting(`subclass`).getValue() == `kSubclassAudioStream`"/>
                    </options_expr>
                      <validation>
                        <constraint when_expr="($parent.getParent().getParent().getSetting(`subclass`).getValue() == `kSubclassAudioStream`) &amp;&amp; ($parent.getId().toInt() == 1)"
                            cond_expr="($this.getSize() &gt; 0)"
                            level="error" description="This alternate interface setting must contain at least one isochronous data endpoint according to the USB audio specification 2.0."/>
                        <!-- Audio streaming interface - zero bandwidth interface must be the first -->
                        <constraint when_expr="$parent.zeroBandwidthCondition.getValue()"
                            cond_expr="$this.getSize() == 0"
                            level="error" description="The first interface setting must be with zero bandwidth requirements - no endpoints defined."/>
                        <!-- Validations are also provided on the interface setting level (array of endpoints) -->
                        <constraint when_expr="($parent.getParent().getParent().getSetting(`subclass`).getValue() == `kSubclassAudioStream`) &amp;&amp; ($this.getSize() == 1) &amp;&amp; !($parent.zeroBandwidthCondition.getValue())"
                            cond_expr="($this.get(0).getSetting(`transfer_type`).getValue() == `kIsochronous`)"
                            level="error"
                            description="The audio streaming subclass supports one isochronous data endpoint (first) and one isochronous feedback endpoint (second) for each interface setting."/>
                        <constraint when_expr="($parent.getParent().getParent().getSetting(`subclass`).getValue() == `kSubclassAudioStream`) &amp;&amp; ($this.getSize() &gt;= 1) &amp;&amp; !($parent.zeroBandwidthCondition.getValue())"
                            cond_expr="($this.get(0).getSetting(`usage`).getValue() == `kData`) || ($this.get(0).getSetting(`usage`).getValue() == `kImplicitFeedback`)"
                            level="error"
                            description="Usage type of the isochronous data endpoint (the first one) can be either Data or Implicit feedback Data."/>
                        <constraint when_expr="($parent.getParent().getParent().getSetting(`subclass`).getValue() == `kSubclassAudioStream`) &amp;&amp; ($this.getSize() &gt;= 1) &amp;&amp; !($parent.zeroBandwidthCondition.getValue())"
                            cond_expr="$this.get(0).getSetting(`synchronization`).getValue() != `kNoSynchronization`"
                            level="error"
                            description="No synchronization cannot be set for the isochronous data endpoint (the first one)."/> 
                        <constraint when_expr="($parent.getParent().getParent().getSetting(`subclass`).getValue() == `kSubclassAudioStream`) &amp;&amp; ($this.getSize() &gt; 1) &amp;&amp; !($parent.zeroBandwidthCondition.getValue())"
                            cond_expr="($this.getSize() &lt;= 2) &amp;&amp; ($this.get(0).getSetting(`transfer_type`).getValue() == `kIsochronous`) &amp;&amp; ($this.get(1).getSetting(`transfer_type`).getValue() == `kIsochronous`)"
                            level="error"
                            description="The audio streaming subclass supports one isochronous data endpoint (first) and one isochronous feedback endpoint (second) for each interface setting."/>
                        <constraint when_expr="($parent.getParent().getParent().getSetting(`subclass`).getValue() == `kSubclassAudioStream`) &amp;&amp; ($this.getSize() &gt; 1) &amp;&amp; !($parent.zeroBandwidthCondition.getValue())"
                            cond_expr="$this.get(1).getSetting(`usage`).getValue() == `kFeedback`"
                            level="error"
                            description="Usage type of the isochronous feedback endpoint (the second one) can only be Feedback."/>
                        <constraint when_expr="($parent.getParent().getParent().getSetting(`subclass`).getValue() == `kSubclassAudioStream`) &amp;&amp; ($this.getSize() &gt; 1) &amp;&amp; !($parent.zeroBandwidthCondition.getValue())"
                            cond_expr="$this.get(1).getSetting(`synchronization`).getValue() == `kNoSynchronization`"
                            level="error"
                            description="No synchronization must be set for the isochronous feedback endpoint (the second one)."/> 
                    </validation> 
                </reference>
                <!-- AS Descriptors and settings -->
                <info id="audio_stream_info" label="Audio stream interface specific settings" value="($parent.endpoints.getSize() == 0) ? `No endpoints are available - configuration is disabled` : ``" options="UI_LABEL_BOLD" available="$parent.getParent().getParent().getSetting(`subclass`).getValue() == `kSubclassAudioStream`"/>
                <reference id="asInterface_descriptor_audio_2_0" label="AS Interface Descriptor" type="asInterface_descriptor_audio_2_0_t" available="$parent.getParent().getParent().getSetting(`subclass`).getValue() == `kSubclassAudioStream`" enable="($parent.endpoints.getSize() &gt; 0)" options="UI_LABEL_HIDDEN"/>
                <reference id="typeIFormat_descriptor_audio_2_0" label="Format Type Descriptor" type="typeIFormat_descriptor_audio_2_0_t" available="$parent.getParent().getParent().getSetting(`subclass`).getValue() == `kSubclassAudioStream`" enable="($parent.endpoints.getSize() &gt; 0)"/>
            </struct>
            <!-- Audio 2.0 Structure -->
            <struct id="setting_audio_2_0_t">
                <quick_selections>
                     <quick_selection id="QS_INTERFACE_AUDIO_CLASS" label="Audio default" available="$this.getMode() == `device`">
                        <set id="interface_name">Audio 20</set>
                        <set id="implementation">kImplementationNone</set>
                        <set id="subclass">kSubclassAudioControl</set>
                        <set id="protocol">kProtocolIPV20</set>
                        <set id="data_interface_count">0</set>
                        <set id="endpoints_settings.0"></set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_AUDIO_CLASS" label="Audio default" available="$this.getMode() == `host`">
                        <set id="interface_name">Audio 20</set>
                        <set id="implementation">kImplementationNone</set>
                        <set id="subclass">kSubclassNone</set>
                        <set id="protocol">kProtocolIPV20</set>
                        <set id="data_interface_count">0</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_AUDIO_CLASS_SPEAKER" label="Audio speaker" available="$this.getMode() == `host`">
                        <set id="interface_name">Audio 20 speaker</set>
                        <set id="implementation">kImplementationAudioSpeaker</set>
                        <set id="subclass">kSubclassNone</set>
                        <set id="protocol">kProtocolIPV20</set>
                        <set id="data_interface_count">0</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_AUDIO_CONTROL_SPEAKER" label="Audio control - speaker" available="$this.getMode() == `device`">
                        <set id="interface_name">Audio control</set>
                        <set id="implementation">kImplementationAudioSpeaker</set>
                        <set id="subclass">kSubclassAudioControl</set>
                        <set id="protocol">kProtocolIPV20</set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                        <!-- AC Class-Specific Header -->
                        <set id="acHeader_descriptor_audio_2_0.bCategory">kDesktopSpeaker</set>
                        <set id="acHeader_descriptor_audio_2_0.bmControls">kNone</set>
                        <!-- Units -->
                        <set id="units_audio_2_0.0"></set>
                        <set id="units_audio_2_0.0.audio_unit">kClockSource</set>
                        <set id="units_audio_2_0.0.clock_source.bClockID">1</set>
                        <set id="units_audio_2_0.0.clock_source.bmAttributesLow">kInternalFixedClock</set>
                        <set id="units_audio_2_0.0.clock_source.bmAttributesHigh">kFreeRunning</set>
                        <set id="units_audio_2_0.0.clock_source.bmControlsLow">kHostProgrammable</set>
                        <set id="units_audio_2_0.0.clock_source.bmControlsHigh">kReadOnly</set>
                        <!-- Input terminal -->
                        <set id="units_audio_2_0.1"></set>
                        <set id="units_audio_2_0.1.audio_unit">kInputTerminal</set>
                        <set id="units_audio_2_0.1.input_terminal.bTerminalID">2</set>
                        <set id="units_audio_2_0.1.input_terminal.wTerminalType">kStreaming</set>
                        <set id="units_audio_2_0.1.input_terminal.bCSourceID">bClockID_1</set>
                        <set id="units_audio_2_0.1.input_terminal.bNrChannels">2</set>
                        <set id="units_audio_2_0.1.input_terminal.bmChannelConfig.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FL">true</set>
                        <set id="units_audio_2_0.1.input_terminal.bmChannelConfig.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FR">true</set>
                        <set id="units_audio_2_0.1.input_terminal.bmControls_0_1bit">kNone</set>
                        <set id="units_audio_2_0.1.input_terminal.bmControls_2_3bit">kNone</set>
                        <set id="units_audio_2_0.1.input_terminal.bmControls_4_5bit">kNone</set>
                        <set id="units_audio_2_0.1.input_terminal.bmControls_6_7bit">kNone</set>
                        <set id="units_audio_2_0.1.input_terminal.bmControls_8_9bit">kNone</set>
                        <set id="units_audio_2_0.1.input_terminal.bmControls_10_11bit">kNone</set>
                        <!-- Feature unit -->
                        <set id="units_audio_2_0.2"></set>
                        <set id="units_audio_2_0.2.audio_unit">kFeatureUnit</set>
                        <set id="units_audio_2_0.2.feature_unit.bUnitID">3</set>
                        <set id="units_audio_2_0.2.feature_unit.bSourceID">bTerminalID_2</set>
                        <set id="units_audio_2_0.2.feature_unit.bmaControls.0.bmControls_0_1bit">kHostProgrammable</set>
                        <set id="units_audio_2_0.2.feature_unit.bmaControls.0.bmControls_2_3bit">kHostProgrammable</set>
                        <set id="units_audio_2_0.2.feature_unit.bmaControls.1"></set>
                        <set id="units_audio_2_0.2.feature_unit.bmaControls.2"></set>
                        <!-- Output terminal -->
                        <set id="units_audio_2_0.3"></set>
                        <set id="units_audio_2_0.3.audio_unit">kOutputTerminal</set>
                        <set id="units_audio_2_0.3.output_terminal.bTerminalID">4</set>
                        <set id="units_audio_2_0.3.output_terminal.wTerminalType">kSpeaker</set>
                        <set id="units_audio_2_0.3.output_terminal.bSourceID">bTerminalID_3</set>
                        <set id="units_audio_2_0.3.output_terminal.bCSourceID">bClockID_1</set>
                        <set id="units_audio_2_0.3.output_terminal.bmControls_0_1bit">kNone</set>
                        <set id="units_audio_2_0.3.output_terminal.bmControls_2_3bit">kNone</set>
                        <set id="units_audio_2_0.3.output_terminal.bmControls_4_5bit">kNone</set>
                        <set id="units_audio_2_0.3.output_terminal.bmControls_6_7bit">kNone</set>
                        <set id="units_audio_2_0.3.output_terminal.bmControls_8_9bit">kNone</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_AUDIO_STREAM_SPEAKER" label="Audio stream - speaker" available="$this.getMode() == `device`">
                        <set id="interface_name">Audio streaming</set>
                        <set id="implementation">kImplementationNone</set>
                        <set id="subclass">kSubclassAudioStream</set>
                        <set id="protocol">kProtocolIPV20</set>
                        <set id="endpoints_settings.0.setting_name">Zero bandwidth</set>
                        <set id="endpoints_settings.1.setting_name">Data output</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bTerminalLink">bTerminalID_2</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmControlsLow">kNone</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmControlsHigh">kNone</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bFormatType">kFormatI</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmFormats">kPCM</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bNrChannels">2</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmChannelConfig.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FL">true</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmChannelConfig.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FR">true</set>
                        <set id="endpoints_settings.1.typeIFormat_descriptor_audio_2_0.bSubslotSize">kTwo</set>
                        <set id="endpoints_settings.1.typeIFormat_descriptor_audio_2_0.bBitResolution">16</set>
                        <!-- Data endpoint -->
                        <set id="endpoints_settings.1.endpoints.0"></set>
                        <set id="endpoints_settings.1.endpoints.0.direction">kOut</set>
                        <set id="endpoints_settings.1.endpoints.0.transfer_type">kIsochronous</set>
                        <set id="endpoints_settings.1.endpoints.0.synchronization">kAsynchronous</set>
                        <set id="endpoints_settings.1.endpoints.0.usage">kData</set>
                        <set id="endpoints_settings.1.endpoints.0.max_packet_size_fs">custom:196</set>
                        <set id="endpoints_settings.1.endpoints.0.polling_interval_fs">1</set>
                        <set id="endpoints_settings.1.endpoints.0.max_packet_size_hs">custom:196</set>
                        <set id="endpoints_settings.1.endpoints.0.polling_interval_hs">4</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bmControls_0_1bit">kNone</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bmControls_2_3bit">kNone</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bmControls_4_5bit">kNone</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bLockDelayUnits">undefined</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.wLockDelay">0</set>
                        <set id="endpoints_settings.1.endpoints.1"></set>
                        <set id="endpoints_settings.1.endpoints.1.direction">kIn</set>
                        <set id="endpoints_settings.1.endpoints.1.transfer_type">kIsochronous</set>
                        <set id="endpoints_settings.1.endpoints.1.synchronization">kNoSynchronization</set>
                        <set id="endpoints_settings.1.endpoints.1.usage">kFeedback</set>
                        <set id="endpoints_settings.1.endpoints.1.max_packet_size_fs">custom:4</set>
                        <set id="endpoints_settings.1.endpoints.1.polling_interval_fs">1</set>
                        <set id="endpoints_settings.1.endpoints.1.max_packet_size_hs">custom:4</set>
                        <set id="endpoints_settings.1.endpoints.1.polling_interval_hs">4</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_AUDIO_CONTROL_GENERATOR" label="Audio control - generator" available="$this.getMode() == `device`">
                        <set id="interface_name">Audio control</set>
                        <set id="implementation">kImplementationAudioGenerator</set>
                        <set id="subclass">kSubclassAudioControl</set>
                        <set id="protocol">kProtocolIPV20</set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                        <!-- AC Class-Specific Header -->
                        <set id="acHeader_descriptor_audio_2_0.bCategory">kMicrophone</set>
                        <set id="acHeader_descriptor_audio_2_0.bmControls">kNone</set>
                        <!-- Units -->
                        <set id="units_audio_2_0.0"></set>
                        <set id="units_audio_2_0.0.audio_unit">kClockSource</set>
                        <set id="units_audio_2_0.0.clock_source.bClockID">1</set>
                        <set id="units_audio_2_0.0.clock_source.bmAttributesLow">kInternalFixedClock</set>
                        <set id="units_audio_2_0.0.clock_source.bmAttributesHigh">kFreeRunning</set>
                        <set id="units_audio_2_0.0.clock_source.bmControlsLow">kHostProgrammable</set>
                        <set id="units_audio_2_0.0.clock_source.bmControlsHigh">kReadOnly</set>
                        <!-- Input terminal -->
                        <set id="units_audio_2_0.1"></set>
                        <set id="units_audio_2_0.1.audio_unit">kInputTerminal</set>
                        <set id="units_audio_2_0.1.input_terminal.bTerminalID">2</set>
                        <set id="units_audio_2_0.1.input_terminal.wTerminalType">kMicrophone</set>
                        <set id="units_audio_2_0.1.input_terminal.bCSourceID">bClockID_1</set>
                        <set id="units_audio_2_0.1.input_terminal.bNrChannels">1</set>
                        <set id="units_audio_2_0.1.input_terminal.bmChannelConfig.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FL">true</set>
                        <set id="units_audio_2_0.1.input_terminal.bmControls_0_1bit">kNone</set>
                        <set id="units_audio_2_0.1.input_terminal.bmControls_2_3bit">kNone</set>
                        <set id="units_audio_2_0.1.input_terminal.bmControls_4_5bit">kNone</set>
                        <set id="units_audio_2_0.1.input_terminal.bmControls_6_7bit">kNone</set>
                        <set id="units_audio_2_0.1.input_terminal.bmControls_8_9bit">kNone</set>
                        <set id="units_audio_2_0.1.input_terminal.bmControls_10_11bit">kNone</set>
                        <!-- Feature unit -->
                        <set id="units_audio_2_0.2"></set>
                        <set id="units_audio_2_0.2.audio_unit">kFeatureUnit</set>
                        <set id="units_audio_2_0.2.feature_unit.bUnitID">3</set>
                        <set id="units_audio_2_0.2.feature_unit.bSourceID">bTerminalID_2</set>
                        <set id="units_audio_2_0.2.feature_unit.bmaControls.0.bmControls_0_1bit">kHostProgrammable</set>
                        <set id="units_audio_2_0.2.feature_unit.bmaControls.0.bmControls_2_3bit">kHostProgrammable</set>
                        <set id="units_audio_2_0.2.feature_unit.bmaControls.1"></set>
                        <!-- Output terminal -->
                        <set id="units_audio_2_0.3"></set>
                        <set id="units_audio_2_0.3.audio_unit">kOutputTerminal</set>
                        <set id="units_audio_2_0.3.output_terminal.bTerminalID">4</set>
                        <set id="units_audio_2_0.3.output_terminal.wTerminalType">kStreaming</set>
                        <set id="units_audio_2_0.3.output_terminal.bSourceID">bTerminalID_3</set>
                        <set id="units_audio_2_0.3.output_terminal.bCSourceID">bClockID_1</set>
                        <set id="units_audio_2_0.3.output_terminal.bmControls_0_1bit">kNone</set>
                        <set id="units_audio_2_0.3.output_terminal.bmControls_2_3bit">kNone</set>
                        <set id="units_audio_2_0.3.output_terminal.bmControls_4_5bit">kNone</set>
                        <set id="units_audio_2_0.3.output_terminal.bmControls_6_7bit">kNone</set>
                        <set id="units_audio_2_0.3.output_terminal.bmControls_8_9bit">kNone</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_AUDIO_STREAM_GENERATOR" label="Audio stream - generator" available="$this.getMode() == `device`">
                        <set id="interface_name">Audio streaming</set>
                        <set id="implementation">kImplementationNone</set>
                        <set id="subclass">kSubclassAudioStream</set>
                        <set id="protocol">kProtocolIPV20</set>
                        <set id="endpoints_settings.0.setting_name">Zero bandwidth</set>
                        <set id="endpoints_settings.1.setting_name">Data input</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bTerminalLink">bTerminalID_4</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmControlsLow">kNone</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmControlsHigh">kNone</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bFormatType">kFormatI</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmFormats">kPCM</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bNrChannels">1</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmChannelConfig.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FL">true</set>
                        <set id="endpoints_settings.1.typeIFormat_descriptor_audio_2_0.bSubslotSize">kOne</set>
                        <set id="endpoints_settings.1.typeIFormat_descriptor_audio_2_0.bBitResolution">8</set>
                        <!-- Data endpoint -->
                        <set id="endpoints_settings.1.endpoints.0"></set>
                        <set id="endpoints_settings.1.endpoints.0.direction">kIn</set>
                        <set id="endpoints_settings.1.endpoints.0.transfer_type">kIsochronous</set>
                        <set id="endpoints_settings.1.endpoints.0.synchronization">kSynchronous</set>
                        <set id="endpoints_settings.1.endpoints.0.usage">kData</set>
                        <set id="endpoints_settings.1.endpoints.0.max_packet_size_fs">k8</set>
                        <set id="endpoints_settings.1.endpoints.0.polling_interval_fs">1</set>
                        <set id="endpoints_settings.1.endpoints.0.max_packet_size_hs">k8</set>
                        <set id="endpoints_settings.1.endpoints.0.polling_interval_hs">4</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bmControls_0_1bit">kNone</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bmControls_2_3bit">kNone</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bmControls_4_5bit">kNone</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bLockDelayUnits">undefined</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.wLockDelay">0</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_AUDIO_CONTROL_UNIFIED" label="Audio control - unified" available="$this.getMode() == `device`">
                        <set id="interface_name">Audio control</set>
                        <set id="implementation">kImplementationAudioUnified</set>
                        <set id="subclass">kSubclassAudioControl</set>
                        <set id="protocol">kProtocolIPV20</set>
                        <set id="endpoints_settings.0.setting_name">Default</set>
                        <!-- AC Class-Specific Header -->
                        <set id="acHeader_descriptor_audio_2_0.bCategory">kHeadset</set>
                        <set id="acHeader_descriptor_audio_2_0.bmControls">kNone</set>
                        <!-- Units -->
                        <set id="units_audio_2_0.0"></set>
                        <set id="units_audio_2_0.0.audio_unit">kClockSource</set>
                        <set id="units_audio_2_0.0.clock_source.bClockID">1</set>
                        <set id="units_audio_2_0.0.clock_source.bmAttributesLow">kInternalFixedClock</set>
                        <set id="units_audio_2_0.0.clock_source.bmAttributesHigh">kFreeRunning</set>
                        <set id="units_audio_2_0.0.clock_source.bmControlsLow">kHostProgrammable</set>
                        <set id="units_audio_2_0.0.clock_source.bmControlsHigh">kReadOnly</set>
                        <!-- Input terminal -->
                        <set id="units_audio_2_0.1"></set>
                        <set id="units_audio_2_0.1.audio_unit">kInputTerminal</set>
                        <set id="units_audio_2_0.1.input_terminal.bTerminalID">2</set>
                        <set id="units_audio_2_0.1.input_terminal.wTerminalType">kMicrophone</set>
                        <set id="units_audio_2_0.1.input_terminal.bCSourceID">bClockID_1</set>
                        <set id="units_audio_2_0.1.input_terminal.bNrChannels">2</set>
                        <set id="units_audio_2_0.1.input_terminal.bmChannelConfig.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FL">true</set>
                        <set id="units_audio_2_0.1.input_terminal.bmChannelConfig.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FR">true</set>
                        <set id="units_audio_2_0.1.input_terminal.bmControls_0_1bit">kNone</set>
                        <set id="units_audio_2_0.1.input_terminal.bmControls_2_3bit">kNone</set>
                        <set id="units_audio_2_0.1.input_terminal.bmControls_4_5bit">kNone</set>
                        <set id="units_audio_2_0.1.input_terminal.bmControls_6_7bit">kNone</set>
                        <set id="units_audio_2_0.1.input_terminal.bmControls_8_9bit">kNone</set>
                        <set id="units_audio_2_0.1.input_terminal.bmControls_10_11bit">kNone</set>
                        <!-- Feature unit -->
                        <set id="units_audio_2_0.2"></set>
                        <set id="units_audio_2_0.2.audio_unit">kFeatureUnit</set>
                        <set id="units_audio_2_0.2.feature_unit.bUnitID">3</set>
                        <set id="units_audio_2_0.2.feature_unit.bSourceID">bTerminalID_2</set>
                        <set id="units_audio_2_0.2.feature_unit.bmaControls.0.bmControls_0_1bit">kHostProgrammable</set>
                        <set id="units_audio_2_0.2.feature_unit.bmaControls.0.bmControls_2_3bit">kHostProgrammable</set>
                        <set id="units_audio_2_0.2.feature_unit.bmaControls.1"></set>
                        <set id="units_audio_2_0.2.feature_unit.bmaControls.2"></set>
                        <!-- Output terminal -->
                        <set id="units_audio_2_0.3"></set>
                        <set id="units_audio_2_0.3.audio_unit">kOutputTerminal</set>
                        <set id="units_audio_2_0.3.output_terminal.bTerminalID">4</set>
                        <set id="units_audio_2_0.3.output_terminal.wTerminalType">kStreaming</set>
                        <set id="units_audio_2_0.3.output_terminal.bSourceID">bTerminalID_3</set>
                        <set id="units_audio_2_0.3.output_terminal.bCSourceID">bClockID_1</set>
                        <set id="units_audio_2_0.3.output_terminal.bmControls_0_1bit">kNone</set>
                        <set id="units_audio_2_0.3.output_terminal.bmControls_2_3bit">kNone</set>
                        <set id="units_audio_2_0.3.output_terminal.bmControls_4_5bit">kNone</set>
                        <set id="units_audio_2_0.3.output_terminal.bmControls_6_7bit">kNone</set>
                        <set id="units_audio_2_0.3.output_terminal.bmControls_8_9bit">kNone</set>
                        <!-- Input terminal -->
                        <set id="units_audio_2_0.4"></set>
                        <set id="units_audio_2_0.4.audio_unit">kInputTerminal</set>
                        <set id="units_audio_2_0.4.input_terminal.bTerminalID">5</set>
                        <set id="units_audio_2_0.4.input_terminal.wTerminalType">kStreaming</set>
                        <set id="units_audio_2_0.4.input_terminal.bCSourceID">bClockID_1</set>
                        <set id="units_audio_2_0.4.input_terminal.bNrChannels">2</set>
                        <set id="units_audio_2_0.4.input_terminal.bmChannelConfig.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FL">true</set>
                        <set id="units_audio_2_0.4.input_terminal.bmChannelConfig.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FR">true</set>
                        <set id="units_audio_2_0.4.input_terminal.bmControls_0_1bit">kNone</set>
                        <set id="units_audio_2_0.4.input_terminal.bmControls_2_3bit">kNone</set>
                        <set id="units_audio_2_0.4.input_terminal.bmControls_4_5bit">kNone</set>
                        <set id="units_audio_2_0.4.input_terminal.bmControls_6_7bit">kNone</set>
                        <set id="units_audio_2_0.4.input_terminal.bmControls_8_9bit">kNone</set>
                        <set id="units_audio_2_0.4.input_terminal.bmControls_10_11bit">kNone</set>
                        <!-- Feature unit -->
                        <set id="units_audio_2_0.5"></set>
                        <set id="units_audio_2_0.5.audio_unit">kFeatureUnit</set>
                        <set id="units_audio_2_0.5.feature_unit.bUnitID">6</set>
                        <set id="units_audio_2_0.5.feature_unit.bSourceID">bTerminalID_5</set>
                        <set id="units_audio_2_0.5.feature_unit.bmaControls.0.bmControls_0_1bit">kHostProgrammable</set>
                        <set id="units_audio_2_0.5.feature_unit.bmaControls.0.bmControls_2_3bit">kHostProgrammable</set>
                        <set id="units_audio_2_0.5.feature_unit.bmaControls.1"></set>
                        <set id="units_audio_2_0.5.feature_unit.bmaControls.2"></set>
                        <!-- Output terminal -->
                        <set id="units_audio_2_0.6"></set>
                        <set id="units_audio_2_0.6.audio_unit">kOutputTerminal</set>
                        <set id="units_audio_2_0.6.output_terminal.bTerminalID">7</set>
                        <set id="units_audio_2_0.6.output_terminal.wTerminalType">kSpeaker</set>
                        <set id="units_audio_2_0.6.output_terminal.bSourceID">bTerminalID_6</set>
                        <set id="units_audio_2_0.6.output_terminal.bCSourceID">bClockID_1</set>
                        <set id="units_audio_2_0.6.output_terminal.bmControls_0_1bit">kNone</set>
                        <set id="units_audio_2_0.6.output_terminal.bmControls_2_3bit">kNone</set>
                        <set id="units_audio_2_0.6.output_terminal.bmControls_4_5bit">kNone</set>
                        <set id="units_audio_2_0.6.output_terminal.bmControls_6_7bit">kNone</set>
                        <set id="units_audio_2_0.6.output_terminal.bmControls_8_9bit">kNone</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_AUDIO_STREAM_UNIFIED_0" label="Audio stream - unified input" available="$this.getMode() == `device`">
                        <!-- Audio streaming used in Audio 2.0 unfied for the microphone (host input) -->
                        <set id="interface_name">Audio streaming input</set>
                        <set id="implementation">kImplementationNone</set>
                        <set id="subclass">kSubclassAudioStream</set>
                        <set id="protocol">kProtocolIPV20</set>
                        <set id="endpoints_settings.0.setting_name">Zero bandwidth</set>
                        <set id="endpoints_settings.1.setting_name">Data input</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bTerminalLink">bTerminalID_4</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmControlsLow">kNone</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmControlsHigh">kNone</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bFormatType">kFormatI</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmFormats">kPCM</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bNrChannels">2</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmChannelConfig.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FL">true</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmChannelConfig.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FR">true</set>
                        <set id="endpoints_settings.1.typeIFormat_descriptor_audio_2_0.bSubslotSize">kTwo</set>
                        <set id="endpoints_settings.1.typeIFormat_descriptor_audio_2_0.bBitResolution">16</set>
                        <!-- Data endpoint -->
                        <set id="endpoints_settings.1.endpoints.0"></set>
                        <set id="endpoints_settings.1.endpoints.0.direction">kIn</set>
                        <set id="endpoints_settings.1.endpoints.0.transfer_type">kIsochronous</set>
                        <set id="endpoints_settings.1.endpoints.0.synchronization">kSynchronous</set>
                        <set id="endpoints_settings.1.endpoints.0.usage">kData</set>
                        <set id="endpoints_settings.1.endpoints.0.max_packet_size_fs">custom:192</set>
                        <set id="endpoints_settings.1.endpoints.0.polling_interval_fs">1</set>
                        <set id="endpoints_settings.1.endpoints.0.max_packet_size_hs">custom:192</set>
                        <set id="endpoints_settings.1.endpoints.0.polling_interval_hs">4</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bmControls_0_1bit">kNone</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bmControls_2_3bit">kNone</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bmControls_4_5bit">kNone</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bLockDelayUnits">undefined</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.wLockDelay">0</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_AUDIO_STREAM_UNIFIED_1" label="Audio stream - unified output" available="$this.getMode() == `device`">
                        <!-- Audio streaming used in Audio 2.0 unfied for the speaker (host output) -->
                        <set id="interface_name">Audio streaming output</set>
                        <set id="implementation">kImplementationNone</set>
                        <set id="subclass">kSubclassAudioStream</set>
                        <set id="protocol">kProtocolIPV20</set>
                        <set id="endpoints_settings.0.setting_name">Zero bandwidth</set>
                        <set id="endpoints_settings.1.setting_name">Data output</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bTerminalLink">bTerminalID_5</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmControlsLow">kNone</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmControlsHigh">kNone</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bFormatType">kFormatI</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmFormats">kPCM</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bNrChannels">2</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmChannelConfig.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FL">true</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmChannelConfig.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FR">true</set>
                        <set id="endpoints_settings.1.typeIFormat_descriptor_audio_2_0.bSubslotSize">kTwo</set>
                        <set id="endpoints_settings.1.typeIFormat_descriptor_audio_2_0.bBitResolution">16</set>
                        <!-- Data endpoint -->
                        <set id="endpoints_settings.1.endpoints.0"></set>
                        <set id="endpoints_settings.1.endpoints.0.direction">kOut</set>
                        <set id="endpoints_settings.1.endpoints.0.transfer_type">kIsochronous</set>
                        <set id="endpoints_settings.1.endpoints.0.synchronization">kAsynchronous</set>
                        <set id="endpoints_settings.1.endpoints.0.usage">kData</set>
                        <set id="endpoints_settings.1.endpoints.0.max_packet_size_fs">custom:196</set>
                        <set id="endpoints_settings.1.endpoints.0.polling_interval_fs">1</set>
                        <set id="endpoints_settings.1.endpoints.0.max_packet_size_hs">custom:196</set>
                        <set id="endpoints_settings.1.endpoints.0.polling_interval_hs">4</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bmControls_0_1bit">kNone</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bmControls_2_3bit">kNone</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bmControls_4_5bit">kNone</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bLockDelayUnits">undefined</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.wLockDelay">0</set>
                        <set id="endpoints_settings.1.endpoints.1"></set>
                        <set id="endpoints_settings.1.endpoints.1.direction">kIn</set>
                        <set id="endpoints_settings.1.endpoints.1.transfer_type">kIsochronous</set>
                        <set id="endpoints_settings.1.endpoints.1.synchronization">kNoSynchronization</set>
                        <set id="endpoints_settings.1.endpoints.1.usage">kFeedback</set>
                        <set id="endpoints_settings.1.endpoints.1.max_packet_size_fs">custom:3</set>
                        <set id="endpoints_settings.1.endpoints.1.polling_interval_fs">1</set>
                        <set id="endpoints_settings.1.endpoints.1.max_packet_size_hs">custom:4</set>
                        <set id="endpoints_settings.1.endpoints.1.polling_interval_hs">4</set>
                    </quick_selection>
                    <!-- This quick selection is used for USB FS (Full Speed) peripehrals in Window 10 as a workaround of Audio 2.0 issue (feedback endpoint packet size (FS) must be 4 bytes. -->
                    <quick_selection id="QS_INTERFACE_AUDIO_STREAM_UNIFIED_1_WIN10" label="Audio stream - unified output Win10" available="$this.getMode() == `device`">
                        <description>Audio 2.0 Audio stream unified interface definition for Windows 10 and USB FS (Full Speed) peripheral (used as a workaround of the Windows 10 issue - isochronous feedback packet size must be 4 bytes in this case).</description>
                        <!-- Audio streaming used in Audio 2.0 unfied for the speaker (host output) -->
                        <set id="interface_name">Audio streaming output</set>
                        <set id="implementation">kImplementationNone</set>
                        <set id="subclass">kSubclassAudioStream</set>
                        <set id="protocol">kProtocolIPV20</set>
                        <set id="endpoints_settings.0.setting_name">Zero bandwidth</set>
                        <set id="endpoints_settings.1.setting_name">Data output</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bTerminalLink">bTerminalID_5</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmControlsLow">kNone</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmControlsHigh">kNone</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bFormatType">kFormatI</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmFormats">kPCM</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bNrChannels">2</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmChannelConfig.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FL">true</set>
                        <set id="endpoints_settings.1.asInterface_descriptor_audio_2_0.bmChannelConfig.USB_INTERFACE_AUDIO_CONTROL_INPUT_TERMINAL_CHANNEL_CONFIG_FR">true</set>
                        <set id="endpoints_settings.1.typeIFormat_descriptor_audio_2_0.bSubslotSize">kTwo</set>
                        <set id="endpoints_settings.1.typeIFormat_descriptor_audio_2_0.bBitResolution">16</set>
                        <!-- Data endpoint -->
                        <set id="endpoints_settings.1.endpoints.0"></set>
                        <set id="endpoints_settings.1.endpoints.0.direction">kOut</set>
                        <set id="endpoints_settings.1.endpoints.0.transfer_type">kIsochronous</set>
                        <set id="endpoints_settings.1.endpoints.0.synchronization">kAsynchronous</set>
                        <set id="endpoints_settings.1.endpoints.0.usage">kData</set>
                        <set id="endpoints_settings.1.endpoints.0.max_packet_size_fs">custom:196</set>
                        <set id="endpoints_settings.1.endpoints.0.polling_interval_fs">1</set>
                        <set id="endpoints_settings.1.endpoints.0.max_packet_size_hs">custom:196</set>
                        <set id="endpoints_settings.1.endpoints.0.polling_interval_hs">4</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bmControls_0_1bit">kNone</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bmControls_2_3bit">kNone</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bmControls_4_5bit">kNone</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.bLockDelayUnits">undefined</set>
                        <set id="endpoints_settings.1.endpoints.0.cs_as_data_2_0.wLockDelay">0</set>
                        <set id="endpoints_settings.1.endpoints.1"></set>
                        <set id="endpoints_settings.1.endpoints.1.direction">kIn</set>
                        <set id="endpoints_settings.1.endpoints.1.transfer_type">kIsochronous</set>
                        <set id="endpoints_settings.1.endpoints.1.synchronization">kNoSynchronization</set>
                        <set id="endpoints_settings.1.endpoints.1.usage">kFeedback</set>
                        <set id="endpoints_settings.1.endpoints.1.max_packet_size_fs">custom:4</set>
                        <set id="endpoints_settings.1.endpoints.1.polling_interval_fs">1</set>
                        <set id="endpoints_settings.1.endpoints.1.max_packet_size_hs">custom:4</set>
                        <set id="endpoints_settings.1.endpoints.1.polling_interval_hs">4</set>
                    </quick_selection>
                    <default>QS_INTERFACE_AUDIO_CLASS</default>
                </quick_selections>
                <reference id="interface_name" type="interface_name_t" label="Custom interface name"/>
                <reference id="subclass" type="subClass_audio_2_0_t" label="Subclass">
                    <validation>
                        <constraint when_expr="$this.getValue() == `kSubclassAudioControl`" cond_expr="$parent.getParent().getParent().countOccurrences(x -> (x.isAvailable() &amp;&amp; x.isEnabled() &amp;&amp; (x.getId() == `subclass`) &amp;&amp; (x.getValue() == `kSubclassAudioControl`)), true) == 1" level="error" 
                            description="This USB component supports one audio control interface only. All audio units shall be configured in the only one Audio control interface configuration."/>
                        <constraint when_expr="$this.getValue() == `kSubclassAudioStream`" cond_expr="($parent.getParent().getID() != `0`) &amp;&amp; ($parent.getParent().getParent().get($parent.getParent().getID().toInt() - 1).getSetting(`interface_class`).getValue() == `kClassAudio_2_0`) &amp;&amp;
                            (($parent.getParent().getParent().get($parent.getParent().getID().toInt() - 1).getSetting(`setting_audio_2_0.subclass`).getValue() == `kSubclassAudioControl`) || ($parent.getParent().getParent().get($parent.getParent().getID().toInt() - 1).getSetting(`setting_audio_2_0.subclass`).getValue() == `kSubclassAudioStream`))" level="error" 
                            description="The audio streaming interfaces (the Audio stream subclasses) must be placed just behind the USB audio control interface (the Audio control subclass) in the Supported interface list to provide the interface association descriptor (use the Move Up/Down buttons to fix the order of interfaces)."/>
                        <constraint when_expr="$this.getValue() == `kSubclassAudioStream`" cond_expr="$parent.getParent().getParent().countOccurrences(x -> (x.isAvailable() &amp;&amp; x.isEnabled() &amp;&amp; (x.getId() == `subclass`) &amp;&amp; (x.getValue() == `kSubclassAudioControl`)), true) &gt;= 1" level="error" 
                            description="The audio stream interface is a part of the audio function and it cannot be used alone. It must be used together with audio control interface."/> 
                        <constraint when_expr="$this.getValue() == `kSubclassAudioControl`" cond_expr="$parent.getParent().getParent().countOccurrences(x -> (x.isAvailable() &amp;&amp; x.isEnabled() &amp;&amp; (x.getId() == `subclass`) &amp;&amp; (x.getValue() == `kSubclassAudioStream`)), true) &gt;= 1" level="error" 
                            description="The audio control interface is a part of the audio function and it cannot be used alone. It must be used together with audio stream interface(s)."/>
                    </validation>
                </reference>
                <reference id="protocol" type="protocol_audio_2_0_t" label="Protocol"/>
                <info id="classImplementationBegin" label="Class implementation code" value="`Class implementation code for interface (` + $parent.interface_name.getValue() + `)`" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"/>
                <reference id="implementation" type="implementation_audio_t" label="Generate code example">
                    <options_expr>
                        <option id="UI_OPEN_DOCUMENTATION" expr="`workflow.md`"/>
                    </options_expr>
                    <description>This setting allows generating of the example code. This seeting is enabled for the audio control subclass only. The audio streaming subclass is generated as a part of the audio example automatically.</description>
                </reference>
                <info id="classImplementationInfo" label=" " value="$parent.implementation.enumItemsOf().findFirst(x -> (x.getId() == $parent.implementation.getEnumItemId())).getDescription()"/>
                <info id="classImplementationEnd" label="Class implementation code" value="``" options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"/>
                <array id="endpoints_settings" label="Interface setting" type="endpoints_setting_audio_2_0_t" min_expr="1" options="ShowContentAs=TABS;UI_ARRAY_REORDER" key_selector_expr="setting -> setting.generateSettingKey()" available="$this.getMode() == `device`">
                    <description>Audio control/streaming interface configuration including endpoints. Setting 0 is the default setting that should provide the zero bandwidth. Other interface configurations are alternate settings for streaming of audio data.</description>
                    <validation>
                        <constraint when_expr="($parent.subclass.getValue() == `kSubclassAudioControl`) &amp;&amp; ($this.getSize() &gt; 0) &amp;&amp; ($this.get(0).getSetting(`endpoints`).getSize() &gt; 0)"
                                    cond_expr="($this.get(0).getSetting(`endpoints`).getSize() &lt; 2) &amp;&amp; (($this.get(0).getSetting(`endpoints`).getSize() == 0) || ($this.get(0).getSetting(`endpoints`).get(0).getSetting(`transfer_type`).getValue() == `kInterrupt`))"
                                    level="error" 
                                    description="The audio control subclass support one optional interrupt endpoint only."/>
                        <constraint when_expr="$parent.subclass.getValue() == `kSubclassAudioControl`"
                                    cond_expr="($this.getSize() &lt;= 1)" 
                                    level="error"
                                    description="The audio control subclass does not support alternate interfaces. It supports one interrupt setting only."/>
                        <constraint when_expr="$parent.subclass.getValue() == `kSubclassAudioStream`"
                                    cond_expr="($this.getSize() &gt;= 2)" 
                                    level="error"
                                    description="The audio streaming interface requires at least two interfaces according to the USB audio specification 2.0. The first must be with zero bandwidth requirements (no isochronous data endpoint defined) and an additional alternate interface that contains the isochronous data endpoint."/>
                        <!-- Audio streaming interface - zero bandwidth interface must be first if used, one isochronous data endpoint only plus the optional isochronous feedback endpoint -->
                       <!-- <constraint when_expr="($parent.subclass.getValue() == `kSubclassAudioStream`) &amp;&amp; ($this.getSize() &gt; 0) &amp;&amp; ($this.countOccurrences(item -> item.getSetting(`endpoints`).getSize() == 0) &gt; 0)"
                            cond_expr="($this.get(0).getSetting(`endpoints`).getSize() == 0)"
                            level="error" description="When the zero bandwidth interface setting is used it must be first interface setting according to the USB audio specification 2.0."/> -->
                    </validation>
                </array>
                <!-- AC descriptors and settings -->
                <reference id="acHeader_descriptor_audio_2_0" label="AC Interface Descriptor Header" type="acHeader_descriptor_audio_2_0_t" available="$parent.subclass.getValue() == `kSubclassAudioControl` &amp;&amp; $this.getMode() == `device`"/>
                <array id="units_audio_2_0" label="Audio control interface configuration" type="unit_audio_2_0_config_t"
                       available="$parent.subclass.getValue() == `kSubclassAudioControl` &amp;&amp; $this.getMode() == `device`"
                       options="ShowContentAs=TABS;UI_ARRAY_REORDER"
                       key_selector_expr="setting -> setting.getSetting(`unit_ref`).getValue().getSetting(`key_name`).getValue()"
                       enable="$parent.subclass.getValue() == `kSubclassAudioControl`">
                    <description>Configuration of audio control units that the system consists from. This setting is available for the Audio control subclass only</description>
                    <validation>
                        <constraint cond_expr="($this.countOccurrences(item -> (item.getSetting(`audio_unit`).getValue() == `kOutputTerminal`)) &gt; 0)" level="error"
                                    description="Audio control interface shall contain at least one output terminal."/>
                        <constraint cond_expr="($this.countOccurrences(item -> (item.getSetting(`audio_unit`).getValue() == `kInputTerminal`)) &gt; 0)" level="error"
                                    description="Audio control interface shall contain at least one input terminal."/>
                        <constraint cond_expr="($this.countOccurrences(item -> (item.getSetting(`audio_unit`).getValue() == `kClockSource`)) &gt; 0)" level="error"
                                    description="Audio control interface shall contain at least one clock source."/>
                    </validation>
                    <item_defaults>
                        <set_default id="clock_source.bClockID"
                                     value_expr="x -> (x.getID()==`0`) ? 1 : (getAudioUnitID(x.getParent().get(x.getID().toInt() - 1)) + 1)"/>
                        <set_default id="clock_selector.bClockID"
                                     value_expr="x -> (x.getID()==`0`) ? 1 : (getAudioUnitID(x.getParent().get(x.getID().toInt() - 1)) + 1)"/>
                        <set_default id="clock_multiplier.bClockID"
                                     value_expr="x -> (x.getID()==`0`) ? 1 : (getAudioUnitID(x.getParent().get(x.getID().toInt() - 1)) + 1)"/>
                        <set_default id="input_terminal.bTerminalID"
                                     value_expr="x -> (x.getID()==`0`) ? 1 : (getAudioUnitID(x.getParent().get(x.getID().toInt() - 1)) + 1)"/>
                        <set_default id="output_terminal.bTerminalID"
                                     value_expr="x -> (x.getID()==`0`) ? 1 : (getAudioUnitID(x.getParent().get(x.getID().toInt() - 1)) + 1)"/>
                        <set_default id="feature_unit.bUnitID"
                                     value_expr="x -> (x.getID()==`0`) ? 1 : (getAudioUnitID(x.getParent().get(x.getID().toInt() - 1)) + 1)"/>        
                    </item_defaults>
                </array>
                <!-- Auxiliary variables -->
                <reference id="starting_in_ep_nr" type="starting_in_ep_nr_t" available="$this.getMode() == `device`"/>
                <reference id="starting_out_ep_nr" type="starting_out_ep_nr_t" available="$this.getMode() == `device`"/>
                <reference id="in_ep_count" type="in_ep_count_t" available="$this.getMode() == `device`"/>
                <reference id="out_ep_count" type="out_ep_count_t" available="$this.getMode() == `device`"/>
                <!-- this setting enables/disables the generating of the template interface file when the implementation is None -->
                <variable id="generateTemplateInterface" value="($parent.subclass.getValue() == `kSubclassAudioStream`) ? false : true"></variable>
                <!-- Number of audio streaming interfaces for the header -->
                <variable id="number_of_audio_interfaces" value="$parent.getParent().getParent().countOccurrences(x -> (x.isAvailable() &amp;&amp; x.isEnabled() &amp;&amp; (x.getId() == `subclass`) &amp;&amp; (x.getValue() == `kSubclassAudioStream`)), true)"/>
                <!-- Array of audio streaming interface for the header -->
                <variable id="list_of_audio_interfaces" value="$parent.getParent().getParent().filter(x -> (x.isAvailable() &amp;&amp; x.isEnabled() &amp;&amp; (x.nodeExists(`subclass`)) &amp;&amp; (x.getSetting(`subclass`).getValue() == `kSubclassAudioStream`)), true).map(x -> x.getParent().getId())"/>
            </struct>
            <!-- End of Audio 2.0 -->
            <!-- Start Audio Host-->
            <struct id="setting_audio_host_t">
                <quick_selections>
                    <quick_selection id="QS_INTERFACE_AUDIO_CLASS" label="Audio default" available="$this.getMode() == `host`">
                        <set id="interface_name">Audio</set>
                        <set id="implementation">kImplementationNone</set>
                        <set id="subclass">kSubclassNone</set>
                        <set id="protocol">kProtocolNone</set>
                        <set id="data_interface_count">0</set>
                    </quick_selection>
                    <quick_selection id="QS_INTERFACE_AUDIO_CLASS_SPEAKER" label="Audio speaker" available="$this.getMode() == `host`">
                        <set id="interface_name">Audio speaker</set>
                        <set id="implementation">kImplementationAudioSpeaker</set>
                        <set id="subclass">kSubclassNone</set>
                        <set id="protocol">kProtocolNone</set>
                        <set id="data_interface_count">0</set>
                    </quick_selection>
                    <default>QS_INTERFACE_AUDIO_CLASS</default>
                </quick_selections>
                <reference id="interface_name" type="interface_name_t" label="Custom interface name"/>
                <reference id="implementation" type="implementation_audio_t" label="Generate class implementation code">
                    <description>This setting allows generating of the example code. This setting is enabled for the audio control subclass only. The audio streaming subclass is generated as a part of the audio example automatically.</description>
                </reference>
                <reference id="subclass" type="subClass_audio_2_0_t" label="Subclass">
                    <validation>
                        <constraint when_expr="$this.getValue() == `kSubclassAudioControl`" cond_expr="$parent.getParent().getParent().countOccurrences(x -> (x.isAvailable() &amp;&amp; x.isEnabled() &amp;&amp; (x.getId() == `subclass`) &amp;&amp; (x.getValue() == `kSubclassAudioControl`)), true) == 1" level="error" 
                            description="This USB component supports one audio control interface only. All audio units shall be configured in the only one Audio control interface configuration."/>
                        <constraint when_expr="$this.getValue() == `kSubclassAudioControl`" cond_expr="$parent.getParent().getParent().countOccurrences(x -> (x.isAvailable() &amp;&amp; x.isEnabled() &amp;&amp; (x.getId() == `subclass`) &amp;&amp; (x.getValue() == `kSubclassAudioStream`)), true) &gt;= 1" level="error" 
                            description="The audio control interface is a part of the audio function and it cannot be used alone. It must be used together with audio stream interface(s)."/>
                    </validation>
                </reference>
                <reference id="protocol" type="protocol_audio_2_0_t" label="Protocol"/>     
                <!-- Auxiliary variables -->                
                <!-- this setting enables/disables the generating of the template interface file when the implementation is None -->
                <variable id="generateTemplateInterface" value="($parent.subclass.getValue() == `kSubclassAudioStream`) ? false : true"></variable>
                <!-- Number of audio streaming interfaces for the header -->
                <variable id="number_of_audio_interfaces" value="$parent.getParent().getParent().countOccurrences(x -> (x.isAvailable() &amp;&amp; x.isEnabled() &amp;&amp; (x.getId() == `subclass`) &amp;&amp; (x.getValue() == `kSubclassAudioStream`)), true)"/>
                <!-- Array of audio streaming interface for the header -->
                <variable id="list_of_audio_interfaces" value="$parent.getParent().getParent().filter(x -> (x.isAvailable() &amp;&amp; x.isEnabled() &amp;&amp; (x.nodeExists(`subclass`)) &amp;&amp; (x.getSetting(`subclass`).getValue() == `kSubclassAudioStream`)), true).map(x -> x.getParent().getId())"/>
            </struct>
            <!-- End Audio Host-->
            <struct id="interface_setting_t" label="Interface setting" from="_interface_setting">
                <reference id="interface_class" type="interface_class_t" label="Class">
                    <validation>
                        <!-- Device SWCompRefs -->
                        <dependency when_expr="(($this.getValue() == `kClassDic`) || ($this.getValue() == `kClassCic`)) &amp;&amp; ($parent.getParent().hasOption(`usb_device`) == true) &amp;&amp; checkPreviousClasses($parent.getParent(), $this)" 
                            resource_type="SWComponent" resource_id="middleware.usb.device.cdc.external" level="error" 
                            description="&quot;USB device CDC&quot; driver is missing in the project.">
                            <feature name="enabled" evaluation="equal">
                                <data expr="true"/>
                            </feature>
                        </dependency>
                        <dependency when_expr="($this.getValue() == `kClassDfu`) &amp;&amp; ($parent.getParent().hasOption(`usb_device`) == true) &amp;&amp; checkPreviousClasses($parent.getParent(), $this)" 
                            resource_type="SWComponent" resource_id="middleware.usb.device.dfu.external" level="error" 
                            description="&quot;USB device DFU&quot; driver is missing in the project.">
                            <feature name="enabled" evaluation="equal">
                                <data expr="true"/>
                            </feature>
                        </dependency>
                        <dependency when_expr="($this.getValue() == `kClassHid`) &amp;&amp; ($parent.getParent().hasOption(`usb_device`) == true) &amp;&amp; checkPreviousClasses($parent.getParent(), $this)" 
                            resource_type="SWComponent" resource_id="middleware.usb.device.hid.external" level="error" 
                            description="&quot;USB device HID&quot; driver is missing in the project.">
                            <feature name="enabled" evaluation="equal">
                                <data expr="true"/>
                            </feature>
                        </dependency>
                        <dependency when_expr="($this.getValue() == `kClassMsc`) &amp;&amp; ($parent.getParent().hasOption(`usb_device`) == true) &amp;&amp; checkPreviousClasses($parent.getParent(), $this)" 
                            resource_type="SWComponent" resource_id="middleware.usb.device.msd.external" level="error" 
                            description="&quot;USB device MSC&quot; driver is missing in the project.">
                            <feature name="enabled" evaluation="equal">
                                <data expr="true"/>
                            </feature>
                        </dependency>
                        <dependency when_expr="($this.getValue() == `kClassPhdc`) &amp;&amp; ($parent.getParent().hasOption(`usb_device`) == true) &amp;&amp; checkPreviousClasses($parent.getParent(), $this)" 
                            resource_type="SWComponent" resource_id="middleware.usb.device.phdc.external" level="error" 
                            description="&quot;USB device PHDC&quot; driver is missing in the project.">
                            <feature name="enabled" evaluation="equal">
                                <data expr="true"/>
                            </feature>
                        </dependency>
                        <dependency when_expr="($this.getValue() == `kClassPrinter`) &amp;&amp; ($parent.getParent().hasOption(`usb_device`) == true) &amp;&amp; checkPreviousClasses($parent.getParent(), $this)" 
                            resource_type="SWComponent" resource_id="middleware.usb.device.printer.external" level="error" 
                            description="&quot;USB device printer&quot; driver is missing in the project.">
                            <feature name="enabled" evaluation="equal">
                                <data expr="true"/>
                            </feature>
                        </dependency>
                        <dependency when_expr="(($this.getValue() == `kClassAudio_1_0`) || ($this.getValue() == `kClassAudio_2_0`)) &amp;&amp; ($parent.getParent().hasOption(`usb_device`) == true) &amp;&amp; checkPreviousClasses($parent.getParent(), $this)" 
                            resource_type="SWComponent" resource_id="middleware.usb.device.audio.external" level="error" 
                            description="&quot;USB device audio&quot; driver is missing in the project.">
                            <feature name="enabled" evaluation="equal">
                                <data expr="true"/>
                            </feature>
                        </dependency>
                        <!-- Host SWCompRefs -->
                        <dependency when_expr="(($this.getValue() == `kClassDic`) || ($this.getValue() == `kClassCic`)) &amp;&amp; ($parent.getParent().hasOption(`usb_host`) == true) &amp;&amp; checkPreviousClasses($parent.getParent(), $this)" 
                            resource_type="SWComponent" resource_id="middleware.usb.host_cdc" level="error" 
                            description="&quot;USB host CDC&quot; driver is missing in the project.">
                            <feature name="enabled" evaluation="equal">
                                <data expr="true"/>
                            </feature>
                        </dependency>
                        <dependency when_expr="($this.getValue() == `kClassHid`) &amp;&amp; ($parent.getParent().hasOption(`usb_host`) == true) &amp;&amp; checkPreviousClasses($parent.getParent(), $this)" 
                            resource_type="SWComponent" resource_id="middleware.usb.host_hid" level="error" 
                            description="&quot;USB host HID&quot; driver is missing in the project.">
                            <feature name="enabled" evaluation="equal">
                                <data expr="true"/>
                            </feature>
                        </dependency>
                        <dependency when_expr="($this.getValue() == `kClassPhdc`) &amp;&amp; ($parent.getParent().hasOption(`usb_host`) == true) &amp;&amp; checkPreviousClasses($parent.getParent(), $this)" 
                            resource_type="SWComponent" resource_id="middleware.usb.host_phdc" level="error" 
                            description="&quot;USB host PHDC&quot; driver is missing in the project.">
                            <feature name="enabled" evaluation="equal">
                                <data expr="true"/>
                            </feature>
                        </dependency>
                        <dependency when_expr="($this.getValue() == `kClassPrinter`) &amp;&amp; ($parent.getParent().hasOption(`usb_host`) == true) &amp;&amp; checkPreviousClasses($parent.getParent(), $this)" 
                            resource_type="SWComponent" resource_id="middleware.usb.host_printer" level="error" 
                            description="&quot;USB host printer&quot; driver is missing in the project.">
                            <feature name="enabled" evaluation="equal">
                                <data expr="true"/>
                            </feature>
                        </dependency>
                        <dependency when_expr="($this.getValue() == `kClassAudioHost`) &amp;&amp; ($parent.getParent().hasOption(`usb_host`) == true) &amp;&amp; checkPreviousClasses($parent.getParent(), $this)" 
                            resource_type="SWComponent" resource_id="middleware.usb.host_audio" level="error" 
                            description="&quot;USB host audio&quot; driver is missing in the project.">
                            <feature name="enabled" evaluation="equal">
                                <data expr="true"/>
                            </feature>
                        </dependency>
                    </validation>
                </reference>
                <reference id="setting_cic" type="setting_cic_t" label="Use case" available="$parent.interface_class.value() == `kClassCic`"/>
                <reference id="setting_dic" type="setting_dic_t" label="Use case" available="$parent.interface_class.value() == `kClassDic`"/>
                <reference id="setting_msc" type="setting_msc_t" label="Use case" available="$parent.interface_class.value() == `kClassMsc`"/>
                <reference id="setting_hid" type="setting_hid_t" label="Use case" available="$parent.interface_class.value() == `kClassHid`"/>
                <reference id="setting_phdc" type="setting_phdc_t" label="Use case" available="$parent.interface_class.value() == `kClassPhdc`"/>
                <reference id="setting_printer" type="setting_printer_t" label="Use case" available="$parent.interface_class.value() == `kClassPrinter`"/>
                <reference id="setting_dfu" type="setting_dfu_t" label="Use case" available="$parent.interface_class.value() == `kClassDfu`"/>
                <reference id="setting_audio_1_0" type="setting_audio_t" label="Use case" available="$parent.interface_class.value() == `kClassAudio_1_0`"/>
                <reference id="setting_audio_2_0" type="setting_audio_2_0_t" label="Use case" available="$parent.interface_class.value() == `kClassAudio_2_0`"/>
                <reference id="setting_audiohost" type="setting_audio_host_t" label="Use case" available="$parent.interface_class.value() == `kClassAudioHost`"/>
            </struct>
            <array id="interfaces_t" type="interface_setting_t" label="Supported interfaces" options="ShowContentAs=MASTER_DETAIL;UI_ARRAY_REORDER;UI_TABLE_COLUMN_WIDTHS=12" key_selector_expr="x -> x.generateInterfaceKey()">
                <validation>
                    <constraint cond_expr="$this.getSize() &gt; 0" level="error" description="There must be at least one supported interface."/>
                    <constraint cond_expr="$this.countOccurrences(interface -> interface.getSetting(`interface_class`).getValue() == `kClassDfu`) &lt;= 1" level="error" description="A maximum of one DFU interface is allowed."/>
                    <constraint cond_expr="$this.get(0).getSetting(`interface_class`).getValue() == `kClassDfu`" when_expr="$this.countOccurrences(interface -> interface.getSetting(`interface_class`).getValue() == `kClassDfu`) &gt; 0" level="error" description="The DFU interface must have index 0."/>
                </validation>
                <item_defaults>
                    <set_default id="setting_phdc" value_expr="(x) -> $this.getMode() == `host` ? `QS_INTERFACE_PHDC_MANAGER` : `QS_INTERFACE_PHDC_WEIGHT_SCALE`"/>
                </item_defaults>
            </array>
        </user_types>
        <settings/>
        <validation/>
        <quick_selections/>
    </config_set>
    <config_set id="hostSettings" label="Host role">
        <description>Host mode settings</description>
        <generated_types/>
        <user_types/>
        <settings>
            <variable id="hasDevicePhdc" value="hasModePhdc(`device`)"/>
            <variable id="ieee11073TypesRequired" value="$parent.interfaces.isIeee11073TypesRequired()"/>
            <variable id="isIeee11073TypesRequiredInDevice" value="isIeee11073TypesRequiredInMode(`device`)"/>
            <variable id="high_speed_supported" value="$instance.getPeripheral() != `USB0`"></variable>
            <reference id="control_max_packet_size_fs" type="control_max_packet_size_fs_t" config_set_id="commonSettings" options="remove_from_struct_init" available="false"/><!-- used for max_packet_size_fs dynamic enum only -->
            <reference id="bulk_max_packet_size_fs" type="bulk_max_packet_size_fs_t" config_set_id="commonSettings" options="remove_from_struct_init" available="false"/><!-- used for max_packet_size_fs dynamic enum only -->
            <reference id="interrupt_max_packet_size_fs" type="interrupt_max_packet_size_fs_t" config_set_id="commonSettings" options="remove_from_struct_init" available="false"/><!-- used for max_packet_size_fs dynamic enum only -->
            <reference id="isochronous_max_packet_size_fs" type="isochronous_max_packet_size_fs_t" config_set_id="commonSettings" options="remove_from_struct_init" available="false"/><!-- used for max_packet_size_fs dynamic enum only -->
            <reference id="control_max_packet_size_hs" type="control_max_packet_size_hs_t" config_set_id="commonSettings" options="remove_from_struct_init" available="false"/><!-- used for max_packet_size_hs dynamic enum only -->
            <reference id="bulk_max_packet_size_hs" type="bulk_max_packet_size_hs_t" config_set_id="commonSettings" options="remove_from_struct_init" available="false"/><!-- used for max_packet_size_hs dynamic enum only -->
            <reference id="interrupt_max_packet_size_hs" type="interrupt_max_packet_size_hs_t" config_set_id="commonSettings" options="remove_from_struct_init" available="false"/><!-- used for max_packet_size_fs dynamic enum only -->
            <reference id="isochronous_max_packet_size_hs" type="isochronous_max_packet_size_hs_t" config_set_id="commonSettings" options="remove_from_struct_init" available="false"/><!-- used for max_packet_size_fs dynamic enum only -->
            <variable id="irq_handler" value="getResource(`interrupts`, $instance.getCoreId())
                .filter(
                    enumItem -> (
                        enumItem.getSetting(`devices`).searchInArray(
                            item -> (
                                (item.getSetting(`id`).getValue() == $instance.getPeripheral()) &amp;&amp; (item.getSetting(`function`).getValue() == `usb`)
                            )
                        ) >= 0
                    )
                ).getFirst().getSetting(`handler_id`).getValue()"/>
            <integer id="max_power" label="Max power [mA]" type="uint16_t">
                <description>Maximum power that can be supplied by the host.</description>
                <validation>
                    <constraint cond_expr="$this.value() &gt;= 100" level="error" description="Host must be able to provide at least 100 mA."/>
                </validation>
            </integer>
            <bool id="hub_support" label="HUB support"/>
            <info id="host_task_call" label="Host task call" value="`USB_HostTasks();`" options="UI_INFO_COPY_BUTTON">
                <description>Generated polling routine to put inside the while loop of the main() function.</description>
            </info>
            <reference id="interfaces" type="interfaces_t" config_set_id="commonSettings" options="usb_host"/>
            <variable id="sharedPeripherals_supported" value="toArray(`NVIC`)"/>
            <variable id="sharedPeripherals" value="getResource(`interrupts`, $instance.getCoreId()).filter(irqItem -> (irqItem.getSetting(`devices`).size() &gt; 1) &amp;&amp; (irqItem.getSetting(`devices`).anyMatch(item -> (item.getSetting(`id`).getValue() == $instance.getPeripheral())))).map(item -> ((item.getSetting(`devices`).size() > 1) ? (item.getSetting(`devices`).findFirst(dev -> (dev.getSetting(`id`).getValue() != $instance.getPeripheral())).getSetting(`id`).getValue()) : `N/A`)).removeDuplicates(x -> x).filter(dev -> $parent.sharedPeripherals_supported.getValue().noneMatch(i -> (i == dev)))"/>
        </settings>
        <validation>
            <dependency resource_type="SWComponent" resource_id="middleware.usb.host_controller_khci" level="error" when_expr="($instance.getPeripheral() == `USB0`) &amp;&amp; !featureDefined(`USBFSH_USB_RAM_BASE_ADDRESS`)" description="&quot;USB Host KHCI Controller Driver(FS)&quot; component is missing in the project.">
                <feature name="enabled" evaluation="equal">
                    <data expr="true"/>
                </feature>
            </dependency>
            <dependency resource_type="SWComponent" resource_id="middleware.usb.host_controller_ehci" level="error" when_expr="($instance.getPeripheral() == `USBHS`) ||($instance.getPeripheral() == `USB1`) || ($instance.getPeripheral() == `USB2`)" description="&quot;USB Host EHCI Controller Driver(HS)&quot; component is missing in the project.">
                <feature name="enabled" evaluation="equal">
                    <data expr="true"/>
                </feature>
            </dependency>
            <dependency resource_type="SWComponent" resource_id="middleware.usb.host_controller_ohci" level="error" when_expr="$instance.getPeripheral() == `USBFSH`" description="&quot;USB Host OHCI Controller Driver(FS)&quot; component is missing in the project.">
                <feature name="enabled" evaluation="equal">
                    <data expr="true"/>
                </feature>
            </dependency>
            <dependency resource_type="SWComponent" resource_id="middleware.usb.host_controller_ip3516hs" level="error" when_expr="$instance.getPeripheral() == `USBHSH`" description="&quot;USB Host IP3516HS Controller Driver(HS)&quot; component is missing in the project.">
                <feature name="enabled" evaluation="equal">
                    <data expr="true"/>
                </feature>
            </dependency>
            <dependency resource_type="SWComponent" resource_id="platform.drivers.sysmpu" level="error" when_expr="featureDefined(`SOC_SYSMPU_COUNT`) &amp;&amp; (getFeature(`SOC_SYSMPU_COUNT`) &gt; 0)" description="&quot;SYSMPU&quot; driver is missing in the project.">
                <feature name="enabled" evaluation="equal">
                    <data expr="true"/>
                </feature>
            </dependency>
            <dependency resource_type="SWComponent" resource_id="platform.drivers.power" level="Error" when_expr="featureDefined(`USBHSH_USB_RAM_BASE_ADDRESS`)" description="Component Power is missing in the project.">
                <feature name="enabled" evaluation="equal">
                    <data expr="true"/>
                </feature>
            </dependency>
            <dependency resource_type="SWComponent" resource_id="platform.drivers.common" level="Error" description="&quot;Common&quot; driver is missing in the project.">
                <feature name="enabled" evaluation="equal">
                    <data expr="true"/>
                </feature>
            </dependency>
            <dependency resource_type="ClockOutput" resource_id_expr="getPeripheralClockSignal($instance.getPeripheral(), `FunctionClock`)" level="Error" 
                description_expr="getPeripheralClockDescription($instance.getPeripheral(), `FunctionClock`) + ` (`+ getPeripheralClockSignal($instance.getPeripheral(), `FunctionClock`) +`) is inactive and USB module will not work.`" when_expr="hasPeripheralClockSignal($instance.getPeripheral(), `FunctionClock`)">
                <feature name="frequency" evaluation="greaterThan">
                    <data expr="0" unit="Hz" type="Frequency"/>
                </feature>
            </dependency>
            <dependency resource_type="ClockOutput" resource_id_expr="getPeripheralClockSignal($instance.getPeripheral(), `FunctionClock1`)" level="Error" 
                description_expr="getPeripheralClockDescription($instance.getPeripheral(), `FunctionClock1`) + ` (`+ getPeripheralClockSignal($instance.getPeripheral(), `FunctionClock1`) +`) is inactive and USB module will not work.`" when_expr="hasPeripheralClockSignal($instance.getPeripheral(), `FunctionClock1`)">
                <feature name="frequency" evaluation="greaterThan">
                    <data expr="0" unit="Hz" type="Frequency"/>
                </feature>
            </dependency>
            <dependency resource_type="ClockOutput" resource_id_expr="getPeripheralClockSignal($instance.getPeripheral(), `FunctionClock2`)" level="Error" 
                description_expr="getPeripheralClockDescription($instance.getPeripheral(), `FunctionClock2`) + ` (`+ getPeripheralClockSignal($instance.getPeripheral(), `FunctionClock2`) +`) is inactive and USB module will not work.`" when_expr="hasPeripheralClockSignal($instance.getPeripheral(), `FunctionClock2`)">
                <feature name="frequency" evaluation="greaterThan">
                    <data expr="0" unit="Hz" type="Frequency"/>
                </feature>
            </dependency>
            <dependency resource_type="PeripheralUnifiedSignal" level="Error" resource_id_expr="`USBFSH.usb_vbus`" description_expr="msg::message(`err_routed_signal`, `USB_VBUS`, `USBFSH`)" when_expr="queryFeature(`PeripheralUnifiedSignal`, `USBFSH.usb_vbus`, `Exists`) &amp;&amp; ($instance.getPeripheral() == `USBFSH`)">
                <feature name="routed" evaluation="equal">
                    <data expr="true"></data>
                </feature>
            </dependency>
            <dependency resource_type="PeripheralUnifiedSignal" level="Error" resource_id_expr="`USBFSH.usb_portpwrn`" description_expr="msg::message(`err_routed_signal`, `USB_PORTPWRN`, `USBFSH`)" when_expr="queryFeature(`PeripheralUnifiedSignal`, `USBFSH.usb_portpwrn`, `Exists`) &amp;&amp; ($instance.getPeripheral() == `USBFSH`)">
                <feature name="routed" evaluation="equal">
                    <data expr="true"></data>
                </feature>
            </dependency>
            <dependency resource_type="PeripheralUnifiedSignal" level="Error" resource_id_expr="`USBHSH.usb_vbus`" description_expr="msg::message(`err_routed_signal`, `USB_VBUS`, `USBHSH`)" when_expr="queryFeature(`PeripheralUnifiedSignal`, `USBHSH.usb_vbus`, `Exists`) &amp;&amp; ($instance.getPeripheral() == `USBHSH`)">
                <feature name="routed" evaluation="equal">
                    <data expr="true"></data>
                </feature>
            </dependency>
            <dependency resource_type="PeripheralUnifiedSignal" level="Error" resource_id_expr="`USBHSH.usb_portpwrn`" description_expr="msg::message(`err_routed_signal`, `USB_PORTPWRN`, `USBHSH`)" when_expr="queryFeature(`PeripheralUnifiedSignal`, `USBHSH.usb_portpwrn`, `Exists`) &amp;&amp; ($instance.getPeripheral() == `USBHSH`)">
                <feature name="routed" evaluation="equal">
                    <data expr="true"></data>
                </feature>
            </dependency>
            <constraint cond_expr="$root.reduce(0, (acc, group) -> acc + group.countOccurrences(component -> ((component.getParent().getId() == `usb`) &amp;&amp; (component.getMode() == `host`) &amp;&amp; component.isEnabled()))) &lt; 2" level="error" description="Only one host instance of the USB component is allowed in the configuration"/>
            <constraint cond_expr="!(($this.getMode() == `host`) &amp;&amp; ($instance.getPeripheral() == `USB0`))" when_expr="featureDefined(`USBFSH_USB_RAM_BASE_ADDRESS`)" level="error" description="Selected mode: Host cannot use peripheral: USB0."/>
            <constraint cond_expr="!((getFeature(`USB_KHCI_HOST_ENABLED`) == 0) &amp;&amp; ($this.getMode() == `host`) &amp;&amp; ($instance.getPeripheral() == `USB0`))" when_expr="featureDefined(`USB_KHCI_HOST_ENABLED`)" level="error" description="Selected mode: Host cannot use peripheral: USB0."/>
            <constraint when_expr="$configSet.sharedPeripherals.getValue().size() &gt; 0" cond_expr="$configSet.sharedPeripherals.getValue().noneMatch(peripheral -> $components.system.#global.all_enabled_instances.getValue().anyMatch(i -> (i.getPeripheral() == peripheral)))" level="error"
                description_expr="`The selected ` + $instance.getPeripheral() + ` peripheral of this component has shared resources with ` + $configSet.sharedPeripherals.getValue().reduce(``, (last, i) -> (last + ((last == ``) ? i : `, ` + i))) + ` peripheral(s). Select different peripheral.`"/>
        </validation>
        <quick_selections>
            <quick_selection id="QS_HOST_DEFAULT" label="None">
                <set id="max_power">500</set>
                <set id="hub_support">true</set>
            </quick_selection>
            <quick_selection id="QS_HOST_CDC_VCOM" label="CDC VCOM (bare metal)">
                <set id="max_power">500</set>
                <set id="hub_support">true</set>
                <set id="interfaces.0.interface_class">kClassCic</set>
                <set id="interfaces.0.setting_cic">QS_INTERFACE_CIC_VCOM</set>
                <set id="interfaces.1.interface_class">kClassDic</set>
                <set id="interfaces.1.setting_dic">QS_INTERFACE_DIC_VCOM</set>
            </quick_selection>
            <quick_selection id="QS_HOST_HID_KEYBOARD" label="HID Keyboard (bare metal)">
                <set id="max_power">500</set>
                <set id="hub_support">true</set>
                <set id="interfaces.0.interface_class">kClassHid</set>
                <set id="interfaces.0.setting_hid">QS_INTERFACE_HID_KEYBOARD</set>
            </quick_selection>
            <quick_selection id="QS_HOST_HID_MOUSE" label="HID Mouse (bare metal)">
                <set id="max_power">500</set>
                <set id="hub_support">true</set>
                <set id="interfaces.0.interface_class">kClassHid</set>
                <set id="interfaces.0.setting_hid">QS_INTERFACE_HID_MOUSE</set>
            </quick_selection>
            <quick_selection id="QS_HOST_HID_GENERIC" label="HID Generic (bare metal)">
                <set id="max_power">500</set>
                <set id="hub_support">true</set>
                <set id="interfaces.0.interface_class">kClassHid</set>
                <set id="interfaces.0.setting_hid">QS_INTERFACE_HID_GENERIC</set>
            </quick_selection>
            <quick_selection id="QS_HOST_AUDIO_SPEAKR" label="Audio - speaker (bare metal)">
                <set id="max_power">500</set>
                <set id="hub_support">true</set>
                <set id="interfaces.0.interface_class">kClassAudioHost</set>
                <set id="interfaces.0.setting_audiohost">QS_INTERFACE_AUDIO_CLASS_SPEAKER</set>
            </quick_selection>
            <quick_selection id="QS_DEVICE_PHDC_MANAGER" label="PHDC Manager (bare metal)">
                <set id="max_power">500</set>
                <set id="hub_support">true</set>
                <set id="interfaces.0.interface_class">kClassPhdc</set>
                <set id="interfaces.0.setting_phdc">QS_INTERFACE_PHDC_MANAGER</set>
            </quick_selection>
            <quick_selection id="QS_DEVICE_PRINTER_PLAIN_TEXT" label="Printer plain text (bare metal)">
                <set id="max_power">500</set>
                <set id="hub_support">true</set>
                <set id="interfaces.0.interface_class">kClassPrinter</set>
                <set id="interfaces.0.setting_printer">QS_INTERFACE_PRINTER_PLAIN_TEXT</set>
            </quick_selection>            
            <default>QS_HOST_DEFAULT</default>
        </quick_selections>
    </config_set>
    <config_set id="deviceSetting" label="Device role">
        <description>Device mode settings</description>
        <generated_types/>
        <user_types>
            <!-- Features type mapping array for HID reprot descritor: 
                label: uint - unsigned integer, int - signed integer, N/A - no value appliacable
                value: maximum value (in usingned hexadecimal format)
            -->
            <enum id="report_descriptor_features_t" from="_report_descriptor_item">
                <item id="kCollection" label="uint" value="0x7F"/>
                <item id="kDelimiter" label="uint" value="0x1"/> <!-- only two values: 1 = open set, 0 = close set -->
                <item id="kDesignator_Index" label="int" value="0xFFFFFFFF"/>
                <item id="kDesignator_Maximum" label="int" value="0xFFFFFFFF"/>
                <item id="kDesignator_Minimum" label="int"  value="0xFFFFFFFF"/>
                <item id="kEnd_Collection" label="N/A" value="0"/>
                <item id="kFeature" label="uint"  value="0x1FF"/>
                <item id="kInput" label="uint"  value="0x1FF"/>
                <item id="kLogical_Maximum" label="int" value="0xFFFFFFFF"/>
                <item id="kLogical_Minimum" label="int"  value="0xFFFFFFFF"/>
                <item id="kOutput" label="uint"  value="0x1FF"/>
                <item id="kPhysical_Maximum" label="int" value="0xFFFFFFFF"/>
                <item id="kPhysical_Minimum" label="int"  value="0xFFFFFFFF"/>
                <item id="kPush" label="N/A"  value="0"/>
                <item id="kPop" label="N/A"  value="0"/>
                <item id="kReport_Count" label="uint" value="0xFFFFFFFF"/>
                <item id="kReport_Id" label="uint" value="0xFFFFFFFF"/>
                <item id="kReport_Size" label="uint"  value="0xFFFFFFFF"/>
                <item id="kString_Index" label="int" value="0xFFFFFFFF"/>
                <item id="kString_Maximum" label="int"  value="0xFFFFFFFF"/>
                <item id="kString_Minimum" label="int"  value="0xFFFFFFFF"/>
                <item id="kUnit" label="uint"  value="0xFFFFFFFF"/>
                <item id="kUnit_Exponent" label="uint" value="0xF"/>
                <item id="kUsage" label="uint"  value="0xFFFF"/>
                <item id="kUsage_Maximum" label="int" value="0xFFFFFFFF"/>
                <item id="kUsage_Minimum" label="int" value="0xFFFFFFFF"/>
                <item id="kUsage_Page" label="uint" value="0xFFFFFFFF"/>
            </enum>
        </user_types>
        <settings>
            <variable id="hasHostPhdc" value="hasModePhdc(`host`)"/>
            <variable id="ieee11073TypesRequired" value="$parent.interfaces.isIeee11073TypesRequired()"/>
            <variable id="isIeee11073TypesRequiredInHost" value="isIeee11073TypesRequiredInMode(`host`)"/>
            <variable id="high_speed_supported" value="$instance.getPeripheral() != `USB0`"></variable>
            <reference id="control_max_packet_size_fs" type="control_max_packet_size_fs_t" config_set_id="commonSettings" options="remove_from_struct_init" available="false"/><!-- used for max_packet_size_fs dynamic enum only -->
            <reference id="bulk_max_packet_size_fs" type="bulk_max_packet_size_fs_t" config_set_id="commonSettings" options="remove_from_struct_init" available="false"/><!-- used for max_packet_size_fs dynamic enum only -->
            <reference id="interrupt_max_packet_size_fs" type="interrupt_max_packet_size_fs_t" config_set_id="commonSettings" options="remove_from_struct_init" available="false"/><!-- used for max_packet_size_fs dynamic enum only -->
            <reference id="isochronous_max_packet_size_fs" type="isochronous_max_packet_size_fs_t" config_set_id="commonSettings" options="remove_from_struct_init" available="false"/><!-- used for max_packet_size_fs dynamic enum only -->
            <reference id="control_max_packet_size_hs" type="control_max_packet_size_hs_t" config_set_id="commonSettings" options="remove_from_struct_init" available="false"/><!-- used for max_packet_size_hs dynamic enum only -->
            <reference id="bulk_max_packet_size_hs" type="bulk_max_packet_size_hs_t" config_set_id="commonSettings" options="remove_from_struct_init" available="false"/><!-- used for max_packet_size_hs dynamic enum only -->
            <reference id="interrupt_max_packet_size_hs" type="interrupt_max_packet_size_hs_t" config_set_id="commonSettings" options="remove_from_struct_init" available="false"/><!-- used for max_packet_size_fs dynamic enum only -->
            <reference id="isochronous_max_packet_size_hs" type="isochronous_max_packet_size_hs_t" config_set_id="commonSettings" options="remove_from_struct_init" available="false"/><!-- used for max_packet_size_fs dynamic enum only -->
            <variable id="irq_handler" value="getResource(`interrupts`, $instance.getCoreId())
                .filter(
                    enumItem -> (
                        enumItem.getSetting(`devices`).searchInArray(
                            item -> (
                                (item.getSetting(`id`).getValue() == $instance.getPeripheral()) &amp;&amp; (item.getSetting(`function`).getValue() == `usb`)
                            )
                        ) >= 0
                    )
                ).getFirst().getSetting(`handler_id`).getValue()"/>
            <integer id="vendor_id" type="uint16_t" label="Vendor ID" enable="" min_expr="0x0000" max_expr="0xFFFF">
                <description>Vendor ID is assigned by the USB-IF.</description>
            </integer>
            <integer id="product_id" type="uint16_t" label="Product ID" enable="" min_expr="0x0000" max_expr="0xFFFF">
                <description>Product ID is assigned by the manufacturer.</description>
            </integer>
            <string id="manufacturer_string" label="Manufacturer">
                <description>Maximum length is 126 characters</description>
                <validation>
                    <constraint cond_expr="$this.getValue().getLength() != 0" level="error" description="Manufacturer string must not be empty"/>
                    <constraint cond_expr="$this.getValue().getLength() &lt; 127" level="error" description="Manufacturer string is too long (maximum length is 126 characters)"/>
                </validation>
            </string>
            <string id="product_string" label="Product">
                <description>Maximum length is 126 characters</description>
                <validation>
                    <constraint cond_expr="$this.getValue().getLength() != 0" level="error" description="Product string must not be empty"/>
                    <constraint cond_expr="$this.getValue().getLength() &lt; 127" level="error" description="Product string is too long (maximum length is 126 characters)"/>
                </validation>
            </string>
            <bool id="self_powered" label="Self-powered"/>
            <bool id="suspend_resume" label="Enable suspend and resume feature" available="featureDefined(`SMC_HAS_HIGH_SPEED_RUN_MODE`) &amp;&amp; getFeature(`SMC_HAS_HIGH_SPEED_RUN_MODE`) == 0">
                <validation>
                    <dependency when_expr="(getFamily() == `Kinetis`) &amp;&amp; $this.getValue()" resource_type="SWComponent" resource_id="platform.drivers.smc" level="error" description="&quot;SMC&quot; component is missing in the project.">
                        <feature name="enabled" evaluation="equal">
                            <data expr="true"/>
                        </feature>
                    </dependency>                    
                </validation>
            </bool>
            <bool id="remote_wakeup" label="Enable remote wakeup feature" available="$parent.suspend_resume.getValue() == `true`"/>
            <info id="remote_wakeup_call" label="Remote wakeup call" value="`USB_RemoteWakeupTrigger();`" options="UI_INFO_COPY_BUTTON" available="$parent.remote_wakeup.isAvailable()" enable="$parent.remote_wakeup.getValue() == true">
                <description>Generated function call to put inside the interrupt service routine that wakes up device from low-power mode.</description>
            </info>
            <integer id="max_power" label="Max power [mA]" type="uint16_t">
                <description>Requested power from Host.</description>
                <validation>
                    <constraint cond_expr="$this.value() &lt;= 500" level="error" description="USB 2.0 compliant device can request a maximum of 500 mA."/>
                    <constraint cond_expr="($this.value() &gt; 0) || $parent.self_powered.value()" level="error" description="Max power can be set to zero only when the device is Self-powered."/>
                    <constraint cond_expr="($this.value() &amp; 1) == 0" level="error" description="Power must be specified in increments of 2 mA."/>
                </validation>
            </integer>
            <info id="device_task_call" label="Device task call" value="`USB_DeviceTasks();`" options="UI_INFO_COPY_BUTTON">
                <description>Generated polling routine to put inside the while loop of the main() function.</description>
            </info>
            <variable id="max_endpoint_count" value="endpointCount()"/>
            <variable id="endpoint_count_in" value="$parent.interfaces.getSize() == 0 ? 0 : getConfiguredInEndpointsCount()" available="isEndpointCountKnown()"/>
            <variable id="endpoint_count_out" value="$parent.interfaces.getSize() == 0 ? 0 : getConfiguredOutEndpointsCount()" available="isEndpointCountKnown()"/>
            <variable id="highest_endpoint_number" value="system::max($parent.endpoint_count_in.getValue(), $parent.endpoint_count_out.getValue())" available="isEndpointCountKnown()"/>
            <info id="remaining_endpoints" label="Remaining endpoints" 
                value=" (($configSet.max_endpoint_count.getValue() &gt;= $configSet.endpoint_count_in.getValue()) ? ($configSet.max_endpoint_count.getValue() - $configSet.endpoint_count_in.getValue()) : 0) + ` In, ` + (($configSet.max_endpoint_count.getValue() &gt;= $configSet.endpoint_count_out.getValue()) ? ($configSet.max_endpoint_count.getValue() - $configSet.endpoint_count_out.getValue()) : 0) + ` Out`"
                available="isEndpointCountKnown()">
                <description>Number of remaining input and output endpoints that are supported by this USB peripheral and which can be configured and used in interfaces.</description>
            </info>
            <reference id="interfaces" type="interfaces_t" config_set_id="commonSettings" options="usb_device">
                <migration from="usb_210" from_setting="deviceSetting.interfaces">
                    <migrate to_setting="$this" conversion_function="(to, from) -> from.getSize()"/>
                    <migrate to_setting="$this.getSetting(`[$this]`)" conversion_function="(to, from) -> from.getSetting(`[$this]`)"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_cic.endpoints_settings`)" conversion_function="(to, from) -> 1"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_cic.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> 0"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_cic.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> from.getSetting(`[$this].setting_cic.endpoints`)"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_dic.endpoints_settings`)" conversion_function="(to, from) -> 1"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_dic.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> 0"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_dic.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> from.getSetting(`[$this].setting_dic.endpoints`)"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_msc.endpoints_settings`)" conversion_function="(to, from) -> 1"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_msc.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> 0"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_msc.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> from.getSetting(`[$this].setting_msc.endpoints`)"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_hid.endpoints_settings`)" conversion_function="(to, from) -> 1"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_hid.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> 0"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_hid.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> from.getSetting(`[$this].setting_hid.endpoints`)"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_phdc.endpoints_settings`)" conversion_function="(to, from) -> 1"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_phdc.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> 0"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_phdc.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> from.getSetting(`[$this].setting_phdc.endpoints`)"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_printer.endpoints_settings`)" conversion_function="(to, from) -> 1"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_printer.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> 0"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_printer.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> from.getSetting(`[$this].setting_printer.endpoints`)"/>
                </migration>
                <migration from="usb_220" from_setting="deviceSetting.interfaces">
                    <migrate to_setting="$this" conversion_function="(to, from) -> from.getSize()"/>
                    <migrate to_setting="$this.getSetting(`[$this]`)" conversion_function="(to, from) -> from.getSetting(`[$this]`)"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_cic.endpoints_settings`)" conversion_function="(to, from) -> 1"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_cic.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> 0"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_cic.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> from.getSetting(`[$this].setting_cic.endpoints`)"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_dic.endpoints_settings`)" conversion_function="(to, from) -> 1"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_dic.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> 0"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_dic.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> from.getSetting(`[$this].setting_dic.endpoints`)"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_msc.endpoints_settings`)" conversion_function="(to, from) -> 1"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_msc.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> 0"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_msc.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> from.getSetting(`[$this].setting_msc.endpoints`)"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_hid.endpoints_settings`)" conversion_function="(to, from) -> 1"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_hid.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> 0"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_hid.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> from.getSetting(`[$this].setting_hid.endpoints`)"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_phdc.endpoints_settings`)" conversion_function="(to, from) -> 1"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_phdc.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> 0"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_phdc.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> from.getSetting(`[$this].setting_phdc.endpoints`)"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_printer.endpoints_settings`)" conversion_function="(to, from) -> 1"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_printer.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> 0"/>
                    <migrate to_setting="$this.getSetting(`[$this].setting_printer.endpoints_settings.0.endpoints`)" conversion_function="(to, from) -> from.getSetting(`[$this].setting_printer.endpoints`)"/>
                </migration>
                <validation>
                    <constraint when_expr="isEndpointCountKnown()" cond_expr="$parent.endpoint_count_in.getValue() &lt;= $configSet.max_endpoint_count.getValue()" level="error" description_expr="`Maximum number of configurable input endpoints (` + $configSet.max_endpoint_count.getValue() + `) is exceeded for the ` + $instance.getPeripheral() + ` peripheral`"/>
                    <constraint when_expr="isEndpointCountKnown()" cond_expr="$parent.endpoint_count_out.getValue() &lt;= $configSet.max_endpoint_count.getValue()" level="error" description_expr="`Maximum number of configurable output endpoints (` + $configSet.max_endpoint_count.getValue() + `) is exceeded for the ` + $instance.getPeripheral() + ` peripheral`"/>
                </validation>
            </reference>
            <variable id="sharedPeripherals_supported" value="toArray(`NVIC`)"/>
            <variable id="sharedPeripherals" value="getResource(`interrupts`, $instance.getCoreId()).filter(irqItem -> (irqItem.getSetting(`devices`).size() &gt; 1) &amp;&amp; (irqItem.getSetting(`devices`).anyMatch(item -> (item.getSetting(`id`).getValue() == $instance.getPeripheral())))).map(item -> ((item.getSetting(`devices`).size() > 1) ? (item.getSetting(`devices`).findFirst(dev -> (dev.getSetting(`id`).getValue() != $instance.getPeripheral())).getSetting(`id`).getValue()) : `N/A`)).removeDuplicates(x -> x).filter(dev -> $parent.sharedPeripherals_supported.getValue().noneMatch(i -> (i == dev)))"/>
        </settings>
        <fragment_defs/>
        <code/>
        <validation>
            <dependency resource_type="SWComponent" resource_id="middleware.usb.device_controller_khci" level="error" when_expr="($instance.getPeripheral() == `USB0`) &amp;&amp; !featureDefined(`USBFSH_USB_RAM_BASE_ADDRESS`)" description="&quot;USB Device KHCI Controller Driver(FS)&quot; component is missing in the project.">
                <feature name="enabled" evaluation="equal">
                    <data expr="true"/>
                </feature>
            </dependency>
            <dependency resource_type="SWComponent" resource_id="middleware.usb.device_controller_ehci" level="error" when_expr="($instance.getPeripheral() == `USBHS`) ||($instance.getPeripheral() == `USB1`) || ($instance.getPeripheral() == `USB2`)" description="&quot;USB Device EHCI Controller Driver(HS)&quot; component is missing in the project.">
                <feature name="enabled" evaluation="equal">
                    <data expr="true"/>
                </feature>
            </dependency>
            <dependency resource_type="SWComponent" resource_id="middleware.usb.device_controller_ip3511fs" level="error" when_expr="$instance.getPeripheral() == `USB0` &amp;&amp; featureDefined(`USBFSH_USB_RAM_BASE_ADDRESS`)" description="&quot;USB Device IP3511FS Controller Driver(FS)&quot; component is missing in the project.">
                <feature name="enabled" evaluation="equal">
                    <data expr="true"/>
                </feature>
            </dependency>
            <dependency resource_type="SWComponent" resource_id="middleware.usb.device_controller_ip3511hs" level="error" when_expr="$instance.getPeripheral() == `USBHSD`" description="&quot;USB Device IP3511HS Controller Driver(HS)&quot; component is missing in the project.">
                <feature name="enabled" evaluation="equal">
                    <data expr="true"/>
                </feature>
            </dependency>
            <dependency resource_type="SWComponent" resource_id="platform.drivers.sysmpu" level="error" when_expr="featureDefined(`SOC_SYSMPU_COUNT`) &amp;&amp; (getFeature(`SOC_SYSMPU_COUNT`) &gt; 0)" description="&quot;SYSMPU&quot; driver is missing in the project.">
                <feature name="enabled" evaluation="equal">
                    <data expr="true"/>
                </feature>
            </dependency>
            <!-- RT6xx has LPC IP but does not suffer from chirping issue -->
            <dependency resource_type="SWComponent" resource_id="platform.drivers.mrt" level="Error" when_expr="!(featureDefined(`USBPHY_COUNT`) &amp;&amp; (getFeature(`USBPHY_COUNT`) > 0)) &amp;&amp; ($instance.getPeripheral() == `USBHSD`) &amp;&amp; (queryFeatureAdvanced(`Configuration`, `Processor`, `Series`, false) == `[LPC LPC54000]`)" description="Component MRT is missing in the project.">
                <feature name="enabled" evaluation="equal">
                    <data expr="true"/>
                </feature>
            </dependency>
            <dependency resource_type="SWComponent" resource_id="platform.drivers.power" level="Error" when_expr="featureDefined(`USBHSD_EP_NUM`)" description="Component Power is missing in the project.">
                <feature name="enabled" evaluation="equal">
                    <data expr="true"/>
                </feature>
            </dependency>
            <dependency resource_type="SWComponent" resource_id="platform.drivers.common" level="Error" description="&quot;Common&quot; driver is missing in the project.">
                <feature name="enabled" evaluation="equal">
                    <data expr="true"/>
                </feature>
            </dependency>
            <dependency resource_type="ClockOutput" resource_id_expr="getPeripheralClockSignal($instance.getPeripheral(), `FunctionClock`)" level="Error" 
                description_expr="getPeripheralClockDescription($instance.getPeripheral(), `FunctionClock`) + ` (`+ getPeripheralClockSignal($instance.getPeripheral(), `FunctionClock`) +`) is inactive and USB module will not work.`" when_expr="hasPeripheralClockSignal($instance.getPeripheral(), `FunctionClock`)">
                <feature name="frequency" evaluation="greaterThan">
                    <data expr="0" unit="Hz" type="Frequency"/>
                </feature>
            </dependency>
            <dependency resource_type="ClockOutput" resource_id_expr="getPeripheralClockSignal($instance.getPeripheral(), `FunctionClock1`)" level="Error" 
                description_expr="getPeripheralClockDescription($instance.getPeripheral(), `FunctionClock1`) + ` (`+ getPeripheralClockSignal($instance.getPeripheral(), `FunctionClock1`) +`) is inactive and USB module will not work.`" when_expr="hasPeripheralClockSignal($instance.getPeripheral(), `FunctionClock1`)">
                <feature name="frequency" evaluation="greaterThan">
                    <data expr="0" unit="Hz" type="Frequency"/>
                </feature>
            </dependency>
            <dependency resource_type="ClockOutput" resource_id_expr="getPeripheralClockSignal($instance.getPeripheral(), `FunctionClock2`)" level="Error" 
                description_expr="getPeripheralClockDescription($instance.getPeripheral(), `FunctionClock2`) + ` (`+ getPeripheralClockSignal($instance.getPeripheral(), `FunctionClock2`) +`) is inactive and USB module will not work.`" when_expr="hasPeripheralClockSignal($instance.getPeripheral(), `FunctionClock2`)">
                <feature name="frequency" evaluation="greaterThan">
                    <data expr="0" unit="Hz" type="Frequency"/>
                </feature>
            </dependency>
            <dependency resource_type="PeripheralUnifiedSignal" level="Error" resource_id_expr="`USBFSH.usb_vbus`" description_expr="msg::message(`err_routed_signal`, `USB_VBUS`, `USBFSH`)" when_expr="queryFeature(`PeripheralUnifiedSignal`, `USBFSH.usb_vbus`, `Exists`) &amp;&amp; ($instance.getPeripheral() == `USB0`)">
                <feature name="routed" evaluation="equal">
                    <data expr="true"></data>
                </feature>
            </dependency>
            <dependency resource_type="PeripheralUnifiedSignal" level="Error" resource_id_expr="`USBHSH.usb_vbus`" description_expr="msg::message(`err_routed_signal`, `USB_VBUS`, `USBHSH`)" when_expr="queryFeature(`PeripheralUnifiedSignal`, `USBHSH.usb_vbus`, `Exists`) &amp;&amp; ($instance.getPeripheral() == `USBHSD`)">
                <feature name="routed" evaluation="equal">
                    <data expr="true"></data>
                </feature>
            </dependency>
            <constraint cond_expr="$root.reduce(0, (acc, group) -> acc + group.countOccurrences(component -> ((component.getParent().getId() == `usb`) &amp;&amp; (component.getMode() == `device`) &amp;&amp; component.isEnabled()))) &lt; 2" level="error" description="Only one device instance of the USB component is allowed in the configuration"/>
            <constraint when_expr="$configSet.sharedPeripherals.getValue().size() &gt; 0" cond_expr="$configSet.sharedPeripherals.getValue().noneMatch(peripheral -> $components.system.#global.all_enabled_instances.getValue().anyMatch(i -> (i.getPeripheral() == peripheral)))" level="error"
                description_expr="`The selected ` + $instance.getPeripheral() + ` peripheral of this component has shared resources with ` + $configSet.sharedPeripherals.getValue().reduce(``, (last, i) -> (last + ((last == ``) ? i : `, ` + i))) + ` peripheral(s). Select different peripheral.`"/>
        </validation>
        <quick_selections>
            <quick_selection id="QS_DEVICE_DEFAULT" label="None">
                <set id="vendor_id">0x1FC9</set>
                <set id="product_id">0x0090</set>
                <set id="manufacturer_string">NXP</set>
                <set id="product_string">Product</set>
                <set id="self_powered">false</set>
                <set id="max_power">100</set>
            </quick_selection>
            <quick_selection id="QS_DEVICE_CDC_VCOM" label="CDC VCOM (bare metal)">
                <set id="vendor_id">0x1FC9</set>
                <set id="product_id">0x0094</set>
                <set id="manufacturer_string">NXP</set>
                <set id="product_string">VCOM</set>
                <set id="self_powered">true</set>
                <set id="max_power">100</set>
                <set id="interfaces.0.interface_class">kClassCic</set>
                <set id="interfaces.0.setting_cic">QS_INTERFACE_CIC_VCOM</set>
                <set id="interfaces.1.interface_class">kClassDic</set>
                <set id="interfaces.1.setting_dic">QS_INTERFACE_DIC_VCOM</set>
            </quick_selection>
            <quick_selection id="QS_DEVICE_DFU_APP" label="Device Firmware Upgrade (app-idle, bare metal)">
                <set id="vendor_id">0x1FC9</set>
                <set id="product_id">0x00AC</set>
                <set id="manufacturer_string">NXP</set>
                <set id="product_string">DFU</set>
                <set id="self_powered">true</set>
                <set id="max_power">100</set>
                <set id="interfaces.0.interface_class">kClassDfu</set>
                <set id="interfaces.0.setting_dfu">QS_INTERFACE_DFU_APP</set>
            </quick_selection>
            <quick_selection id="QS_DEVICE_DFU" label="Device Firmware Upgrade (dfu-idle, bare metal)">
                <set id="vendor_id">0x1FC9</set>
                <set id="product_id">0x00A1</set>
                <set id="manufacturer_string">NXP</set>
                <set id="product_string">DFU</set>
                <set id="self_powered">true</set>
                <set id="max_power">100</set>
                <set id="interfaces.0.interface_class">kClassDfu</set>
                <set id="interfaces.0.setting_dfu">QS_INTERFACE_DFU_DFU</set>
            </quick_selection>
            <quick_selection id="QS_DEVICE_HID_GENERIC" label="HID Generic (bare metal)">
                <set id="vendor_id">0x1FC9</set>
                <set id="product_id">0x00A2</set>
                <set id="manufacturer_string">NXP</set>
                <set id="product_string">Generic</set>
                <set id="self_powered">false</set>
                <set id="max_power">100</set>
                <set id="interfaces.0.interface_class">kClassHid</set>
                <set id="interfaces.0.setting_hid">QS_INTERFACE_HID_GENERIC</set>
            </quick_selection>
            <quick_selection id="QS_DEVICE_HID_KEYBOARD" label="HID Keyboard (bare metal)">
                <set id="vendor_id">0x1FC9</set>
                <set id="product_id">0x00A0</set>
                <set id="manufacturer_string">NXP</set>
                <set id="product_string">Keyboard</set>
                <set id="self_powered">false</set>
                <set id="max_power">100</set>
                <set id="interfaces.0.interface_class">kClassHid</set>
                <set id="interfaces.0.setting_hid">QS_INTERFACE_HID_KEYBOARD</set>
            </quick_selection>
            <quick_selection id="QS_DEVICE_HID_MOUSE" label="HID Mouse (bare metal)">
                <set id="vendor_id">0x1FC9</set>
                <set id="product_id">0x0091</set>
                <set id="manufacturer_string">NXP</set>
                <set id="product_string">Mouse</set>
                <set id="self_powered">false</set>
                <set id="max_power">100</set>
                <set id="interfaces.0.interface_class">kClassHid</set>
                <set id="interfaces.0.setting_hid">QS_INTERFACE_HID_MOUSE</set>
            </quick_selection>
            <quick_selection id="QS_DEVICE_MSC_RAM_DISK" label="MSC RAM disk (bare metal)">
                <set id="vendor_id">0x1FC9</set>
                <set id="product_id">0x0092</set>
                <set id="manufacturer_string">NXP</set>
                <set id="product_string">RAM disk</set>
                <set id="self_powered">true</set>
                <set id="max_power">50</set>
                <set id="interfaces.0.interface_class">kClassMsc</set>
                <set id="interfaces.0.setting_msc">QS_INTERFACE_MSC_RAM_DISK</set>
            </quick_selection>
            <quick_selection id="QS_DEVICE_PHDC_WEIGHT_SCALE" label="PHDC Weight scale (bare metal)">
                <set id="vendor_id">0x1FC9</set>
                <set id="product_id">0x0096</set>
                <set id="manufacturer_string">NXP</set>
                <set id="product_string">Weight scale</set>
                <set id="self_powered">true</set>
                <set id="max_power">50</set>
                <set id="interfaces.0.interface_class">kClassPhdc</set>
                <set id="interfaces.0.setting_phdc">QS_INTERFACE_PHDC_WEIGHT_SCALE</set>
            </quick_selection>
            <quick_selection id="QS_DEVICE_PRINTER_PLAIN_TEXT" label="Printer plain text (bare metal)">
                <set id="vendor_id">0x1FC9</set>
                <set id="product_id">0x009B</set>
                <set id="manufacturer_string">NXP</set>
                <set id="product_string">Printer</set>
                <set id="self_powered">true</set>
                <set id="max_power">50</set>
                <set id="interfaces.0.interface_class">kClassPrinter</set>
                <set id="interfaces.0.setting_printer">QS_INTERFACE_PRINTER_PLAIN_TEXT</set>
            </quick_selection>
            <quick_selection id="QS_DEVICE_AUDIO_SPEAKER" label="Audio 1.0 - speaker (bare metal)">
                <set id="vendor_id">0x1FC9</set>
                <set id="product_id">0x0098</set>
                <set id="manufacturer_string">NXP</set>
                <set id="product_string">Audio speaker</set>
                <set id="self_powered">true</set>
                <set id="max_power">100</set>
                <set id="interfaces.0.interface_class">kClassAudio_1_0</set>
                <set id="interfaces.0.setting_audio_1_0">QS_INTERFACE_AUDIO_CONTROL_SPEAKER</set>
                <set id="interfaces.1.interface_class">kClassAudio_1_0</set>
                <set id="interfaces.1.setting_audio_1_0">QS_INTERFACE_AUDIO_STREAM_SPEAKER</set>
            </quick_selection>
            <quick_selection id="QS_DEVICE_AUDIO_2_0_SPEAKER" label="Audio 2.0 - speaker (bare metal)">
                <set id="vendor_id">0x1FC9</set>
                <set id="product_id">0x0098</set>
                <set id="manufacturer_string">NXP</set>
                <set id="product_string">Audio speaker</set>
                <set id="self_powered">true</set>
                <set id="max_power">100</set>
                <set id="interfaces.0.interface_class">kClassAudio_2_0</set>
                <set id="interfaces.0.setting_audio_2_0">QS_INTERFACE_AUDIO_CONTROL_SPEAKER</set>
                <set id="interfaces.1.interface_class">kClassAudio_2_0</set>
                <set id="interfaces.1.setting_audio_2_0">QS_INTERFACE_AUDIO_STREAM_SPEAKER</set>
            </quick_selection>
            <quick_selection id="QS_DEVICE_AUDIO_2_0_GENERATOR" label="Audio 2.0 - generator (bare metal)">
                <set id="vendor_id">0x1FC9</set>
                <set id="product_id">0x0098</set>
                <set id="manufacturer_string">NXP</set>
                <set id="product_string">Audio generator</set>
                <set id="self_powered">true</set>
                <set id="max_power">100</set>
                <set id="interfaces.0.interface_class">kClassAudio_2_0</set>
                <set id="interfaces.0.setting_audio_2_0">QS_INTERFACE_AUDIO_CONTROL_GENERATOR</set>
                <set id="interfaces.1.interface_class">kClassAudio_2_0</set>
                <set id="interfaces.1.setting_audio_2_0">QS_INTERFACE_AUDIO_STREAM_GENERATOR</set>
            </quick_selection>
            <quick_selection id="QS_DEVICE_AUDIO_2_0_UNIFIED" label="Audio 2.0 - unified (bare metal)">
                <set id="vendor_id">0x1FC9</set>
                <set id="product_id">0x0098</set>
                <set id="manufacturer_string">NXP</set>
                <set id="product_string">Audio unified</set>
                <set id="self_powered">true</set>
                <set id="max_power">100</set>
                <set id="interfaces.0.interface_class">kClassAudio_2_0</set>
                <set id="interfaces.0.setting_audio_2_0">QS_INTERFACE_AUDIO_CONTROL_UNIFIED</set>
                <set id="interfaces.1.interface_class">kClassAudio_2_0</set>
                <set id="interfaces.1.setting_audio_2_0">QS_INTERFACE_AUDIO_STREAM_UNIFIED_0</set>
                <set id="interfaces.2.interface_class">kClassAudio_2_0</set>
                <set id="interfaces.2.setting_audio_2_0">QS_INTERFACE_AUDIO_STREAM_UNIFIED_1</set>
            </quick_selection>
            <quick_selection id="QS_DEVICE_AUDIO_2_0_UNIFIED_WIN10" label="Audio 2.0 - unified for Win 10/USB FS (bare metal)">
                <description>Audio 2.0 class - unified audio device for Windows 10 and USB FS (Full Speed) peripheral (used as a workaround of the Windows 10 issue - isochronous feedback packet size must be 4 bytes).</description>
                <set id="vendor_id">0x1FC9</set>
                <set id="product_id">0x0098</set>
                <set id="manufacturer_string">NXP</set>
                <set id="product_string">Audio unified</set>
                <set id="self_powered">true</set>
                <set id="max_power">100</set>
                <set id="interfaces.0.interface_class">kClassAudio_2_0</set>
                <set id="interfaces.0.setting_audio_2_0">QS_INTERFACE_AUDIO_CONTROL_UNIFIED</set>
                <set id="interfaces.1.interface_class">kClassAudio_2_0</set>
                <set id="interfaces.1.setting_audio_2_0">QS_INTERFACE_AUDIO_STREAM_UNIFIED_0</set>
                <set id="interfaces.2.interface_class">kClassAudio_2_0</set>
                <set id="interfaces.2.setting_audio_2_0">QS_INTERFACE_AUDIO_STREAM_UNIFIED_1_WIN10</set>
            </quick_selection>
            <default>QS_DEVICE_DEFAULT</default>
        </quick_selections>
    </config_set>
</component:config_component>
