<?xml version="1.0" encoding= "UTF-8" ?>
<component:config_component id="cmp" label="CMP" global_only="false" xsi:schemaLocation="http://swtools.freescale.net/XSD/component/1.0 http://swtools.freescale.net/XSD/component/1.0/component-7.0.xsd" xmlns:component="http://swtools.freescale.net/XSD/component/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" category="Peripheral driver">
   <sw_comp_ref name="platform.drivers.cmp" version="2.0.0" match_type="greaterOrEqual" until_version="2.1.0"/>
   <description>Comparator (CMP)</description>
   <mode id="polling" label="Polling" available="true">
      <description>Modes of the CMP peripheries are implemented as quick selection options.</description>
      <config_set_refs>
         <config_set_ref>fsl_cmp</config_set_ref>
         <config_set_ref>fsl_dac</config_set_ref>
         <config_set_ref>fsl_filter</config_set_ref>
      </config_set_refs>
      <master_peripheral>
         <peripheral_type>CMP</peripheral_type>
      </master_peripheral>
   </mode>
   <mode id="interrupt" label="Interrupts/DMA" available="true">
      <description>Modes of the CMP peripheries are implemented as quick selection options.</description>
      <config_set_refs>
         <config_set_ref>fsl_cmp</config_set_ref>
         <config_set_ref>fsl_dac</config_set_ref>
         <config_set_ref>fsl_filter</config_set_ref>
         <config_set_ref>interrupt</config_set_ref>
      </config_set_refs>
      <master_peripheral>
         <peripheral_type>CMP</peripheral_type>
      </master_peripheral>
   </mode>
   <config_set id="fsl_cmp" label="CMP configuration" from_source="fsl_cmp.h">
      <description>Configuration of analog comparator</description>
      <generated_types>
         <enum id="cmp_hysteresis_mode_t" label="CMP Hysteresis mode." from="_cmp_hysteresis_mode">
            <item id="kCMP_HysteresisLevel0" label="Hysteresis level 0."/>
            <item id="kCMP_HysteresisLevel1" label="Hysteresis level 1."/>
            <item id="kCMP_HysteresisLevel2" label="Hysteresis level 2."/>
            <item id="kCMP_HysteresisLevel3" label="Hysteresis level 3."/>
         </enum>
         <enum id="cmp_reference_voltage_source_t" label="CMP Voltage Reference source." from="_cmp_reference_voltage_source">
            <item id="kCMP_VrefSourceVin1" label="Vin1 is selected as a resistor ladder network supply reference Vin."/>
            <item id="kCMP_VrefSourceVin2" label="Vin2 is selected as a resistor ladder network supply reference Vin."/>
         </enum>
         <struct id="cmp_config_t" label="Configures the comparator." from="_cmp_config">
            <bool id="enableCmp" label="Enable the CMP module.">
               <description>Enable the CMP module.</description>
            </bool>
            <reference id="hysteresisMode" label="CMP Hysteresis mode." type="cmp_hysteresis_mode_t">
               <description>CMP Hysteresis mode.</description>
            </reference>
            <bool id="enableHighSpeed" label="Enable High-speed (HS) comparison mode.">
               <description>Enable High-speed (HS) comparison mode.</description>
            </bool>
            <bool id="enableInvertOutput" label="Enable the inverted comparator output.">
               <description>Enable the inverted comparator output.</description>
            </bool>
            <bool id="useUnfilteredOutput" label="Set the compare output(COUT) to equal COUTA(true) or COUT(false).">
               <description>Set the compare output(COUT) to equal COUTA(true) or COUT(false).</description>
            </bool>
            <bool id="enablePinOut" label="The comparator output is available on the associated pin.">
               <description>The comparator output is available on the associated pin.</description>
            </bool>
            <bool id="enableTriggerMode" label="Enable the trigger mode." available="(featureDefined(`FSL_FEATURE_CMP_HAS_TRIGGER_MODE`) &amp;&amp; getFeature(`FSL_FEATURE_CMP_HAS_TRIGGER_MODE`))">
               <description>Enable the trigger mode.</description>
            </bool>
         </struct>
         <struct id="cmp_filter_config_t" label="Configures the filter." from="_cmp_filter_config">
            <bool id="enableSample" label="Using the external SAMPLE as a sampling clock input or using a divided bus clock." available="(featureDefined(`FSL_FEATURE_CMP_HAS_EXTERNAL_SAMPLE_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_CMP_HAS_EXTERNAL_SAMPLE_SUPPORT`))">
               <description>Using the external SAMPLE as a sampling clock input or using a divided bus clock.</description>
            </bool>
            <integer id="filterCount" label="Filter Sample Count." type="uint8_t">
               <description>Filter Sample Count. Available range is 1-7; 0 disables the filter.</description>
            </integer>
            <integer id="filterPeriod" label="Filter Sample Period." type="uint8_t">
               <description>Filter Sample Period. The divider to the bus clock. Available range is 0-255.</description>
            </integer>
         </struct>
         <struct id="cmp_dac_config_t" label="Configures the internal DAC." from="_cmp_dac_config">
            <reference id="referenceVoltageSource" label="Supply voltage reference source." type="cmp_reference_voltage_source_t">
               <description>Supply voltage reference source.</description>
            </reference>
            <integer id="DACValue" label="Value for the DAC Output Voltage." type="uint8_t">
               <description>Value for the DAC Output Voltage. Available range is 0-63.</description>
            </integer>
         </struct>
      </generated_types>
      <user_types>
         <enum id="cmp_hysteresis_mode_t" label="CMP Hysteresis mode" from="_cmp_hysteresis_mode">
            <!-- npi dependent see Datasheet -->
            <item id="kCMP_HysteresisLevel0" label="Level 0"/>
            <item id="kCMP_HysteresisLevel1" label="Level 1"/>
            <item id="kCMP_HysteresisLevel2" label="Level 2"/>
            <item id="kCMP_HysteresisLevel3" label="Level 3"/>
         </enum>
         <struct id="cmp_config_t" label="Configures the comparator" from="_cmp_config">
            <variable id="enableCmp" value="`false`" options="add_to_struct">
            </variable>
            <bool id="explicitEnableCmp" label="Start CMP module" options="remove_from_struct_init">
               <description>Enable the CMP module in initialization.</description>
            </bool>
            <reference id="hysteresisMode" label="Hysteresis mode" type="cmp_hysteresis_mode_t">
               <description>CMP hysteresis mode, MCU specific, see Data Sheet for appropriate values of the levels. Typically Level 0 = 5 mV, 10 mV, 20 mV and  Level 3 = 30 mV.</description>
            </reference>
            <bool id="enableHighSpeed" label="High-speed mode">
               <description>Enable High-speed (HS) comparison mode. Compare to the low power, propagation delay is up to 5 times shorter, like typically 50 ns instead of 250 ns.</description>
            </bool>
            <bool id="enableInvertOutput" label="Inverted output">
               <description>Enable the inverted comparator output.</description>
            </bool>
            <bool id="useUnfilteredOutput" label="Unfiltered output">
               <description>Set the comparator output pin (CMPO) to be fed from signal entering filter block (checked) or from output signal of filter block (unchecked).</description>
            </bool>
            <bool id="enablePinOut" label="Pin output">
               <description>The comparator output is available on the associated pin.</description>               
               <validation>
                  <dependency when_expr="$this.getValue()" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.cmp_out`" description_expr="$components.system.#global.err_routed_signal.getValue().formatMessage(`Output`, $instance.getPeripheral())" level="Warning">
                     <feature name="routed">
                        <data expr="true"/>
                     </feature>
                  </dependency>
               </validation>
            </bool>
            <bool id="enableTriggerMode" label="Trigger mode" available="(featureDefined(`FSL_FEATURE_CMP_HAS_TRIGGER_MODE`) &amp;&amp; getFeature(`FSL_FEATURE_CMP_HAS_TRIGGER_MODE`))">
               <description>Enable the trigger mode.</description>
            </bool>
         </struct>
      </user_types>
      <settings>
         <reference id="main_config" label="Main configuration" type="cmp_config_t" config_set_id="fsl_cmp" available="true" options="UI_LABEL_HIDDEN; UI_BORDER_HIDDEN">
            <description>Main comparator configuration</description>
         </reference>
         <variable id="positiveChannelIndex" value="$parent.positiveChannel.getEnumItemValue().regexSubstr(`.*cmp_in.(\d+).*`,1)"/>
         <dynamic_enum id="positiveChannel" label="Positive input" items="getPeripheralSignals($instance.getPeripheral()).filter(item -> item.getValue().regexMatch(`.*cmp_in.\d+.*`)).sort((item1, item2) -> stringCompare(item1,item2)).addItemToList(`IN.7`,`DAC sub-module output`,`[cmp_in.7]`,true)" options="remove_from_struct_init">
            <description>Positive side input of the comparator. Input number 7 is connected to the DAC sub-module.</description>            
            <validation>
               <dependency resource_type="PeripheralUnifiedSignal" when_expr="$parent.positiveChannelIndex.getValue() != `7`" resource_id_expr="$instance.getPeripheral() + `.cmp_in.` + $parent.positiveChannelIndex.getValue()" description_expr="$components.system.#global.err_routed_signal.getValue().formatMessage(`Input ` + $parent.positiveChannelIndex.getValue(), $instance.getPeripheral())" level="Warning">
                  <feature name="routed">
                     <data expr="true"/>
                  </feature>
               </dependency>
            </validation>
         </dynamic_enum>
         <variable id="negativeChannelIndex" value="$parent.negativeChannel.getEnumItemValue().regexSubstr(`.*cmp_in.(\d+).*`,1)"/>
         <dynamic_enum id="negativeChannel" label="Negative input" items="getPeripheralSignals($instance.getPeripheral()).filter(item -> item.getValue().regexMatch(`.*cmp_in.\d+.*`)).sort((item1, item2) -> stringCompare(item1,item2)).addItemToList(`IN.7`,`DAC sub-module output`,`[cmp_in.7]`,true)" options="remove_from_struct_init">
            <description>Negative side input of the comparator. Input number 7 is connected to the DAC sub-module.</description>
            <validation>
               <constraint cond_expr="$parent.negativeChannelIndex.getValue() != $parent.positiveChannelIndex.getValue()" level="warning" description="Positive and negative inputs should be fed from different signal."/>               
               <dependency resource_type="PeripheralUnifiedSignal" when_expr="$parent.negativeChannelIndex.getValue() != `7`" resource_id_expr="$instance.getPeripheral() + `.cmp_in.` + $parent.negativeChannelIndex.getValue()" description_expr="$components.system.#global.err_routed_signal.getValue().formatMessage(`Input ` + $parent.negativeChannelIndex.getValue(), $instance.getPeripheral())" level="Warning">
                  <feature name="routed">
                     <data expr="true"/>
                  </feature>
               </dependency>
            </validation>
         </dynamic_enum>
         <bool id="enablePassThroughMode" label="Pass through mode" available="(featureDefined(`FSL_FEATURE_CMP_HAS_PASS_THROUGH_MODE`) &amp;&amp; getFeature(`FSL_FEATURE_CMP_HAS_PASS_THROUGH_MODE`))">
            <description>Enable the pass through mode. It is necessary to enable this option to get signals from the multiple options on the same ALT in the routing. This option is MCU specific available.</description>
         </bool>
      </settings>
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="common_code_templates"/>
            <from component_id="system" config_set_id="fsl_interrupt_peripheral"/>
         </import>
         <def fragment="cmp_init_call">
            <fragment id="init_line">
               <param id="code" expr="`CMP_Init(` + toUpperCase($param.prefix) + `_PERIPHERAL, &amp;` + $instance.getFnGroupPrefix() + $instance.getID() + `_config);`"></param>
               <param id="description" expr="`Initialize CMP main sub-module functionality`"></param>
               <param id="paddingLevel" expr="1"></param>
            </fragment>
         </def>   
      </fragment_defs>
      <code>
         <section target="includes">
            <fragment id="include">
               <param id="name">common</param>
               <param id="filename">fsl_common.h</param>
            </fragment>
            <fragment id="include">
               <param id="name">cmp</param>
               <param id="filename">fsl_cmp.h</param>
            </fragment>
            <fragment id="include">
               <param id="name">clock</param>
               <param id="filename">fsl_clock.h</param>
            </fragment>
         </section>
         <section target="defines">
            <fragment id="define">
               <param id="name" expr="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`)"/>
               <param id="value" expr="$instance.getPeripheral()"/>
               <param id="description">Definition of peripheral ID</param>
            </fragment>
            <fragment id="define">
               <param id="name" expr="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_POSITIVE_INPUT_NUMBER`)"/>
               <param id="value" expr="$this.positiveChannelIndex.getValue() + `U`"/>
               <param id="description">Definition of positive input source used in CMP_SetInputChannels() function</param>
            </fragment>
            <fragment id="define">
               <param id="name" expr="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_NEGATIVE_INPUT_NUMBER`)"/>
               <param id="value" expr="$this.negativeChannelIndex.getValue() + `U`"/>
               <param id="description">Definition of negative input source used in CMP_SetInputChannels() function</param>
            </fragment>
         </section>                  
         <section target="global_vars">
            <fragment id="comment">
               <param id="content" expr="$instance.getFnGroupPrefix() + $instance.getID() + ` main configuration`"></param>
               <param id="paddingLevel" expr="0"></param>
            </fragment>
            <fragment id="const_struct" apply_to="$this.main_config">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_config`" />
               <param id="type" >cmp_config_t</param>
            </fragment>
         </section>
         <section target="global_vars_extern">
            <fragment id="extern_const_var" apply_to="$this.main_config">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_config`" />
               <param id="type" >cmp_config_t</param>
            </fragment>
         </section>
         <section target="init_function_preinit3">
            <fragment id="cmp_init_call" apply_to="$this.main_config">
               <param id="prefix" expr="$instance.getFnGroupPrefix() +  $instance.getId()" />
            </fragment>            
         </section>
         <section target="init_function_body">
            <fragment id="init_line">
               <param id="code" expr="`CMP_SetInputChannels(` + toUpperCase($instance.getFnGroupPrefix() +  $instance.getId()) + `_PERIPHERAL, ` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_POSITIVE_INPUT_NUMBER`) + `, ` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_NEGATIVE_INPUT_NUMBER`) + `);`"></param>
               <param id="description" expr="`Initialize CMP main sub-module functionality`"></param>
               <param id="paddingLevel" expr="1"></param>
            </fragment>
            <fragment id="init_line" if_expr="(($this.enablePassThroughMode.isAvailable()) &amp;&amp; ($this.enablePassThroughMode.value()))">
               <param id="code" expr="`CMP_EnablePassThroughMode(` + toUpperCase($instance.getFnGroupPrefix() +  $instance.getId()) + `_PERIPHERAL, ` + $this.enablePassThroughMode.value() + `);`"></param>
               <param id="description" expr="`Enables the pass through mode`"></param>
               <param id="paddingLevel" expr="1"></param>
            </fragment>
            <fragment id="init_line" if_expr="$this.main_config.explicitEnableCmp.value()">
               <param id="code" expr="`CMP_Enable(` + toUpperCase($instance.getFnGroupPrefix() +  $instance.getId()) + `_PERIPHERAL, ` + $this.main_config.explicitEnableCmp.value() + `);`"></param>
               <param id="description" expr="`Explicitly enables CMP periphery to satisfy glitch limitations.`"></param>
               <param id="paddingLevel" expr="1"></param>
            </fragment>
         </section>
      </code>
      <validation/>
      <quick_selections>
         <quick_selection id="cmp_default" label="Default">
            <description>Default configuration of the CMP sub-module same as CMP_GetDefaultConfig() function settings</description>
            <set id="main_config.explicitEnableCmp">true</set>
            <set id="main_config.hysteresisMode">kCMP_HysteresisLevel0</set>
            <set id="main_config.enableHighSpeed">false</set>
            <set id="main_config.enableInvertOutput">false</set>
            <set id="main_config.useUnfilteredOutput">false</set>
            <set id="main_config.enablePinOut">false</set>
            <set id="main_config.enableTriggerMode">false</set>
            <set id="enablePassThroughMode">true</set>
            <set id="positiveChannel">IN.0</set>
            <set id="negativeChannel">IN.0</set>
         </quick_selection>
         <default>cmp_default</default>
      </quick_selections>      
   </config_set>
   <config_set id="fsl_dac" label="DAC sub-module configuration" from_source="fsl_cmp.h">
      <description>Configuration of the DAC sub-module. The DAC output is interconnected with both comparator input multiplexor as input IN.7. DAC output can be also used by other peripheries as reference voltage, if it is interconnected.</description>
      <generated_types>         
      </generated_types>
      <user_types>
         <struct id="cmp_dac_config_t" label="DAC sub-module configuration" from="_cmp_dac_config">
            <variable id="referenceDynListSize" value="getPeripheralSignals($instance.getPeripheral()).filter(item -> item.getValue().regexMatch(`.*cmp_dac_ref_\d+.*`)).size()"/>
            <dynamic_enum id="referenceVoltageSource" label="Voltage reference source" items="getPeripheralSignals($instance.getPeripheral()).filter(item -> item.getValue().regexMatch(`.*cmp_dac_ref_\d+.*`)).addItemToList(`DAC_VIN1`,`DAC_VIN1`,`DAC_VIN1`, $parent.referenceDynListSize.getValue() == `0`).addItemToList(`DAC_VIN2`,`DAC_VIN2`,`DAC_VIN2`, $parent.referenceDynListSize.getValue() == `0`)" options="transform_by_regex=.*VIN(\d+).*;prefix=kCMP_VrefSourceVin">
               <description>Supply voltage reference source. It defines range of the output voltage of the DAC sub-module.</description>
            </dynamic_enum>
            <integer id="DACValue" label="Output level" type="uint8_t" min_expr="1" max_expr="64">
               <description>Value for the DAC Output Voltage in Volts = Voltage reference * this Value/64. Available range is 1-64.</description>
            </integer>
         </struct>
      </user_types>
      <settings>         
         <bool id="enableDAC" label="Enable DAC block">
             <description>Enable DAC block</description>
             <validation>
               <constraint cond_expr="($this.getValue() || (($instance.fsl_cmp.positiveChannelIndex.getValue() != `7`) &amp;&amp; ($instance.fsl_cmp.negativeChannelIndex.getValue() != `7`)))" level="warning" description="DAC sub-module output is chosen as Positive or Negative side input, so DAC sub-module should be also enabled and set up."/>
            </validation>             
         </bool>
         <reference id="dac_config" label="DAC sub-module configuration" type="cmp_dac_config_t" config_set_id="fsl_dac" available="$parent.enableDAC.value()" options="UI_LABEL_HIDDEN">
            <description>DAC sub-module configuration</description>
         </reference>
      </settings>     
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="common_code_templates"/>
            <from component_id="system" config_set_id="fsl_interrupt_peripheral"/>
         </import>
         <def fragment="dacConfig">
            <expr>`const cmp_dac_config_t ` + toUpperCase($instance.getFnGroupPrefix() +  $instance.getId()) + `_dac_config = {`</expr>
            <br/>
            <expr>leftPadding(`.referenceVoltageSource = kCMP_VrefSourceVin` + $this.referenceVoltageSource.getCValue().regexSubstr(`.*VIN(\d+).*`,1) + `,`, 1)</expr>
            <br/>
            <expr>leftPadding(`.DACValue = ` + ($this.DACValue.getValue() - 1) + `U`, 1)</expr>
            <br/>
            <expr>`};`</expr>
            <br/>
         </def>
      </fragment_defs>
      <code>
         <section target="global_vars">
            <fragment id="comment" if_expr="$this.enableDAC.value()">
               <param id="content" expr="`Configuration of the DAC sub-module, used in the CMP_SetDACConfig() function`"></param>
               <param id="paddingLevel" expr="0"></param>
            </fragment>
            <fragment id="dacConfig" apply_to="$this.dac_config" if_expr="$this.enableDAC.value()">               
            </fragment>
         </section>
         <section target="global_vars_extern">
            <fragment id="extern_const_var" apply_to="$this.dac_config" if_expr="$this.enableDAC.value()">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_dac_config`" />
               <param id="type" >cmp_dac_config_t</param>
            </fragment>
         </section>
         <section target="init_function_preinit1">        
            <fragment id="init_line" if_expr="$this.enableDAC.value()">
               <param id="code" expr="`CMP_SetDACConfig(` + toUpperCase($instance.getFnGroupPrefix() +  $instance.getId()) + `_PERIPHERAL, &amp;` + $instance.getFnGroupPrefix() + $instance.getID() + `_dac_config);`"></param>
               <param id="description" expr="`Set up internal DAC sub-module, that can be used as input 7 of the CMP both inputs.`"></param>
               <param id="paddingLevel" expr="1"></param>
            </fragment>          
         </section>
      </code>
      <validation/>
      <quick_selections>
         <quick_selection id="dac_default" label="Default">
            <description></description>            
            <set id="enableDAC">false</set>
            <set id="dac_config.DACValue">1</set>
         </quick_selection>
         <default>dac_default</default>
      </quick_selections>
   </config_set>
   <config_set id="fsl_filter" label="Filtering configuration" from_source="fsl_cmp.h">
      <description>Filtering blocks configuration. Filtering modes can be selected in this quick selection and after that tuned to fully satisfy user requirement.</description>
      <generated_types>
      </generated_types>
      <user_types>
         <enum id="cmp_clock_source_t" label="Sample clock source selection" from="_cmp_clock_source">
            <item id="SystemClock" label="System clock selected" value="BusInterfaceClock"/> <!-- value = clock_unify_ID -->               
            <!-- <item id="ExternalClock" label="Window/sample clock signal" value="SampleClock"/> Maybe when the external clock addition to the module clocks will be applicable -->
         </enum>
         <struct id="cmp_filter_config_t" label="Configures the filtering options" from="_cmp_filter_config">
            <set id="filteringOptions" label="Filtering options">
               <item id="enableWindow" label="External windowing" value="ExternalWindowing" available="(featureDefined(`FSL_FEATURE_CMP_HAS_WINDOW_MODE`) &amp;&amp; getFeature(`FSL_FEATURE_CMP_HAS_WINDOW_MODE`))"/>
               <item id="enableFilter" label="Filter block" value="FilterBlock"/>            
            </set>
            <reference id="_clockSource" label="Clock source" type="cmp_clock_source_t" options="remove_from_struct_init" available="false"/> <!-- item used for clockSource dynamic enum implementation only -->
            <variable id="clockSourceUId" value="$parent.clockSource.getEnumItemValue()" available="(($parent.filteringOptions.enableWindow.isAvailable()) &amp;&amp; ($parent.filteringOptions.enableWindow.getValue())) || $parent.filteringOptions.enableFilter.getValue()"/>
            <dynamic_enum id="clockSource" label="Sample clock source" options="remove_from_struct_init" items="enumItemsOf($parent._clockSource).arrayToEnumItems(
               enumItem -> true,
               enumItem -> enumItem.getID(),
               enumItem -> getPeripheralClock($instance.getPeripheral(), enumItem.getValue()),
               enumItem -> enumItem.getValue()).addItemToList(`ExternalClock`,`External Clock`,`SampleClock`,(featureDefined(`FSL_FEATURE_CMP_HAS_EXTERNAL_SAMPLE_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_CMP_HAS_EXTERNAL_SAMPLE_SUPPORT`)))" available="(($parent.filteringOptions.enableWindow.isAvailable()) &amp;&amp; ($parent.filteringOptions.enableWindow.getValue())) || $parent.filteringOptions.enableFilter.getValue()">
               <description>Sample clock source selection. Bus clock means internal sample source CR1[SE] = 0. External clock means external sample source CR1[SE] = 1.</description>
               <validation>
                  <constraint cond_expr="((!(($parent.filteringOptions.enableWindow.isAvailable()) &amp;&amp; ($parent.filteringOptions.enableWindow.getValue()))) || $this.getEnumItemValue() == `BusInterfaceClock`)" level="error" description="Bus clock has to be selected when windowing is enabled."/>
                  <dependency when_expr="$this.getEnumItemValue() == `SampleClock`" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.cmp_winsmp`" description="Sample clock source signal is not routed." level="Warning">
                     <feature name="routed" evaluation="equal">
                        <data expr="true"/>
                     </feature>
                  </dependency>
                  <dependency when_expr="(getPeripheralClockType($instance.getPeripheral(),$parent.clockSourceUId.getValue()) == `INPUT_SIGNAL`) &amp;&amp; ($parent.clockSourceFreq.getEnumItemId() == `GetFreq`)" resource_type="ClockOutput" resource_id_expr="getPeripheralClockSignal($instance.getPeripheral(),$parent.clockSourceUId.getValue())"
                     description_expr="(getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()).regexMatch(`.*-.*`)?(getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()).regexSubstr(`(.*)-`,1) + `is inactive.`): (getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()) + `is inactive.`))"
                     level="Warning">
                     <feature name="frequency" evaluation="greaterThan">
                        <data expr="0" unit="Hz" type="Frequency"/>
                     </feature>
                  </dependency>
                  <dependency when_expr="(getPeripheralClockType($instance.getPeripheral(),$parent.clockSourceUId.getValue()) == `INPUT_SIGNAL`) &amp;&amp; ($parent.clockSourceFreq.getEnumItemId() != `GetFreq`) &amp;&amp; ($parent.clockSourceFreq.getEnumItemId() != `custom`)" resource_type="ClockOutput" resource_id_expr="getPeripheralClockSignal($instance.getPeripheral(),$parent.clockSourceUId.getValue())"
                     description_expr="(getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()).regexMatch(`.*-.*`)?(getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()).regexSubstr(`(.*)-`,1) + `is inactive.`): (getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()) + `is inactive.`))"
                     level="Error">
                     <feature name="frequency" evaluation="greaterThan">
                        <data expr="0" unit="Hz" type="Frequency"/>
                     </feature>
                  </dependency>
               </validation>
            </dynamic_enum>
            <dynamic_enum id="clockSourceFreq" label="Sample clock source frequency" options="remove_from_struct_init" available="($parent.clockSource.isAvailable() &amp;&amp; ($parent.clockSource.getEnumItemValue() != `SampleClock`))" 
               items="(getClockFunctionalGroups().arrayToEnumItems(
                  enumItem -> true,
                  enumItem -> enumItem,
                  enumItem -> frequencyToString(getPeripheralClockFrequency($instance.getPeripheral(), $parent.clockSource.getEnumItemValue(), enumItem)) + ` (` + enumItem + `)`,
                  enumItem -> getPeripheralClockFrequency($instance.getPeripheral(), $parent.clockSource.getEnumItemValue(), enumItem)).addItemToList(`GetFreq`,`Runtime calculation by CLOCK_GetFreq()`,`GetFreq`,true))" >
               <description>Selection of the clock source frequency</description>
               <validation>
                  <constraint cond_expr="(($this.getEnumItemValue() == `GetFreq`) || ($this.getEnumItemValue().toHertz() != 0))" level="error" description="Clock source frequency cannot be 0 when it is used."/>
               </validation>
               <custom_value_support default="1" validation_expr="x -> x.toHertz() &gt; 0" />
            </dynamic_enum> 
            <integer type="uint32_t" id="extClockFrequency" label="Sample clock frequency [Hz]" options="remove_from_struct_init" available="($parent.clockSource.isAvailable() &amp;&amp; ($parent.clockSource.getEnumItemValue() == `SampleClock`))" min_expr="1">
               <description>Frequency of the sample clock source taken directly from External sample clock (see Window/sample signal item) in case of using external sampling. Value from this settings is used only to calculate Filtering delay.</description>
            </integer>     
            <dynamic_enum id="windowSample" label="Window/sample signal" items="getPeripheralSignals($instance.getPeripheral()).filter(item -> item.getValue().regexMatch(`.*cmp_winsmp.*`))" options="remove_from_struct_init" available=
            "((($parent.filteringOptions.enableWindow.isAvailable()) &amp;&amp; 
            ($parent.filteringOptions.enableWindow.getValue())) || 
            (($parent.clockSource.isAvailable()) &amp;&amp; 
            ($parent.clockSource.getEnumItemValue() == `SampleClock`)))">
               <description>External signal (pin/ other peripheral output) used for external windowing or sampling.</description>
            </dynamic_enum>
            <integer id="filterPeriod" label="Sample clock divider" type="uint8_t" min_expr="1" max_expr="255" available="(($parent.filteringOptions.enableFilter.getValue()) &amp;&amp; (($parent.clockSource.getEnumItemValue()) != `SampleClock`))">
               <description>Filter Sample Period in ticks of bus clock. The divider of the bus clock. Available range is 1-255.</description>
            </integer>
            <!-- Filter clock frequency  - it is not used in the external sampling mode (external Window/sample signal is used) -->
            <integer id="filterCount" label="Filter sample count" type="uint8_t" min_expr="1" max_expr="7" available="$parent.filteringOptions.enableFilter.getValue()">
               <description>Filter Sample Count - number of consecutive samples that must agree to filter out glitches. Available range is 1-7.</description>
            </integer>
            <info id="filterClockFrequency" label="Sample clock frequency" 
            value="frequencyToString((($parent.filteringOptions.enableFilter.getValue()) &amp;&amp; ($parent.clockSource.getEnumItemValue() != `SampleClock`))
            ? (($parent.clockSourceFreq.getEnumItemValue().toHertz()) / ($parent.filterPeriod.getValue()))
            : (((($parent.filteringOptions.enableWindow.isAvailable()) &amp;&amp; ($parent.filteringOptions.enableWindow.getValue())) &amp;&amp; (($parent.clockSource.isAvailable()) &amp;&amp; ($parent.clockSource.getEnumItemValue() != `SampleClock`)))
            ? ($parent.clockSourceFreq.getEnumItemValue().toHertz()) : (0)))"
                          available="($parent.clockSource.isAvailable() &amp;&amp; ($parent.clockSource.getEnumItemValue() != `SampleClock`))">
               <description>
                  Frequency of the sample filter clock calculated from Bus clock and divided by Sample clock divider value in case of using the internal sampling (Sample clock source item set to the Bus clock CR1[SE] = 0).
               </description>
            </info>
            <info id="filterDelay" label="Filtering delay" value="timeToString((($parent.filterClockFrequency.isAvailable())
            ? ((($parent.filteringOptions.enableFilter.getValue()) ? ((($parent.filterCount.getValue() * $parent.filterPeriod.getValue()) + 1) + ( 
            (($parent.filteringOptions.enableWindow.isAvailable()) &amp;&amp; ($parent.filteringOptions.enableWindow.getValue())) ? 1 : 0)) : ((($parent.filteringOptions.enableWindow.isAvailable()) &amp;&amp; ($parent.filteringOptions.enableWindow.getValue())) ? 1 : 0)) * $parent.clockSourceFreq.getEnumItemValue().getTime(`ns`, `Hz`))
            : ((($parent.filterCount.getValue()) * $parent.extClockFrequency.getValue().getTime(`ns`,`Hz`))))/1000.0) + (($parent.filterClockFrequency.isAvailable()) ? `` : ` + 1 Bus clock tick`)" available="($parent.filteringOptions.enableFilter.getValue() || (($parent.filteringOptions.enableWindow.isAvailable()) &amp;&amp; ($parent.filteringOptions.enableWindow.getValue())))">
               <description>
                  Time which takes signal to go through the filtering/sampling block. 
                  Delay of the filtering/sampling block is influenced by clock source frequency and the Sample clock divider in case of using the internal sampling, or Sample clock in case of using external sampling and Sample clock divider, Filter sample count and Bus clock frequency.
               </description>
            </info>
         </struct>         
      </user_types>
      <settings>
         <reference id="filter_config" label="Filter sub-module configuration" type="cmp_filter_config_t" config_set_id="fsl_filter" available="true" options="UI_LABEL_HIDDEN; UI_BORDER_HIDDEN">
            <description>Comparator filtering options configuration</description>
         </reference>         
      </settings>
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="common_code_templates"/>
            <from component_id="system" config_set_id="fsl_interrupt_peripheral"/>
         </import>
        <def fragment="filterConfig">          
          <expr>`const cmp_filter_config_t ` + toUpperCase($instance.getFnGroupPrefix() +  $instance.getId()) + `_filter_config = {`</expr>
          <br/>
          <if expr="(featureDefined(`FSL_FEATURE_CMP_HAS_EXTERNAL_SAMPLE_SUPPORT`) &amp;&amp; 
                     getFeature(`FSL_FEATURE_CMP_HAS_EXTERNAL_SAMPLE_SUPPORT`))">          
             <expr>leftPadding(`.enableSample = ` + (($this.clockSource.getEnumItemValue() == `SampleClock`) ? `true,` : `false,`), 1)</expr>
             <br/>
          </if>             
          <expr>leftPadding(`.filterCount = ` + $this.filterCount.getCValue() + `U,`, 1)</expr>
          <br/>
          <expr>leftPadding(`.filterPeriod = ` + $this.filterPeriod.getCValue() + `U`, 1)</expr>
          <br/>
          <expr>`};`</expr>
          <br/>
        </def>
      </fragment_defs>
      <code>
         <section target="global_vars">
            <fragment id="comment" if_expr="$this.filter_config.filteringOptions.enableFilter.value()">
               <param id="content" expr="`Configuration of the filter sub-module, used in the CMP_SetFilterConfig() function`"></param>
               <param id="paddingLevel" expr="0"></param>
            </fragment>
            <fragment id="filterConfig" apply_to="$this.filter_config" if_expr="$this.filter_config.filteringOptions.enableFilter.value()">
            </fragment>
         </section>
         <section target="global_vars_extern">
            <fragment id="extern_const_var" apply_to="$this.filter_config" if_expr="$this.filter_config.filteringOptions.enableFilter.value()">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_filter_config`" />
               <param id="type" >cmp_filter_config_t</param>
            </fragment>
         </section>
         <section target="init_function_preinit0">
            <fragment id="init_line" if_expr="(($this.filter_config.filteringOptions.enableWindow.isAvailable()) &amp;&amp; ($this.filter_config.filteringOptions.enableWindow.value()))">
               <param id="code" expr="`CMP_EnableWindowMode(` + toUpperCase($instance.getFnGroupPrefix() +  $instance.getId()) + `_PERIPHERAL, ` + $this.filter_config.filteringOptions.enableWindow.value() + `);`"></param>
               <param id="description" expr="`Enables windowing by external signal`"></param>
               <param id="paddingLevel" expr="1"></param>
            </fragment>
            <fragment id="init_line" if_expr="$this.filter_config.filteringOptions.enableFilter.value()">
               <param id="code" expr="`CMP_SetFilterConfig(` + toUpperCase($instance.getFnGroupPrefix() +  $instance.getId()) + `_PERIPHERAL, &amp;` + $instance.getFnGroupPrefix() + $instance.getID() + `_filter_config);`"></param>
               <param id="description" expr="`Configures Filter block settings`"></param>
               <param id="paddingLevel" expr="1"></param>
            </fragment>          
         </section>
      </code>
      <validation/>
      <quick_selections>
         <quick_selection id="ContinuousMode" label="Continuous mode">
            <description>Comparator output is influenced only by Inverted output item and COUT = COUTA.</description>            
            <set id="filter_config.filteringOptions.enableWindow">false</set>
            <set id="filter_config.filteringOptions.enableFilter">false</set>            
            <set id="filter_config.clockSource">SystemClock</set>
            <set id="filter_config.filterCount">1</set>
            <set id="filter_config.filterPeriod">1</set>
         </quick_selection>
         <quick_selection id="ExternallySampledNonFilteredMode" label="Externally sampled, Non-Filtered mode" available="(featureDefined(`FSL_FEATURE_CMP_HAS_EXTERNAL_SAMPLE_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_CMP_HAS_EXTERNAL_SAMPLE_SUPPORT`))">
            <description>Window/sample signal is used as sample clock (Filter sample count = 1).</description>
            <set id="filter_config.filteringOptions.enableWindow">false</set>
            <set id="filter_config.filteringOptions.enableFilter">true</set>            
            <set id="filter_config.clockSource">ExternalClock</set>
            <set id="filter_config.filterCount">1</set>
            <set id="filter_config.filterPeriod">1</set>
         </quick_selection>
         <quick_selection id="InternallySampledNonFilteredMode" label="Internally sampled, Non-Filtered mode">
            <description>Divided bus clock (devided by Filter sample period) is used as sample clock (Filter sample count = 1).</description>
            <set id="filter_config.filteringOptions.enableWindow">false</set>
            <set id="filter_config.filteringOptions.enableFilter">true</set>
            <set id="filter_config.clockSource">SystemClock</set>
            <set id="filter_config.filterCount">1</set>
            <set id="filter_config.filterPeriod">1</set>
         </quick_selection>
         <quick_selection id="ExternallySampledFilteredMode" label="Externally Sampled, Filtered mode" available="(featureDefined(`FSL_FEATURE_CMP_HAS_EXTERNAL_SAMPLE_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_CMP_HAS_EXTERNAL_SAMPLE_SUPPORT`))">
            <description>Window/sample signal is used as sample clock for the filter (Filter sample count > 1). To differentiate it from Non-Filtered modes Filter sample count is set to maximum value = 7. User can set his own value.</description>
            <set id="filter_config.filteringOptions.enableWindow">false</set>
            <set id="filter_config.filteringOptions.enableFilter">true</set>
            <set id="filter_config.clockSource">ExternalClock</set>
            <set id="filter_config.filterCount">7</set>
            <set id="filter_config.filterPeriod">1</set>
         </quick_selection>
         <quick_selection id="InternallySampledFilteredMode" label="Internally Sampled, Filtered mode">
            <description>Divided bus clock (devided by Filter sample period) is used as sample clock for the filter (Filter sample count > 1). To differentiate it from Non-Filtered modes Filter sample count is set to maximum value = 7. User can set his own value.</description>
            <set id="filter_config.filteringOptions.enableWindow">false</set>
            <set id="filter_config.filteringOptions.enableFilter">true</set>
            <set id="filter_config.clockSource">SystemClock</set>
            <set id="filter_config.filterCount">7</set>
            <set id="filter_config.filterPeriod">1</set>
         </quick_selection>
         <quick_selection id="WindowedMode" label="Windowed mode" available="(featureDefined(`FSL_FEATURE_CMP_HAS_WINDOW_MODE`) &amp;&amp; getFeature(`FSL_FEATURE_CMP_HAS_WINDOW_MODE`))">
            <description>Comparator output is sampled on every rising bus clock edge when external Window/sample signal = 1 to generate COUTA.</description>
            <set id="filter_config.filteringOptions.enableWindow">true</set>
            <set id="filter_config.filteringOptions.enableFilter">false</set>
            <set id="filter_config.clockSource">SystemClock</set>
            <set id="filter_config.filterCount">1</set>
            <set id="filter_config.filterPeriod">1</set>
         </quick_selection>
         <quick_selection id="WindowedResampledMode" label="Windowed/Resampled mode" available="(featureDefined(`FSL_FEATURE_CMP_HAS_WINDOW_MODE`) &amp;&amp; getFeature(`FSL_FEATURE_CMP_HAS_WINDOW_MODE`))">
            <description>Comparator output is sampled on every rising bus clock edge when Window/sample signal = 1 to generate COUTA, which is then resampled on an interval determined by FILT_PER to generate COUT.</description>
            <set id="filter_config.filteringOptions.enableWindow">true</set>
            <set id="filter_config.filteringOptions.enableFilter">true</set>
            <set id="filter_config.clockSource">SystemClock</set>
            <set id="filter_config.filterCount">1</set>
            <set id="filter_config.filterPeriod">1</set>
         </quick_selection>
         <quick_selection id="WindowedFilteredMode" label="Windowed/Filtered mode" available="(featureDefined(`FSL_FEATURE_CMP_HAS_WINDOW_MODE`) &amp;&amp; getFeature(`FSL_FEATURE_CMP_HAS_WINDOW_MODE`))">
            <description>Comparator output is sampled on every rising bus clock edge when Window/sample signal = 1 to generate COUTA, which is then resampled and filtered to generate COUT. To differentiate it from Non-Filtered modes Filter sample count is set to maximum value = 7. User can set his own value.</description>
            <set id="filter_config.filteringOptions.enableWindow">true</set>
            <set id="filter_config.filteringOptions.enableFilter">true</set>
            <set id="filter_config.clockSource">SystemClock</set>
            <set id="filter_config.filterCount">7</set>
            <set id="filter_config.filterPeriod">1</set>
         </quick_selection>
         <default>ContinuousMode</default>
      </quick_selections>
   </config_set>   
   <config_set id="interrupt" label="Interrupt configuration" from_source="fsl_common.h">
      <description>Interrupt configuration</description> 
      <generated_types/>
      <user_types>
         <set id="interrupt_types" label="Interrupt types">
            <item id="kCMP_OutputRisingInterruptEnable" label="Rising edge interrupt" value="kCMP_OutputRisingInterruptEnable"/>
            <item id="kCMP_OutputFallingInterruptEnable" label="Falling edge interrupt" value="kCMP_OutputFallingInterruptEnable"/>            
         </set>
      </user_types>
      <settings>
         <reference id="interrupt_sel" label="Interrupt selection" type="interrupt_types"/>
         <bool id="enableDma" label="DMA request instead of interrupt" available="(featureDefined(`FSL_FEATURE_CMP_HAS_DMA`) &amp;&amp; getFeature(`FSL_FEATURE_CMP_HAS_DMA`))">
            <description>Enable DMA requests from CMP instead of interrupt, Rising edge interrupt or Falling edge interrupt or both should be enabled in this case.</description>
            <validation>
               <constraint cond_expr="!$this.getValue() || $parent.interrupt_sel.kCMP_OutputRisingInterruptEnable.getValue() || $parent.interrupt_sel.kCMP_OutputFallingInterruptEnable.getValue()" level="warning" description="Rising edge interrupt or Falling edge interrupt or both should be enabled to specify source of the DMA trigger."/>
            </validation>
         </bool>         
         <reference id="interrupt" label="Interrupt setting" type="interrupt_vector_t" config_set_id="fsl_interrupt_peripheral" component_id="system" available="!$parent.enableDma.getValue()"/>
      </settings>
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="fsl_interrupt_peripheral"/>
         </import>
      </fragment_defs>
      <code>
        <section target="defines">
           <fragment id="IRQ_definitions" apply_to="$this.interrupt"/>
        </section>            
        <section target="init_function_postinit0">
          <if expr="$this.interrupt_sel.getCValue() != ``">
             <text>  /* Select edges which trigger interrupt or DMA transfer if selected */</text><br/>
             <expr>`  CMP_EnableInterrupts(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +`_PERIPHERAL, (`) + $this.interrupt_sel.getCValue() + `));`</expr><br/>
          </if>
          <fragment id="init_line" if_expr="$this.enableDma.value()">
             <param id="code" expr="`CMP_EnableDMA(` + toUpperCase($instance.getFnGroupPrefix() +  $instance.getId()) + `_PERIPHERAL, ` + $this.enableDma.value() + `);`"></param>
             <param id="description" expr="`Enables the DMA transfer on compare instead of interrupt.`"></param>
             <param id="paddingLevel" expr="1"></param>
          </fragment>
          <fragment id="IRQn_set_priority_default" apply_to="$this.interrupt" if_expr="!$this.enableDma.value()"/>
          <fragment id="IRQn_enable_default" apply_to="$this.interrupt" if_expr="!$this.enableDma.value()"/>
        </section>
      </code>
      <quick_selections>
         <quick_selection id="QS_IRQ_priority1" label="Default">
            <description>Default IRQ setting.</description>
            <set id="interrupt_sel.kCMP_OutputRisingInterruptEnable">true</set>
            <set id="interrupt_sel.kCMP_OutputFallingInterruptEnable">true</set>
            <set id="interrupt.priority">0</set>
         </quick_selection>
         <default>QS_IRQ_priority1</default>
      </quick_selections>
   </config_set>
</component:config_component>