<?xml version="1.0" encoding= "UTF-8" ?>
<component:config_component id="lpuart" label="LPUART" category="Peripheral driver" global_only="false" xsi:schemaLocation="http://swtools.freescale.net/XSD/component/1.0 http://swtools.freescale.net/XSD/component/1.0/component-5.0.xsd" xmlns:component="http://swtools.freescale.net/XSD/component/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   <sw_comp_ref name="platform.drivers.lpuart" version="2.2.4"/>
   <description>Low Power Universal Asynchronous Receiver/Transmitter (LPUART)</description>
   <mode id="polling" label="Polling">
      <description>Basic LPUART operation initialization (without support of interrupts and transactional API).</description>
      <config_set_refs>
         <config_set_ref>lpuartConfig_t</config_set_ref>
      </config_set_refs>
      <master_peripheral>
         <peripheral_type>LPUART</peripheral_type>
      </master_peripheral>
   </mode>
   <mode id="interrupts" label="Interrupts">
      <description>LPUART operation using interrupts (interrupt routines are defined by users)</description>
      <config_set_refs>
         <config_set_ref>lpuartConfig_t</config_set_ref>
         <config_set_ref>interruptsCfg</config_set_ref>
      </config_set_refs>
      <master_peripheral>
         <peripheral_type>LPUART</peripheral_type>
      </master_peripheral>
   </mode>
   <mode id="transfer" label="Transfer">
      <description>LPUART operation using transfer mode (ring buffer). This mode supports transactional APIs that provides asynchronous transfer (non-blocking API is provided; callback functions can be used).
      </description>
      <config_set_refs>
         <config_set_ref>lpuartConfig_t</config_set_ref>
         <config_set_ref>transferCfg</config_set_ref>
      </config_set_refs>
      <master_peripheral>
         <peripheral_type>LPUART</peripheral_type>
      </master_peripheral>
   </mode>
   <mode id="edma" label="eDMA" available="featureDefined(`SOC_EDMA_COUNT`) &amp;&amp; getFeature(`SOC_EDMA_COUNT`)">
      <description>LPUART operation using eDMA mode (DMA device). This mode supports transactional API by using eDMA device.
      </description>
      <config_set_refs>
         <config_set_ref>lpuartConfig_t</config_set_ref>
         <config_set_ref>edmaCfg</config_set_ref>
      </config_set_refs>
      <master_peripheral>
         <peripheral_type>LPUART</peripheral_type>
      </master_peripheral>
   </mode>
   <mode id="dma" label="DMA" available="featureDefined(`SOC_DMA_COUNT`) &amp;&amp; getFeature(`SOC_DMA_COUNT`)">
      <description>LPUART operation using DMA mode (DMA device). This mode supports transactional API by using DMA device.
      </description>
      <config_set_refs>
         <config_set_ref>lpuartConfig_t</config_set_ref>
         <config_set_ref>dmaCfg</config_set_ref>
      </config_set_refs>
      <master_peripheral>
         <peripheral_type>LPUART</peripheral_type>
      </master_peripheral>
   </mode>
   <mode id="freertos" label="FreeRTOS">
      <description>LPUART operation in RTOS mode (FreeRTOS mode with transactional API).</description>
      <config_set_refs>
         <config_set_ref>fsl_lpuart_freertos</config_set_ref>
      </config_set_refs>
      <master_peripheral>
         <peripheral_type>LPUART</peripheral_type>
      </master_peripheral>
   </mode>
   
   <!-- ******************** -->
   <!-- GENERATED CONFIG SET -->
   <!-- ******************** -->
   <config_set id="fsl_lpuart" label="TBD" from_source="fsl_lpuart.h">
      <description>TBD</description>
      <fragment_defs/>
      <code/>
      <validation/>
      <quick_selections>
      </quick_selections>
      <generated_types>
         <enum id="lpuart_parity_mode_t" label="LPUART parity mode." from="_lpuart_parity_mode">
            <item id="kLPUART_ParityDisabled" label="Parity disabled"/>
            <item id="kLPUART_ParityEven" label="Parity enabled, type even, bit setting: PE|PT = 10"/>
            <item id="kLPUART_ParityOdd" label="Parity enabled, type odd, bit setting: PE|PT = 11"/>
         </enum>
         <enum id="lpuart_data_bits_t" label="LPUART data bits count." from="_lpuart_data_bits">
            <item id="kLPUART_EightDataBits" label="Eight data bit"/>
            <item id="kLPUART_SevenDataBits" label="Seven data bit" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT`))"/>
         </enum>
         <enum id="lpuart_stop_bit_count_t" label="LPUART stop bit count." from="_lpuart_stop_bit_count">
            <item id="kLPUART_OneStopBit" label="One stop bit"/>
            <item id="kLPUART_TwoStopBit" label="Two stop bits"/>
         </enum>
         <enum id="lpuart_transmit_cts_source_t" label="LPUART transmit CTS source." from="_lpuart_transmit_cts_source" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`))">
            <item id="kLPUART_CtsSourcePin" label="CTS resource is the LPUART_CTS pin."/>
            <item id="kLPUART_CtsSourceMatchResult" label="CTS resource is the match result."/>
         </enum>
         <enum id="lpuart_transmit_cts_config_t" label="LPUART transmit CTS configure." from="_lpuart_transmit_cts_config" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`))">
            <item id="kLPUART_CtsSampleAtStart" label="CTS input is sampled at the start of each character."/>
            <item id="kLPUART_CtsSampleAtIdle" label="CTS input is sampled when the transmitter is idle"/>
         </enum>
         <enum id="lpuart_idle_type_select_t" label="LPUART idle flag type defines when the receiver starts counting." from="_lpuart_idle_type_select">
            <item id="kLPUART_IdleTypeStartBit" label="Start counting after a valid start bit."/>
            <item id="kLPUART_IdleTypeStopBit" label="Start conuting after a stop bit."/>
         </enum>
         <enum id="lpuart_idle_config_t" label="LPUART idle detected configuration." from="_lpuart_idle_config">
            <item id="kLPUART_IdleCharacter1" label="the number of idle characters."/>
            <item id="kLPUART_IdleCharacter2" label="the number of idle characters."/>
            <item id="kLPUART_IdleCharacter4" label="the number of idle characters."/>
            <item id="kLPUART_IdleCharacter8" label="the number of idle characters."/>
            <item id="kLPUART_IdleCharacter16" label="the number of idle characters."/>
            <item id="kLPUART_IdleCharacter32" label="the number of idle characters."/>
            <item id="kLPUART_IdleCharacter64" label="the number of idle characters."/>
            <item id="kLPUART_IdleCharacter128" label="the number of idle characters."/>
         </enum>
         <struct id="lpuart_config_t" label="LPUART configuration structure." from="_lpuart_config" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT`))">
            <integer id="baudRate_Bps" label="LPUART baud rate" type="uint32_t">
               <description>LPUART baud rate</description>
            </integer>
            <reference id="parityMode" label="Parity mode, disabled (default), even, odd" type="lpuart_parity_mode_t">
               <description>Parity mode, disabled (default), even, odd</description>
            </reference>
            <reference id="dataBitsCount" label="Data bits count, eight (default), seven" type="lpuart_data_bits_t">
               <description>Data bits count, eight (default), seven</description>
            </reference>
            <bool id="isMsb" label="Data bits order, LSB (default), MSB">
               <description>Data bits order, LSB (default), MSB</description>
            </bool>
            <reference id="stopBitCount" label="Number of stop bits, 1 stop bit (default) or 2 stop bits" type="lpuart_stop_bit_count_t" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_STOP_BIT_CONFIG_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_STOP_BIT_CONFIG_SUPPORT`))">
               <description>Number of stop bits, 1 stop bit (default) or 2 stop bits</description>
            </reference>
            <integer id="txFifoWatermark" label="TX FIFO watermark" type="uint8_t" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_FIFO`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_FIFO`))">
               <description>TX FIFO watermark</description>
            </integer>
            <integer id="rxFifoWatermark" label="RX FIFO watermark" type="uint8_t" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_FIFO`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_FIFO`))">
               <description>RX FIFO watermark</description>
            </integer>
            <bool id="enableRxRTS" label="RX RTS enable" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`))">
               <description>RX RTS enable</description>
            </bool>
            <bool id="enableTxCTS" label="TX CTS enable" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`))">
               <description>TX CTS enable</description>
            </bool>
            <reference id="txCtsSource" label="TX CTS source" type="lpuart_transmit_cts_source_t" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`))">
               <description>TX CTS source</description>
            </reference>
            <reference id="txCtsConfig" label="TX CTS configure" type="lpuart_transmit_cts_config_t" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`))">
               <description>TX CTS configure</description>
            </reference>
            <reference id="rxIdleType" label="RX IDLE type." type="lpuart_idle_type_select_t">
               <description>RX IDLE type.</description>
            </reference>
            <reference id="rxIdleConfig" label="RX IDLE configuration." type="lpuart_idle_config_t">
               <description>RX IDLE configuration. Configures the number of idle characters that must be received before the IDLE flag is set.</description>
            </reference>
            <bool id="enableTx" label="Enable TX">
               <description>Enable TX</description>
            </bool>
            <bool id="enableRx" label="Enable RX">
               <description>Enable RX</description>
            </bool>
         </struct>
         <struct id="lpuart_transfer_t" label="LPUART transfer structure." from="_lpuart_transfer" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT`))">
            <fixme id="data" label="The buffer of data to be transfer." type="uint8_t *">
               <description>The buffer of data to be transfer.</description>
            </fixme>
            <fixme id="dataSize" label="The byte count to be transfer." type="size_t">
               <description>The byte count to be transfer.</description>
            </fixme>
         </struct>
         <struct id="lpuart_handle_t" label="" from="_lpuart_handle" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT`))">
            <fixme id="txData" label="Address of remaining data to send." type="uint8_t *volatile">
               <description>Address of remaining data to send.</description>
            </fixme>
            <fixme id="txDataSize" label="Size of the remaining data to send." type="size_t">
               <description>Size of the remaining data to send.</description>
            </fixme>
            <fixme id="txDataSizeAll" label="Size of the data to send out." type="size_t">
               <description>Size of the data to send out.</description>
            </fixme>
            <fixme id="rxData" label="Address of remaining data to receive." type="uint8_t *volatile">
               <description>Address of remaining data to receive.</description>
            </fixme>
            <fixme id="rxDataSize" label="Size of the remaining data to receive." type="size_t">
               <description>Size of the remaining data to receive.</description>
            </fixme>
            <fixme id="rxDataSizeAll" label="Size of the data to receive." type="size_t">
               <description>Size of the data to receive.</description>
            </fixme>
            <fixme id="rxRingBuffer" label="Start address of the receiver ring buffer." type="uint8_t *">
               <description>Start address of the receiver ring buffer.</description>
            </fixme>
            <fixme id="rxRingBufferSize" label="Size of the ring buffer." type="size_t">
               <description>Size of the ring buffer.</description>
            </fixme>
            <integer id="rxRingBufferHead" label="Index for the driver to store received data into ring buffer." type="uint16_t">
               <description>Index for the driver to store received data into ring buffer.</description>
            </integer>
            <integer id="rxRingBufferTail" label="Index for the user to get data from the ring buffer." type="uint16_t">
               <description>Index for the user to get data from the ring buffer.</description>
            </integer>
            <reference id="callback" label="Callback function." type="lpuart_transfer_callback_t">
               <description>Callback function.</description>
            </reference>
            <fixme id="userData" label="LPUART callback function parameter." type="void *">
               <description>LPUART callback function parameter.</description>
            </fixme>
            <integer id="txState" label="TX transfer state." type="uint8_t">
               <description>TX transfer state.</description>
            </integer>
            <integer id="rxState" label="RX transfer state." type="uint8_t">
               <description>RX transfer state.</description>
            </integer>
            <bool id="isSevenDataBits" label="Seven data bits flag." available="(featureDefined(`FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT`))">
               <description>Seven data bits flag.</description>
            </bool>
         </struct>
         <fixme id="lpuart_transfer_callback_t" label="LPUART transfer callback function." type="void(*" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT`))"/>
      </generated_types>
      <settings>
      </settings>
      <user_types>
      </user_types>
   </config_set>
   <!-- *************************** -->
   <!-- END OF GENERATED CONFIG SET -->
   <!-- *************************** -->
   <config_set id="lpuartConfig_t" label="LPUART general configuration" from_source="src/fsl_lpuart.h">
      <description>LPUART general configuration</description>
      <generated_types>
      </generated_types>
      <user_types>
         <enum id="lpuart_parity_mode_t" label="LPUART parity mode." from="_lpuart_parity_mode">
            <item id="kLPUART_ParityDisabled" label="Parity disabled"/>
            <item id="kLPUART_ParityEven" label="Even parity"/>
            <item id="kLPUART_ParityOdd" label="Odd parity"/>
         </enum>
         <enum id="lpuart_data_bits_t" label="LPUART data size" from="_lpuart_data_bits">
            <item id="kLPUART_EightDataBits" label="Eight data bit"/>
            <item id="kLPUART_SevenDataBits" label="Seven data bit" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT`))"/>
         </enum>
         <enum id="lpuart_stop_bit_count_t" label="LPUART stop bit count" from="_lpuart_stop_bit_count">
            <item id="kLPUART_OneStopBit" label="One stop bit"/>
            <item id="kLPUART_TwoStopBit" label="Two stop bits"/>
         </enum>
         <enum id="lpuart_transmit_cts_source_t" label="LPUART transmit CTS source" from="_lpuart_transmit_cts_source" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`))">
            <item id="kLPUART_CtsSourcePin" label="LPUART CTS pin"/>
            <item id="kLPUART_CtsSourceMatchResult" label="Match result"/>
         </enum>
         <enum id="lpuart_transmit_cts_config_t" label="LPUART transmit CTS configure." from="_lpuart_transmit_cts_config" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`))">
            <item id="kLPUART_CtsSampleAtStart" label="Sampled at the start"/>
            <item id="kLPUART_CtsSampleAtIdle" label="Sampled at idle"/>
         </enum>
         <enum id="lpuart_idle_type_select_t" label="LPUART idle flag type defines when the receiver starts counting." from="_lpuart_idle_type_select">
            <item id="kLPUART_IdleTypeStartBit" label="Start counting after a valid start bit"/>
            <item id="kLPUART_IdleTypeStopBit" label="Start counting after a stop bit"/>
         </enum>
         <enum id="lpuart_idle_config_t" label="LPUART idle detected configuration." from="_lpuart_idle_config">
            <item id="kLPUART_IdleCharacter1" label="1 idle character"/>
            <item id="kLPUART_IdleCharacter2" label="2 idle characters"/>
            <item id="kLPUART_IdleCharacter4" label="4 idle characters"/>
            <item id="kLPUART_IdleCharacter8" label="8 idle characters"/>
            <item id="kLPUART_IdleCharacter16" label="16 idle characters"/>
            <item id="kLPUART_IdleCharacter32" label="32 idle characters"/>
            <item id="kLPUART_IdleCharacter64" label="64 idle characters"/>
            <item id="kLPUART_IdleCharacter128" label="128 idle characters"/>
         </enum>
         <struct id="lpuart_config_t" label="LPUART configuration structure." from="_lpuart_config" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT`))">
<!--            <integer id="lpuartSrcClkFreq" label="LPUART source clock frequency [Hz]" type="uint32_t" options="remove_from_struct_init">
               <description>LPUART clock source selection is part of the SIM (System Integration Module) configuration that is MCU specific. Set the value of this setting according to the configuration of the SIM device.</description>
               <validation>
                  <constraint cond_expr="$this.getValue() &gt; 0" level="error" description="The LPUART source clock freqnency must be set (non-zero value is expected)."/>
               </validation>
            </integer>-->
            <variable id="clockSourceUId" value="`LpuartClock`"/>
            <dynamic_enum id="clockSource" label="Clock source" options="remove_from_struct_init" items="createArray().addItemToList(`LpuartClock`, getPeripheralClock($instance.getPeripheral(), `LpuartClock`), ($instance.getPeripheral() + `_CLK_SRC`),true)" >
               <description>LPUART clock source.</description>
               <validation>
                  <dependency when_expr="($parent.lpuartSrcClkFreq.getEnumItemId() != `GetFreq`) &amp;&amp; ($parent.lpuartSrcClkFreq.getEnumItemId() != `custom`)" resource_type="ClockOutput" resource_id_expr="getPeripheralClockSignal($instance.getPeripheral(),$parent.clockSourceUId.getValue())"
                     description_expr="(getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()).regexMatch(`.*-.*`)?(getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()).regexSubstr(`(.*)-`,1) + `is inactive.`): (getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()) + `is inactive.`))"
                     level="Error">
                     <feature name="frequency" evaluation="greaterThan">
                        <data expr="0" unit="Hz" type="Frequency"/>
                     </feature>
                  </dependency>
               </validation>
            </dynamic_enum>
            <dynamic_enum id="lpuartSrcClkFreq" label="Clock source frequency" options="remove_from_struct_init" 
               items="getClockFunctionalGroups().arrayToEnumItems(
               enumItem -> true,
               enumItem -> enumItem,
               enumItem -> frequencyToString(getPeripheralClockFrequency($instance.getPeripheral(), $parent.clockSource.getEnumItemId(), enumItem)) + ` (` + enumItem + `)`,
               enumItem -> getPeripheralClockFrequency($instance.getPeripheral(), $parent.clockSource.getEnumItemId(), enumItem))" >
               <description>Selection of the clock source frequency. Note: LPUART clock source selection is part of the SIM (System Integration Module) configuration, see the LPUART clock settings in the Clocks tool.</description>
               <validation>
                  <constraint cond_expr="$this.getEnumItemValue() != 0" level="error" description="Clock source frequency cannot be 0 when it is used."/>
               </validation>
               <custom_value_support default="0" validation_expr="x -> x.toHertz() >= 0" />
            </dynamic_enum> 
            <integer id="baudRate_Bps" label="LPUART baud rate" type="uint32_t"  min_expr="1"> <!-- TO DO - This item is workaround for the issue KPSDK-18000 - [fsl_clock] Missing support of the LPUART clock in the GetFreq function. When fixed it shall be removed. -->
               <description>LPUART baud rate</description>
            </integer>
            <reference id="parityMode" label="Parity mode" type="lpuart_parity_mode_t">
               <description>Parity mode, disabled (default), even, odd</description>
            </reference>
            <reference id="dataBitsCount" label="Data size" type="lpuart_data_bits_t">
               <description>Data size in bits. There is supported eight (default) and seven (it is MCU specific)</description>
            </reference>
            <bool id="isMsb" label="Enable MSB data bits order">
               <description>Enable of MSB data bits order. When disabled the LSB order is used.</description>
            </bool>
            <reference id="stopBitCount" label="Number of stop bits" type="lpuart_stop_bit_count_t" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_STOP_BIT_CONFIG_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_STOP_BIT_CONFIG_SUPPORT`))">
               <description>Number of stop bits - 1 stop bit (default) or 2 stop bits</description>
            </reference>
            <integer id="txFifoWatermark" label="TX FIFO watermark" type="uint8_t" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_FIFO`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_FIFO`))" max_expr="((featureDefined(`FSL_FEATURE_LPUART_FIFO_SIZE`) &amp;&amp; (getFeature(`FSL_FEATURE_LPUART_FIFO_SIZE`) &gt; 1))? getFeature(`FSL_FEATURE_LPUART_FIFO_SIZE`):1)">
               <description>TX FIFO watermark</description>
            </integer>
            <integer id="rxFifoWatermark" label="RX FIFO watermark" type="uint8_t" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_FIFO`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_FIFO`))" max_expr="((featureDefined(`FSL_FEATURE_LPUART_FIFO_SIZE`) &amp;&amp; (getFeature(`FSL_FEATURE_LPUART_FIFO_SIZE`) &gt; 1))? getFeature(`FSL_FEATURE_LPUART_FIFO_SIZE`):1)">
               <description>RX FIFO watermark</description>
               <validation>
                  <constraint when_expr="featureDefined(`FSL_FEATURE_LPUART_FIFO_SIZE`) &amp;&amp; (getFeature(`FSL_FEATURE_LPUART_FIFO_SIZE`) &gt; 1)" cond_expr="$this.getValue()!=0" level="info" description_expr="`Rx FIFO buffer (size: ` + getFeature(`FSL_FEATURE_LPUART_FIFO_SIZE`) + ` datawords) is available and can be used by setting watermark in range 1 - ` + (getFeature(`FSL_FEATURE_LPUART_FIFO_SIZE`).toInt()-1) + `.`"/> 
               </validation>
            </integer>
            <bool id="enableRxRTS" label="RX RTS enable" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`))">
               <description>Enables/disables the receiver RTS (Request To Send of Receiver).</description>
               <validation>
                  <dependency when_expr="$this.getValue()" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.uart_rts`" description_expr="$components.system.#global.err_routed_signal.getValue().formatMessage(`RTS`, $instance.getPeripheral())" level="Warning">
                     <feature name="routed" evaluation="equal">
                        <data expr="true"/>
                     </feature>
                  </dependency>
               </validation>
            </bool>
            <bool id="enableTxCTS" label="TX CTS enable" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`))">
               <description>Enable the CTS of the TX (Clear To Send of the transmitter)</description>
               <validation>
                  <dependency when_expr="$this.getValue()" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.uart_cts`" description_expr="$components.system.#global.err_routed_signal.getValue().formatMessage(`CTS`, $instance.getPeripheral())" level="Warning">
                     <feature name="routed" evaluation="equal">
                        <data expr="true"/>
                     </feature>
                  </dependency>
               </validation>
            </bool>
            <reference id="txCtsSource" label="TX CTS source" type="lpuart_transmit_cts_source_t" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`))">
               <description>Transmitter CTS source selection.</description>
            </reference>
            <reference id="txCtsConfig" label="TX CTS configuration" type="lpuart_transmit_cts_config_t" available="(featureDefined(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT`))">
               <description>Selection if the CTS state is checked at the start of each character or only when the transmitter is idle.</description>
            </reference>
            <reference id="rxIdleType" label="RX IDLE type" type="lpuart_idle_type_select_t">
               <description>Receiver IDLE type.</description>
            </reference>
            <reference id="rxIdleConfig" label="RX IDLE configuration" type="lpuart_idle_config_t">
               <description>Receiver IDLE configuration.</description>
            </reference>
            <bool id="enableTx" label="Enable TX">
               <description>Enable transmitter of the LPUART device.</description>
               <validation>
                  <dependency when_expr="$this.getValue()" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.uart_tx`" description_expr="$components.system.#global.err_routed_signal.getValue().formatMessage(`TX`, $instance.getPeripheral())" level="Warning">
                     <feature name="routed" evaluation="equal">
                        <data expr="true"/>
                     </feature>
                  </dependency>
               </validation>
            </bool>
            <bool id="enableRx" label="Enable RX">
               <description>Enable receiver of the LPUART.</description>
               <validation>
                  <dependency when_expr="$this.getValue()" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.uart_rx`" description_expr="$components.system.#global.err_routed_signal.getValue().formatMessage(`RX`, $instance.getPeripheral())" level="Warning">
                     <feature name="routed" evaluation="equal">
                        <data expr="true"/>
                     </feature>
                  </dependency>
               </validation>
            </bool>
         </struct>
      </user_types>
      <settings>
         <reference id="lpuartConfig" label="LPUART Configuration" type="lpuart_config_t"/>
      </settings>
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="common_code_templates"/>
         </import>
      </fragment_defs>
      <code>
         <section target="includes">
            <fragment id="include">
               <param id="name">common</param>
               <param id="filename">fsl_common.h</param>
            </fragment>
            <fragment id="include">
               <param id="name">lpuart</param>
               <param id="filename">fsl_lpuart.h</param>
            </fragment>
            <fragment id="include">
               <param id="name">clock</param>
               <param id="filename">fsl_clock.h</param>
            </fragment>
         </section>
         <section target="defines">
            <fragment id="define">
               <param id="name" expr="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`)"/>
               <param id="value" expr="$instance.getPeripheral()"/>
               <param id="description">Definition of peripheral ID</param>
            </fragment>
            <fragment id="define">
               <param id="name" expr="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_CLOCK_SOURCE`)"/>
<!--               <param id="value" expr="`CLOCK_GetFreq(` + $instance.getPeripheral() + `_CLK_SRC)`"/> TO DO - use the CLOCK_GetFreq() function when the issue KPSDK-18000 is fixed. -->
               <param id="value" expr="$this.lpuartConfig.lpuartSrcClkFreq.getEnumItemValue().toHertz() + `UL`"/>
               <param id="description">Definition of the clock source frequency</param>
            </fragment>
         </section>                  
         <section target="global_vars">
            <fragment id="const_struct" apply_to="$this.lpuartConfig">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_config`" />
               <param id="type" >lpuart_config_t</param>
            </fragment>
         </section>
         <section target="global_vars_extern">
            <fragment id="extern_const_var" apply_to="$this.lpuartConfig">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_config`" />
               <param id="type" >lpuart_config_t</param>
            </fragment>
         </section>
         <section target="init_function_body">
            <expr>leftPadding(`LPUART_Init(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL, &amp;`) + $instance.getFnGroupPrefix() + $instance.getID() + `_config, ` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_CLOCK_SOURCE);`), 1)</expr><br/>
         </section>
      </code>
      <validation>  
      </validation>
      <quick_selections>
         <quick_selection id="QuickSelection1" label="115200-N,8,1">
            <set id="lpuartConfig.baudRate_Bps">115200</set>
            <set id="lpuartConfig.parityMode">kLPUART_ParityDisabled</set>
            <set id="lpuartConfig.enableTx">true</set>
            <set id="lpuartConfig.enableRx">true</set>
            <set id="lpuartConfig.txFifoWatermark">0</set>
            <set id="lpuartConfig.rxFifoWatermark">1</set>
         </quick_selection>
         <quick_selection id="QuickSelection2" label="57600-N,8,1">
            <set id="lpuartConfig.baudRate_Bps">57600</set>
            <set id="lpuartConfig.parityMode">kLPUART_ParityDisabled</set>
            <set id="lpuartConfig.enableTx">true</set>
            <set id="lpuartConfig.enableRx">true</set>
            <set id="lpuartConfig.txFifoWatermark">0</set>
            <set id="lpuartConfig.rxFifoWatermark">1</set>
         </quick_selection>
         <quick_selection id="QuickSelection3" label="38400-N,8,1">
            <set id="lpuartConfig.baudRate_Bps">38400</set>
            <set id="lpuartConfig.parityMode">kLPUART_ParityDisabled</set>
            <set id="lpuartConfig.enableTx">true</set>
            <set id="lpuartConfig.enableRx">true</set>
            <set id="lpuartConfig.txFifoWatermark">0</set>
            <set id="lpuartConfig.rxFifoWatermark">1</set>
         </quick_selection>
         <quick_selection id="QuickSelection4" label="19200-N,8,1">
            <set id="lpuartConfig.baudRate_Bps">19200</set>
            <set id="lpuartConfig.parityMode">kLPUART_ParityDisabled</set>
            <set id="lpuartConfig.enableTx">true</set>
            <set id="lpuartConfig.enableRx">true</set>
            <set id="lpuartConfig.txFifoWatermark">0</set>
            <set id="lpuartConfig.rxFifoWatermark">1</set>
         </quick_selection>
         <quick_selection id="QuickSelection5" label="9600-N,8,1">
            <set id="lpuartConfig.baudRate_Bps">9600</set>
            <set id="lpuartConfig.parityMode">kLPUART_ParityDisabled</set>
            <set id="lpuartConfig.enableTx">true</set>
            <set id="lpuartConfig.enableRx">true</set>
            <set id="lpuartConfig.txFifoWatermark">0</set>
            <set id="lpuartConfig.rxFifoWatermark">1</set>
         </quick_selection>
         <default>QuickSelection1</default>
      </quick_selections>
   </config_set>
   <config_set id="interruptsCfg" label="Interrupt configuration" from_source="src/fsl_lpuart.h">
      <description>LPUART interrupt mode configuration.</description>
      <generated_types>
      </generated_types>
      <user_types>
         <set id="interrupt_types" label="Interrupts">
            <item id="kLPUART_LinBreakInterruptEnable" label="LIN break detect interrupt" available="featureDefined(`FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT`)"/>
            <item id="kLPUART_RxActiveEdgeInterruptEnable" label="RX active edge interrupt"/>
            <item id="kLPUART_TxDataRegEmptyInterruptEnable" label="Transmit data register empty interrupt"/>
            <item id="kLPUART_TransmissionCompleteInterruptEnable" label="Transmission complete interrupt"/>
            <item id="kLPUART_RxDataRegFullInterruptEnable" label="Receiver data register full interrupt"/>
            <item id="kLPUART_IdleLineInterruptEnable" label="Idle line interrupt"/>
            <item id="kLPUART_RxOverrunInterruptEnable" label="Receiver overrun interrupt"/>
            <item id="kLPUART_NoiseErrorInterruptEnable" label="Noise error flag interrupt"/>
            <item id="kLPUART_FramingErrorInterruptEnable" label="Framing error flag interrupt"/>
            <item id="kLPUART_ParityErrorInterruptEnable" label="Parity error flag interrupt"/>
            <item id="kLPUART_TxFifoOverflowInterruptEnable" label="RX FIFO overflow interrupt" available="featureDefined(`FSL_FEATURE_LPUART_HAS_FIFO`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_FIFO`)"/>
            <item id="kLPUART_RxFifoUnderflowInterruptEnable" label="RX FIFO underflow interrupt" available="featureDefined(`FSL_FEATURE_LPUART_HAS_FIFO`) &amp;&amp; getFeature(`FSL_FEATURE_LPUART_HAS_FIFO`)"/>
         </set>
      </user_types>
      <settings>
         <reference id="interrupts" label="Interrupts" type="interrupt_types"/>
         <struct id="interrupt_vectors" label="Interrupt vectors">
            <variable id="var_shared_IRQn_rx_tx" value="getResource(
                                                        `interrupts`, 
                                                         $instance.getCoreId()
                                                         ).searchInArray
                                                           ( varItem -> 
                                                             (   
                                                              ((varItem.getSetting(`devices`).searchInArray
                                                                  (
                                                                     item -> (item.getSetting(`function`).getValue() == `serial_rx` &amp;&amp; (item.getSetting(`id`).getValue() == $instance.getPeripheral()))
                                                                  )
                                                               ) >=0
                                                            &amp;&amp;
                                                               (varItem.getSetting(`devices`).searchInArray
                                                                  (
                                                                     item -> (item.getSetting(`function`).getValue() == `serial_tx` &amp;&amp; (item.getSetting(`id`).getValue() == $instance.getPeripheral()))
                                                                  )
                                                               ) >=0)
                                                            ||
                                                            (varItem.getSetting(`devices`).searchInArray
                                                                  (
                                                                     item -> (item.getSetting(`function`).getValue() == `serial_rx_tx` &amp;&amp; (item.getSetting(`id`).getValue() == $instance.getPeripheral()))
                                                                  )
                                                               ) >=0
                                                             )
                                                           ) >=0"/>
            <bool id="enable_rx_tx_irq" label="Enable Rx/Tx interrupt" available="$parent.var_shared_IRQn_rx_tx.value() == `true`"/>
            <reference id="interrupt_rx_tx" label="Rx/Tx Interrupt" type="interrupt_vector_t" config_set_id="fsl_interrupt_peripheral" component_id="system" options="irq_function=serial_rx_tx" enable="$parent.enable_rx_tx_irq.getValue()" available="$parent.enable_rx_tx_irq.isAvailable()">
               <options_expr>
                  <option id="irq_handler_insert" expr="
leftPadding(`uint32_t intStatus;`, 1) + `&#10;` +
leftPadding(`/* Reading all interrupt flags of status registers */`, 1) + `&#10;` +
leftPadding(`intStatus = LPUART_GetStatusFlags(` + $configSet.inst_peripheral_ID.getValue() + `);`, 1) + `&#10;&#10;` +
leftPadding(`/* Flags can be cleared by reading the status register and reading/writing data registers.`,1) + `&#10;` +
leftPadding(`See the reference manual for details of each flag.`, 2) + `&#10;` +
leftPadding(`The LPUART_ClearStatusFlags() function can be also used for clearing of flags in case the content of data/FIFO regsiter is not used.`, 2) + `&#10;` +
leftPadding(`For example:`, 2) + `&#10;` +
leftPadding(`status_t status;`, 4) + `&#10;` +
leftPadding(`status = LPUART_ClearStatusFlags(` + $configSet.inst_peripheral_ID.getValue() + `, intStatus);`, 4) + `&#10;` +
leftPadding(`*/`, 1) + `&#10;&#10;` +
leftPadding(`/* Place your code here */`, 1) + `&#10;`
                  "/>
               </options_expr>
            </reference>
            <bool id="enable_rx_irq" label="Enable Rx interrupt" available="!$parent.enable_rx_tx_irq.isAvailable()"/>
            <reference id="interrupt_rx" label="Rx Interrupt" type="interrupt_vector_t" config_set_id="fsl_interrupt_peripheral" component_id="system" options="irq_function=serial_rx" enable="$parent.enable_rx_irq.getValue()" available="!$parent.enable_rx_tx_irq.isAvailable()">
               <options_expr>
                  <option id="irq_handler_insert" expr="
leftPadding(`uint32_t intStatus;`, 1) + `&#10;` +
leftPadding(`/* Reading all interrupt flags of status registers */`, 1) + `&#10;` +
leftPadding(`intStatus = LPUART_GetStatusFlags(` + $configSet.inst_peripheral_ID.getValue() + `);`, 1) + `&#10;&#10;` +
leftPadding(`/* Flags can be cleared by reading the status register and reading/writing data registers.`,1) + `&#10;` +
leftPadding(`See the reference manual for details of each flag.`, 2) + `&#10;` +
leftPadding(`The LPUART_ClearStatusFlags() function can be also used for clearing of flags in case the content of data/FIFO regsiter is not used.`, 2) + `&#10;` +
leftPadding(`For example:`, 2) + `&#10;` +
leftPadding(`status_t status;`, 4) + `&#10;` +
leftPadding(`intStatus &amp;= ~(kLPUART_TransmissionCompleteFlag | kLPUART_TxDataRegEmptyFlag | LPUART_STAT_BRK13_MASK);`, 4) + `&#10;` +
leftPadding(`status = UART_ClearStatusFlags(` + $configSet.inst_peripheral_ID.getValue() + `, intStatus);`, 4) + `&#10;` +
leftPadding(`*/`, 1) + `&#10;&#10;` +
leftPadding(`/* Place your code here */`, 1) + `&#10;`
                  "/>
               </options_expr>
            </reference>
            <bool id="enable_tx_irq" label="Enable Tx interrupt" available="!$parent.enable_rx_tx_irq.isAvailable()"/>
            <reference id="interrupt_tx" label="Tx Interrupt" type="interrupt_vector_t" config_set_id="fsl_interrupt_peripheral" component_id="system" options="irq_function=serial_tx" enable="$parent.enable_tx_irq.getValue()" available="!$parent.enable_rx_tx_irq.isAvailable()">
               <options_expr>
                  <option id="irq_handler_insert" expr="
leftPadding(`uint32_t intStatus;`, 1) + `&#10;` +
leftPadding(`/* Reading all interrupt flags of status registers */`, 1) + `&#10;` +
leftPadding(`intStatus = LPUART_GetStatusFlags(` + $configSet.inst_peripheral_ID.getValue() + `);`, 1) + `&#10;&#10;` +
leftPadding(`/* Flags can be cleared by reading the status register and reading/writing data registers.`,1) + `&#10;` +
leftPadding(`See the reference manual for details of each flag.`, 2) + `&#10;` +
leftPadding(`The LPUART_ClearStatusFlags() function can be also used for clearing of flags in case the content of data/FIFO regsiter is not used.`, 2) + `&#10;` +
leftPadding(`For example:`, 2) + `&#10;` +
leftPadding(`status_t status;`, 4) + `&#10;` +
leftPadding(`intStatus &amp;= (kLPUART_TransmissionCompleteFlag | kLPUART_TxDataRegEmptyFlag | LPUART_STAT_BRK13_MASK);`, 4) + `&#10;` +
leftPadding(`status = UART_ClearStatusFlags(` + $configSet.inst_peripheral_ID.getValue() + `, intStatus);`, 4) + `&#10;` +
leftPadding(`*/`, 1) + `&#10;&#10;` +
leftPadding(`/* Place your code here */`, 1) + `&#10;`
                  "/>
               </options_expr>
            </reference>
         </struct>
         <variable id="inst_ID" value="$instance.getFnGroupPrefix() + $instance.getID()"></variable>
         <variable id="inst_ID_def" value="toUpperCase($parent.inst_ID.getValue())"></variable>
         <variable id="inst_peripheral_ID" value="$parent.inst_ID_def.getValue() + `_PERIPHERAL`"></variable>
      </settings>
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="fsl_interrupt_peripheral"/>
            <from component_id="system" config_set_id="common_code_templates"/>
         </import>
      </fragment_defs>
      <code>
         <section target="defines">
            <!-- RX/TX interrupt definitions -->
            <fragment id="IRQ_definitions" if_expr="$this.interrupt_vectors.enable_rx_tx_irq.isAvailable()" apply_to="$this.interrupt_vectors.interrupt_rx_tx"/>
            <fragment id="IRQ_definitions" if_expr="$this.interrupt_vectors.enable_rx_irq.isAvailable()" apply_to="$this.interrupt_vectors.interrupt_rx"/>
            <fragment id="IRQ_definitions" if_expr="$this.interrupt_vectors.enable_tx_irq.isAvailable()" apply_to="$this.interrupt_vectors.interrupt_tx"/>
         </section>                  
         <section target="init_function_body">
            <expr>leftPadding(`LPUART_EnableInterrupts(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL, `) + (($this.interrupts.getCValue()==``) ? `0` : $this.interrupts.getCValue()) + `);`, 1)</expr><br/>
            <!-- RX/TX interrupt initialization -->
            <fragment id="IRQn_set_priority_default" if_expr="$this.interrupt_vectors.enable_rx_tx_irq.isAvailable() &amp;&amp; $this.interrupt_vectors.enable_rx_tx_irq.getValue()" apply_to="$this.interrupt_vectors.interrupt_rx_tx"/>
            <fragment id="IRQn_enable_default" if_expr="$this.interrupt_vectors.enable_rx_tx_irq.isAvailable() &amp;&amp; $this.interrupt_vectors.enable_rx_tx_irq.getValue()" apply_to="$this.interrupt_vectors.interrupt_rx_tx"/>
            
            <fragment id="IRQn_set_priority_default" if_expr="$this.interrupt_vectors.enable_rx_irq.isAvailable() &amp;&amp; $this.interrupt_vectors.enable_rx_irq.getValue()" apply_to="$this.interrupt_vectors.interrupt_rx"/>
            <fragment id="IRQn_enable_default" if_expr="$this.interrupt_vectors.enable_rx_irq.isAvailable() &amp;&amp; $this.interrupt_vectors.enable_rx_irq.getValue()" apply_to="$this.interrupt_vectors.interrupt_rx"/>
           
            <fragment id="IRQn_set_priority_default" if_expr="$this.interrupt_vectors.enable_tx_irq.isAvailable() &amp;&amp; $this.interrupt_vectors.enable_tx_irq.getValue()" apply_to="$this.interrupt_vectors.interrupt_tx"/>
            <fragment id="IRQn_enable_default" if_expr="$this.interrupt_vectors.enable_tx_irq.isAvailable() &amp;&amp; $this.interrupt_vectors.enable_tx_irq.getValue()" apply_to="$this.interrupt_vectors.interrupt_tx"/>
         </section>
      </code>
      <quick_selections>
         <quick_selection id="QuickSelection1" label="Rx/Tx interrupts enabled">
            <set id="interrupts.kLPUART_TxDataRegEmptyInterruptEnable">true</set>
            <set id="interrupts.kLPUART_TransmissionCompleteInterruptEnable">true</set>
            <set id="interrupts.kLPUART_RxDataRegFullInterruptEnable">true</set>
            <set id="interrupts.kLPUART_RxOverrunInterruptEnable">true</set>
            <set id="interrupt_vectors.enable_rx_tx_irq">true</set>
            <set id="interrupt_vectors.enable_rx_irq">true</set>
            <set id="interrupt_vectors.enable_tx_irq">true</set>
         </quick_selection>
         <quick_selection id="QuickSelection2" label="Rx/Tx and error interrupts">
            <set id="interrupts.kLPUART_TxDataRegEmptyInterruptEnable">true</set>
            <set id="interrupts.kLPUART_TransmissionCompleteInterruptEnable">true</set>
            <set id="interrupts.kLPUART_RxDataRegFullInterruptEnable">true</set>
            <set id="interrupts.kLPUART_RxOverrunInterruptEnable">true</set>
            <set id="interrupts.kLPUART_NoiseErrorInterruptEnable">true</set>
            <set id="interrupts.kLPUART_FramingErrorInterruptEnable">true</set>
            <set id="interrupts.kLPUART_ParityErrorInterruptEnable">true</set>
            <set id="interrupts.kLPUART_RxFifoOverflowInterruptEnable">true</set>
            <set id="interrupts.kLPUART_TxFifoOverflowInterruptEnable">true</set>
            <set id="interrupts.kLPUART_RxFifoUnderflowInterruptEnable">true</set>
            <set id="interrupt_vectors.enable_rx_tx_irq">true</set>
            <set id="interrupt_vectors.enable_rx_irq">true</set>
            <set id="interrupt_vectors.enable_tx_irq">true</set>
            </quick_selection>
         <default>QuickSelection1</default>
      </quick_selections>
   </config_set>
   
   <config_set id="transferCfg" label="Transfer configuration" from_source="src/fsl_lpuart.h">
      <description>LPUART transfer mode configuration.</description>
      <generated_types>
      </generated_types>
      <user_types>
         <struct id="lpuart_transfer_cfg" label="LPUART transfer structure." from="_lpuart_transfer">
               <info id="data" label="The ID of the buffer" value="$instance.getFnGroupPrefix() + $instance.getID() + `_` +  ($parent.hasOption(`function`) ? $parent.optionValue(`function`) : ``) + `Buffer`">
               <description>The ID of data buffer to be transfered.</description>
            </info>
            <integer id="data_size" label="Buffer size in bytes" type="uint16_t" min_expr="1">
               <description>The size of the buffer (number of bytes that are transfered.</description>
            </integer>
         </struct>
         <struct id="transfer_config" label="Transfer configuration">
            <info id="transfer_handle" label="Transfer handle ID" value="$instance.getFnGroupPrefix() + $instance.getID() + `_handle`"/>
            <bool id="init_rx_transfer" label="Initialization of Rx transfer structure"></bool>
            <reference id="rx_transfer" label="Rx transfer" type="lpuart_transfer_cfg" options="function=rx" enable="$parent.init_rx_transfer.getValue()"/>
            <bool id="init_tx_transfer" label="Initialization of Tx transfer structure"></bool>
            <reference id="tx_transfer" label="Tx transfer" type="lpuart_transfer_cfg" options="function=tx" enable="$parent.init_tx_transfer.getValue()"/>
            <bool id="init_callback" label="Initialization of transfer callback"></bool>
            <string id="callback_fcn" label="Transfer callback function name" enable="$parent.init_callback.getValue()">
               <description>The callback function name that is used in the transfer initialization. User must provide the definition of this function. This item is optional for the transfer mode initialization.</description>
               <validation>
                  <constraint when_expr="$parent.init_callback.getValue() &amp;&amp; ($this.getValue() != ``)" cond_expr="isCIdentifier($this.getValue())" level="error" description="The callback function name must be a valid identifier."/> 
                  <constraint when_expr="$parent.init_callback.getValue()" cond_expr="$this.getValue()!=``" level="error" description="The callback function shall be defined. If the callback function is not used uncheck the Initialization of transfer callback option."/> 
               </validation>
            </string>
            <string id="user_data" label="User data pointer" enable="$parent.init_callback.getValue()">
<!--               <string id="user_data" label="User data pointer" enable="$parent.callback_fcn.getValue()!=``">-->
                  <description>Definition of the user data pointer ID. When empty the NULL is provided in the initializaton function for the callback function.</description>
                <validation>
                    <constraint when_expr="$parent.init_callback.getValue()" cond_expr="(($this.getValue() == ``) || isCIdentifier($this.getValue()))" level="error" description="The user data pointer is not valid C identifier."/>
                </validation>
            </string>
         </struct>
      </user_types>
      <settings>
         <reference id="transfer" label="Transfer" type="transfer_config"/>
         <variable id="var_shared_IRQn_rx_tx_transfer" value="getResource(
            `interrupts`, 
            $instance.getCoreId()
            ).searchInArray
            ( varItem -> 
            (   
            ((varItem.getSetting(`devices`).searchInArray
            (
            item -> (item.getSetting(`function`).getValue() == `serial_rx` &amp;&amp; (item.getSetting(`id`).getValue() == $instance.getPeripheral()))
            )
            ) >=0
            &amp;&amp;
            (varItem.getSetting(`devices`).searchInArray
            (
            item -> (item.getSetting(`function`).getValue() == `serial_tx` &amp;&amp; (item.getSetting(`id`).getValue() == $instance.getPeripheral()))
            )
            ) >=0)
            ||
            (varItem.getSetting(`devices`).searchInArray
            (
            item -> (item.getSetting(`function`).getValue() == `serial_rx_tx` &amp;&amp; (item.getSetting(`id`).getValue() == $instance.getPeripheral()))
            )
            ) >=0
            )
            ) >=0"/>
         <reference id="interrupt_rx_tx" label="Rx/Tx interrupt priority setting" type="interrupt_vector_t" config_set_id="fsl_interrupt_peripheral" component_id="system" options="irq_without_enable_control;without_handler_settings" available="$parent.var_shared_IRQn_rx_tx_transfer.value() == `true`">
            <description>Configuration of Rx/Tx interrupt priority (by default FreeRTOS sets interrupt to lower priority than the default level).</description>
         </reference>
         <reference id="interrupt_rx" label="Rx interrupt priority setting" type="interrupt_vector_t" config_set_id="fsl_interrupt_peripheral" component_id="system" options="irq_function=serial_rx;irq_without_enable_control;without_handler_settings" available="!$parent.interrupt_rx_tx.isAvailable()">
            <description>Configuration of RX interrupt priority (by default FreeRTOS sets interrupt to lower priority than the default level).</description>
         </reference>
         <reference id="interrupt_tx" label="Tx interrupt priority setting" type="interrupt_vector_t" config_set_id="fsl_interrupt_peripheral" component_id="system" options="irq_function=serial_tx;irq_without_enable_control;without_handler_settings" available="!$parent.interrupt_rx_tx.isAvailable()">
            <description>Configuration of TX interrupt priority (by default FreeRTOS sets interrupt to lower priority than the default level).</description>
         </reference>
      </settings>
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="common_code_templates"/>
            <from component_id="system" config_set_id="fsl_interrupt_peripheral"/>
         </import>
         <def fragment="transfer_struct">
            <text>const </text><expr>$param.type + ` ` + $param.name</expr><text> = {</text><br/>
            <expr>`  .data = ` + $param.bufferID + `,`</expr><br/>  
            <expr>`  .dataSize = ` + $param.bufferSize</expr><br/>
            <text>};</text><br/>
         </def>
         <def fragment="rx_buffer_size">
            <expr>toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_` + $instance.transferCfg.transfer.rx_transfer.optionValue(`function`) + `_BUFFER_SIZE`)</expr>
         </def>
      </fragment_defs>
      <code>
         <section target="defines">
            <!-- RX/TX transfer buffer size -->
            <fragment id="define" if_expr="$this.transfer.init_rx_transfer.getValue()">
<!--               <param id="name" expr="$instance.getFnGroupName().toUpperCase() + `_` + $instance.getID().toUpperCase() + `_` + $this.transfer.rx_transfer.optionValue(`function`).toUpperCase() + `_BUFFER_SIZE`"/>-->
               <param id="name" expr="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_` + $this.transfer.rx_transfer.optionValue(`function`) + `_BUFFER_SIZE`)"/>
               <param id="value" expr="$this.transfer.rx_transfer.data_size.getCValue()"/> <!-- The getValue() function must be used to provide the symbol name (getCValue() return a string) -->
               <param id="description">Rx transfer buffer size.</param>
            </fragment>
            <fragment id="define" if_expr="$this.transfer.init_tx_transfer.getValue()">
               <param id="name" expr="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_` + $this.transfer.tx_transfer.optionValue(`function`) + `_BUFFER_SIZE`)"/>
               <param id="value" expr="$this.transfer.tx_transfer.data_size.getCValue()"/> <!-- The getValue() function must be used to provide the symbol name (getCValue() return a string) -->
               <param id="description">Rx transfer buffer size.</param>
            </fragment>
            <fragment id="IRQ_definitions"  if_expr="$this.interrupt_rx_tx.isAvailable()" apply_to="$this.interrupt_rx_tx"/>
            <fragment id="IRQ_definitions"  if_expr="$this.interrupt_rx.isAvailable()" apply_to="$this.interrupt_rx"/>
            <fragment id="IRQ_definitions"  if_expr="$this.interrupt_tx.isAvailable()" apply_to="$this.interrupt_tx"/>
            <!-- Error interrupt definitions -->
<!--            <fragment id="define" if_expr="$this.interrupt_vectors.enable_err_irq.getValue()">
               <param id="name" expr="$instance.getFnGroupName() + `_` + $instance.getID() + `_` + $this.interrupt_vectors.interrupt_err.optionValue(`irq_function`) + `_IRQn`"/>
               <param id="value" expr="$this.interrupt_vectors.interrupt_err.IRQn.getValue()"/> <!-\- The getValue() function must be used to provide the symbol name (getCValue() return a string) -\->
               <param id="description">UART Error interrupt vector ID (number).</param>
            </fragment>
            <fragment id="define" if_expr="$this.interrupt_vectors.enable_err_irq.getValue()">
               <param id="name" expr="$instance.getFnGroupName() + `_` + $instance.getID() + `_` + $this.interrupt_vectors.interrupt_err.optionValue(`irq_function`) + `_IRQ_PRIORITY`"/>
               <param id="value" expr="$this.interrupt_vectors.interrupt_err.priority.getCValue()"/>
               <param id="description">UART Error interrupt vector priority.</param>
            </fragment>
            <fragment id="define" if_expr="$this.interrupt_vectors.enable_err_irq.getValue()">
               <param id="name" expr="$instance.getFnGroupName() + `_` + $instance.getID() + `_` + $this.interrupt_vectors.interrupt_err.optionValue(`irq_function`) + `_IRQHandler`"/>
               <param id="value" expr="$instance.getPeripheral() + `_` + $this.interrupt_vectors.interrupt_err.optionValue(`irq_function`) + `_IRQHandler`"/>
               <param id="description">UART error interrupt handler identifier.</param>
            </fragment>-->
         </section> 
         <section target="global_vars">
            <!-- Transfer handle definition -->
            <fragment id="global_var" apply_to="$this.transfer.transfer_handle">
               <param id="name" expr="$this.getValue()" />
               <param id="type">lpuart_handle_t</param>
            </fragment>
            <!-- Rx transfer buffer definition -->
            <fragment id="global_var_array" apply_to="$this.transfer.rx_transfer" if_expr="$this.transfer.init_rx_transfer.getValue()">
               <param id="name" expr="$this.data.getValue()" />
               <param id="size" expr="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_` + $this.optionValue(`function`) + `_BUFFER_SIZE`)"/>
               <param id="type">uint8_t</param>
            </fragment>
            <!-- RX transfer structures -->
            <fragment id="transfer_struct" if_expr="$this.transfer.init_rx_transfer.getValue()">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_rxTransfer`"/>
               <param id="type">lpuart_transfer_t</param>
               <param id="bufferID" expr="$this.transfer.rx_transfer.data.getValue()"/>
               <param id="bufferSize" expr="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_` + $this.transfer.rx_transfer.optionValue(`function`) + `_BUFFER_SIZE`)"/>
            </fragment>
            <!-- Tx transfer buffer definition -->
            <fragment id="global_var_array" apply_to="$this.transfer.tx_transfer" if_expr="$this.transfer.init_tx_transfer.getValue()">
               <param id="name" expr="$this.data.getValue()" />
               <param id="size" expr="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_` + $this.optionValue(`function`) + `_BUFFER_SIZE`)"/>
               <param id="type">uint8_t</param>
            </fragment>
            <!-- TX transfer structures -->
            <fragment id="transfer_struct" if_expr="$this.transfer.init_tx_transfer.getValue()">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_txTransfer`"/>
               <param id="type">lpuart_transfer_t</param>
               <param id="bufferID" expr="$this.transfer.tx_transfer.data.getValue()"/>
               <param id="bufferSize" expr="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_` + $this.transfer.tx_transfer.optionValue(`function`) + `_BUFFER_SIZE`)"/>
            </fragment>
         </section>
         <section target="global_vars_extern">
            <!-- Transfer handle definition -->
            <fragment id="extern_var" apply_to="$this.transfer.transfer_handle">
               <param id="name" expr="$this.getValue()" />
               <param id="type">lpuart_handle_t</param>
            </fragment>
            <!-- Rx transfer buffer definition -->
            <fragment id="extern_var_array" apply_to="$this.transfer.rx_transfer" if_expr="$this.transfer.init_rx_transfer.getValue()">
               <param id="name" expr="$this.data.getValue()" />
               <param id="size" expr="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_` + $this.optionValue(`function`) + `_BUFFER_SIZE`)"/>
               <param id="type">uint8_t</param>
            </fragment>
            <!-- RX transfer structures -->
            <fragment id="extern_const_var" if_expr="$this.transfer.init_rx_transfer.getValue()">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_rxTransfer`"/>
               <param id="type">lpuart_transfer_t</param>
            </fragment>
            <!-- Tx transfer buffer definition -->
            <fragment id="extern_var_array" apply_to="$this.transfer.tx_transfer" if_expr="$this.transfer.init_tx_transfer.getValue()">
               <param id="name" expr="$this.data.getValue()" />
               <param id="size" expr="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_` + $this.optionValue(`function`) + `_BUFFER_SIZE`)"/>
               <param id="type">uint8_t</param>
            </fragment>
            <!-- TX transfer structures -->
            <fragment id="extern_const_var" if_expr="$this.transfer.init_tx_transfer.getValue()">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_txTransfer`"/>
               <param id="type">lpuart_transfer_t</param>
            </fragment>
            <!-- user data pointer of the callback function -->
            <fragment id="extern_var" if_expr="$this.transfer.init_callback.getValue() &amp;&amp; ($this.transfer.user_data.getValue() != ``)">
               <param id="name" expr="$this.transfer.user_data.getValue()"/>
               <param id="type" expr="`void *`"/>
            </fragment>
         </section>
            <!-- Transfer callback function declaration -->
<!--            void UART_UserCallback(UART_Type *base, uart_handle_t *handle, status_t status, void *userData)-->
            <section target="callback_function_extern">
               <fragment id="extern_fcn_def" if_expr="$this.transfer.init_callback.getValue()">
               <param id="name" expr="$this.transfer.callback_fcn.getValue()"/>
               <param id="type">void</param>
               <param id="params">LPUART_Type *base, lpuart_handle_t *handle, status_t status, void *userData</param>
               <param id="description" expr="`LPUART transfer callback function for the ` + $instance.getID() +` component (init. function `+ $instance.getFnGroupName() + `)` "/>
            </fragment>
         </section>
         <section target="init_function_body">
<!--                 LPUART_TransferCreateHandle(LPUARTx, &g_uartHandle, LPUART_UserCallback, NULL /* user data ptr */);-->
            <expr>leftPadding(`LPUART_TransferCreateHandle(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL, &amp;`) +  $this.transfer.transfer_handle.getValue() + `, ` + ($this.transfer.init_callback.getValue() ? $this.transfer.callback_fcn.getValue() : `NULL`   ) + `, ` + (($this.transfer.init_callback.getValue() &amp;&amp; ($this.transfer.user_data.getValue()!=``)) ? $this.transfer.user_data.getValue() : `NULL`)  + `);`, 1)</expr><br/>
            <fragment id="IRQn_set_priority_default" if_expr="$this.interrupt_rx_tx.isAvailable()" apply_to="$this.interrupt_rx_tx"/>
            <fragment id="IRQn_set_priority_default" if_expr="$this.interrupt_rx.isAvailable()" apply_to="$this.interrupt_rx"/>
            <fragment id="IRQn_set_priority_default" if_expr="$this.interrupt_tx.isAvailable()" apply_to="$this.interrupt_tx"/>
         </section>
      </code>
      <quick_selections>
         <quick_selection id="QuickSelection1" label="Rx/Tx transfer enabled">
            <set id="transfer.init_rx_transfer">true</set>
            <set id="transfer.rx_transfer.data_size">10</set>
            <set id="transfer.init_tx_transfer">true</set>
            <set id="transfer.tx_transfer.data_size">10</set>
         </quick_selection>
         <default>QuickSelection1</default>
      </quick_selections>
   </config_set>
   <!-- eDMA mode -->
   <config_set id="edmaCfg" label="eDMA configuration" from_source="src/fsl_lpuart_edma.h">
      <description>LPUART transfer mode configuration.</description>
      <generated_types>
         <struct id="lpuart_edma_handle_t" label="" from="_lpuart_edma_handle">
            <reference id="callback" label="Callback function" type="lpuart_edma_transfer_callback_t">
               <description>Callback function.</description>
            </reference>
            <fixme id="userData" label="LPUART callback function parameter" type="void *">
               <description>LPUART callback function parameter.</description>
            </fixme>
            <fixme id="rxDataSizeAll" label="Size of the data to receive" type="size_t">
               <description>Size of the data to receive.</description>
            </fixme>
            <fixme id="txDataSizeAll" label="Size of the data to send out" type="size_t">
               <description>Size of the data to send out.</description>
            </fixme>
            <fixme id="txEdmaHandle" label="The eDMA TX channel used" type="edma_handle_t *">
               <description>The eDMA TX channel used.</description>
            </fixme>
            <fixme id="rxEdmaHandle" label="The eDMA RX channel used" type="edma_handle_t *">
               <description>The eDMA RX channel used.</description>
            </fixme>
            <integer id="nbytes" label="eDMA minor byte transfer count initially configured" type="uint8_t">
               <description>eDMA minor byte transfer count initially configured.</description>
            </integer>
            <integer id="txState" label="TX transfer state" type="uint8_t">
               <description>TX transfer state.</description>
            </integer>
            <integer id="rxState" label="RX transfer state" type="uint8_t">
               <description>RX transfer state</description>
            </integer>
         </struct>
         <fixme id="lpuart_edma_transfer_callback_t" label="LPUART transfer callback function" type="void(*"/>
      </generated_types>
      <user_types>
         <struct id="lpuart_edma_t" label="LPUART eDMA handle type" public="true">
            <bool id="enable_custom_name" label="Enable LPUART custom handle name">
               <description>When this option is enabled a user custom name of the DMA handle is allowed to set in the settings below.
               </description>
            </bool>
            <string id="handle_custom_name" label="Handle name" available="$parent.enable_custom_name.getValue()">
               <description>The eDMA handle is used for processing of DMA requests. </description>
               <validation>
                  <constraint cond_expr="isCIdentifier($this.getValue())" level="error" description_expr="`The handle name: `+ $this.getCValue() +` is not valid C identifier!`"/>
                  <constraint cond_expr="$components.system.#global.duplicit_ids.getValue().noneMatch(x -> x.getValue() == $this.getValue())" level="warning" description_expr="`The handle name ` + $this.getValue() + ` is a duplicate.`"/>  
               </validation>
            </string>
            <info id="handle_default_name" label="Handle name" value="$parent.enable_custom_name.getValue() ? $parent.handle_custom_name.getValue() : 
               $instance.getFnGroupPrefix() + $instance.getID() + 
               `_LPUART_eDMA_Handle`" available="!$parent.enable_custom_name.getValue()">
               <validation>
                  <constraint cond_expr="isCIdentifier($this.getValue())" level="error" description_expr="`The handle name: `+ $this.getCValue() +` is not valid C identifier!`"/>
                  <constraint cond_expr="$components.system.#global.duplicit_ids.getValue().noneMatch(x -> x.getValue() == $this.getValue())" level="warning" description_expr="`The handle name ` + $this.getValue() + ` is a duplicate.`"/>  
               </validation>
            </info>
            <variable id="lpuart_eDMA_handle_id" value="$parent.enable_custom_name.getValue() ? $parent.handle_custom_name.getValue() : $parent.handle_default_name.getValue()" options="id_check"></variable>
            <bool id="init_callback" label="Initialization of eDMA callback"></bool>
            <string id="callback_fcn" label="Transfer callback function name" enable="$parent.init_callback.getValue()">
               <description>The callback function name that is used in the eDMA initialization. User must provide the definition of this function. This item is optional for the eDMA mode initialization.</description>
               <validation>
                  <constraint when_expr="$parent.init_callback.getValue()" cond_expr="$this.getValue() != ``" level="error" description="The callback function shall be defined. If the callback function is not used uncheck the Initialization of eDMA callback option."/> 
                  <constraint when_expr="$parent.init_callback.getValue() &amp;&amp; ($this.getValue() != ``)" cond_expr="isCIdentifier($this.getValue())" level="error" description="The callback function name must be a valid identifier."/> 
               </validation>
            </string>
            <string id="user_data" label="User data pointer" enable="$parent.init_callback.getValue()">
               <!--               <string id="user_data" label="User data pointer" enable="$parent.callback_fcn.getValue()!=``">-->
               <description>Definition of the user data pointer ID. When empty the NULL is provided in the initializaton function for the callback function.</description>
               <validation>
                  <constraint when_expr="$parent.init_callback.getValue()" cond_expr="(($this.getValue() == ``) || isCIdentifier($this.getValue()))" level="error" description="The user data pointer is not valid C identifier."/>
               </validation>
            </string>
         </struct>
      </user_types>
      <settings>
         <struct id="edma_channels" label="eDMA channels">
            <bool id="enable_rx_edma_channel" label="Enable Rx eDMA channel"></bool>
            <reference id="edma_rx_channel" label="Rx eDMA channel" type="edma_channel_t" config_set_id="fsl_edma_peripheral" component_id="system" options="dma_function=RX" enable="$parent.enable_rx_edma_channel.getValue()"/>
            <bool id="enable_tx_edma_channel" label="Enable Tx eDMA channel"></bool>
            <reference id="edma_tx_channel" label="Tx eDMA channel" type="edma_channel_t" config_set_id="fsl_edma_peripheral" component_id="system" options="dma_function=TX" enable="$parent.enable_tx_edma_channel.getValue()"/>
         </struct>
         <reference id="lpuart_edma_handle" label="LPUART eDMA handle" type="lpuart_edma_t"/>
      </settings>
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="common_code_templates"/>
            <from component_id="system" config_set_id="fsl_edma_peripheral"/>
         </import>
         <def fragment="LPUART_eDMA_transfer_handle_init" public="true">
            <expr>leftPadding(`/* Create the LPUART eDMA handle */`,1)</expr><br/>
            <expr>leftPadding(`LPUART_TransferCreateHandleEDMA(`, 1) + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL, `) 
               + `&amp;` + $this.lpuart_edma_handle.lpuart_eDMA_handle_id.getValue() + `, ` +
               + ($this.lpuart_edma_handle.init_callback.getValue() ? $this.lpuart_edma_handle.callback_fcn.getValue() : `NULL`) + `, `  
               + (($this.lpuart_edma_handle.init_callback.getValue() &amp;&amp; ($this.lpuart_edma_handle.user_data.getValue() != ``)) ? $this.lpuart_edma_handle.user_data.getValue() : `NULL`) + `, `  
               + ($this.edma_channels.enable_tx_edma_channel.getValue() ? (`&amp;` + $this.edma_channels.edma_tx_channel.eDMA_handle.getValue()) : `NULL`) + `, `
               + ($this.edma_channels.enable_rx_edma_channel.getValue() ? (`&amp;` + $this.edma_channels.edma_rx_channel.eDMA_handle.getValue()) : `NULL`) +
               + `);`</expr><br/>
         </def>
      </fragment_defs>
      <code>
         <section target="includes">
            <fragment id="include">
               <param id="name">lpuart</param>
               <param id="filename">fsl_lpuart_edma.h</param>
            </fragment>
         </section>
         <section target="defines">            
            <!-- RX -->
            <fragment id="DMA_definitions" apply_to="$this.edma_channels.edma_rx_channel" if_expr="$this.edma_channels.enable_rx_edma_channel.getValue()"/>
            <!-- TX -->
            <fragment id="DMA_definitions" apply_to="$this.edma_channels.edma_tx_channel" if_expr="$this.edma_channels.enable_tx_edma_channel.getValue()"/>
         </section> 
         <section target="global_vars">
            <!-- RX -->
            <fragment id="DMA_handle_definition" apply_to="$this.edma_channels.edma_rx_channel" if_expr="$this.edma_channels.enable_rx_edma_channel.getValue()"/>
            <!-- TX -->
            <fragment id="DMA_handle_definition" apply_to="$this.edma_channels.edma_tx_channel" if_expr="$this.edma_channels.enable_tx_edma_channel.getValue()"/>
            <!-- UART eDMA handle -->
            <fragment id="global_var">
               <param id="name" expr="$this.lpuart_edma_handle.lpuart_eDMA_handle_id.getValue()"/>
               <param id="type" expr="`lpuart_edma_handle_t`"/>
            </fragment>
         </section>   
         <section target="global_vars_extern">
            <!-- RX -->
            <fragment id="DMAMUX_handle_declaration" apply_to="$this.edma_channels.edma_rx_channel" if_expr="$this.edma_channels.enable_rx_edma_channel.getValue()"/>
            <!-- TX -->
            <fragment id="DMAMUX_handle_declaration" apply_to="$this.edma_channels.edma_tx_channel" if_expr="$this.edma_channels.enable_tx_edma_channel.getValue()"/>
            <!-- user data pointer of the callback function -->
            <fragment id="extern_var" if_expr="$this.lpuart_edma_handle.init_callback.getValue() &amp;&amp; ($this.lpuart_edma_handle.user_data.getValue() != ``)">
               <param id="name" expr="$this.lpuart_edma_handle.user_data.getValue()"/>
               <param id="type" expr="`void *`"/>
            </fragment>
            <!-- UART eDMA handle -->
            <fragment id="extern_var">
               <param id="name" expr="$this.lpuart_edma_handle.lpuart_eDMA_handle_id.getValue()"/>
               <param id="type" expr="`lpuart_edma_handle_t`"/>
            </fragment>
         </section>   
         <section target="init_function_body">
            <!-- RX -->
            <fragment id="DMAMUX_source_init" apply_to="$this.edma_channels.edma_rx_channel" if_expr="$this.edma_channels.enable_rx_edma_channel.getValue()"/>
            <!-- TX -->
            <fragment id="DMAMUX_source_init" apply_to="$this.edma_channels.edma_tx_channel" if_expr="$this.edma_channels.enable_tx_edma_channel.getValue()"/>
            <!-- RX -->
            <fragment id="DMA_handle_init" apply_to="$this.edma_channels.edma_rx_channel" if_expr="$this.edma_channels.enable_rx_edma_channel.getValue()"/>
            <!-- TX -->
            <fragment id="DMA_handle_init" apply_to="$this.edma_channels.edma_tx_channel" if_expr="$this.edma_channels.enable_tx_edma_channel.getValue()"/>
            <fragment id="LPUART_eDMA_transfer_handle_init"/>
         </section> 
         <section target="callback_function_extern">
            <!-- Transfer callback function declaration -->
            <fragment id="extern_fcn_def" if_expr="$this.lpuart_edma_handle.init_callback.getValue() ">
               <param id="name" expr="$this.lpuart_edma_handle.callback_fcn.getValue()"/>
               <param id="type">void</param>
               <param id="params">LPUART_Type *,lpuart_edma_handle_t *,status_t ,void *</param>
               <param id="description" expr="`LPUART eDMA callback function for the ` + $instance.getID() +` component (init. function `+ $instance.getFnGroupName() + `)` "/>
            </fragment>
         </section>
      </code>
      <validation>
         <constraint cond_expr="$this.edma_channels.enable_rx_edma_channel.getValue() || $this.edma_channels.enable_tx_edma_channel.getValue()" level="warning" description="Both Rx and Tx eDMA requests are disabled. The eDMA transfer handles will not be initialized."/>
         <dependency resource_type="SWComponent" resource_id="platform.drivers.lpuart_edma" level="Warning" description_expr="$components.system.#global.err_missing_driver.getValue().formatMessage(`fsl_uart_edma`, ` (required for the eDMA mode)`)">
            <feature name="enabled" evaluation="equal">
               <data expr="true"/>
            </feature>
         </dependency>
         <dependency resource_type="SWComponent" resource_id="platform.drivers.lpuart_edma" level="Warning" description_expr="$components.system.#global.err_driver_version.getValue().formatMessage(`fsl_uart_edma`, ` (required for the eDMA mode)`)">
            <feature name="version" evaluation="compatible">
               <data type="Version" expr="`2.2.4`"/>
               </feature>
         </dependency>
      </validation>
      <quick_selections>
         <quick_selection id="QuickSelection1" label="Rx /Tx transfer enabled">
            <set id="edma_channels.enable_rx_edma_channel">true</set>
            <set id="edma_channels.enable_tx_edma_channel">true</set>
            <set id="edma_channels.edma_tx_channel.eDMAn">1</set>
         </quick_selection>
         <default>QuickSelection1</default>
      </quick_selections>
   </config_set>
   <!-- DMA mode -->
   <config_set id="dmaCfg" label="DMA configuration" from_source="src/fsl_lpuart_dma.h">
      <description>LPUART transfer mode configuration.</description>
      <generated_types>
         <struct id="lpuart_dma_handle_t" label="" from="_lpuart_dma_handle">
            <reference id="callback" label="Callback function" type="lpuart_dma_transfer_callback_t">
               <description>Callback function.</description>
            </reference>
            <fixme id="userData" label="LPUART callback function parameter" type="void *">
               <description>LPUART callback function parameter.</description>
            </fixme>
            <fixme id="rxDataSizeAll" label="Size of the data to receive" type="size_t">
               <description>Size of the data to receive.</description>
            </fixme>
            <fixme id="txDataSizeAll" label="Size of the data to send out" type="size_t">
               <description>Size of the data to send out.</description>
            </fixme>
            <fixme id="txDmaHandle" label="The DMA TX channel used" type="dma_handle_t *">
               <description>The DMA TX channel used.</description>
            </fixme>
            <fixme id="rxDmaHandle" label="The DMA RX channel used" type="dma_handle_t *">
               <description>The DMA RX channel used.</description>
            </fixme>
            <integer id="txState" label="TX transfer state" type="uint8_t">
               <description>TX transfer state.</description>
            </integer>
            <integer id="rxState" label="RX transfer state" type="uint8_t">
               <description>RX transfer state</description>
            </integer>
         </struct>
         <fixme id="lpuart_dma_transfer_callback_t" label="LPUART transfer callback function" type="void(*"/>
      </generated_types>
      <user_types>
         <struct id="lpuart_dma_t" label="LPUART DMA handle type" public="true">
            <bool id="enable_custom_name" label="Enable LPUART custom handle name">
               <description>When this option is enabled a user custom name of the DMA handle is allowed to set in the settings below.
               </description>
            </bool>
            <string id="handle_custom_name" label="Handle name" available="$parent.enable_custom_name.getValue()">
               <description>The DMA handle is used for processing of DMA requests. </description>
               <validation>
                  <constraint cond_expr="isCIdentifier($this.getValue())" level="error" description_expr="`The handle name: `+ $this.getCValue() +` is not valid C identifier!`"/>
                  <constraint cond_expr="$components.system.#global.duplicit_ids.getValue().noneMatch(x -> x.getValue() == $this.getValue())" level="warning" description_expr="`The handle name ` + $this.getValue() + ` is a duplicate.`"/>  
               </validation>
            </string>
            <info id="handle_default_name" label="Handle name" value="$parent.enable_custom_name.getValue() ? $parent.handle_custom_name.getValue() : 
               $instance.getFnGroupPrefix() + $instance.getID() + 
               `_LPUART_DMA_Handle`" available="!$parent.enable_custom_name.getValue()">
               <validation>
                  <constraint cond_expr="isCIdentifier($this.getValue())" level="error" description_expr="`The handle name: `+ $this.getCValue() +` is not valid C identifier!`"/>
                  <constraint cond_expr="$components.system.#global.duplicit_ids.getValue().noneMatch(x -> x.getValue() == $this.getValue())" level="warning" description_expr="`The handle name ` + $this.getValue() + ` is a duplicate.`"/>  
                </validation>
            </info>
            <variable id="lpuart_DMA_handle_id" value="$parent.enable_custom_name.getValue() ? $parent.handle_custom_name.getValue() : $parent.handle_default_name.getValue()" options="id_check"></variable>
            <bool id="init_callback" label="Initialization of DMA callback"></bool>
            <string id="callback_fcn" label="Transfer callback function name" enable="$parent.init_callback.getValue()">
               <description>The callback function name that is used in the DMA initialization. User must provide the definition of this function. This item is optional for the DMA mode initialization.</description>
               <validation>
                  <constraint when_expr="$parent.init_callback.getValue()" cond_expr="$this.getValue() != ``" level="error" description="The callback function shall be defined. If the callback function is not used uncheck the Initialization of DMA callback option."/> 
                  <constraint when_expr="$parent.init_callback.getValue() &amp;&amp; ($this.getValue() != ``)" cond_expr="isCIdentifier($this.getValue())" level="error" description="The callback function name must be a valid identifier."/> 
               </validation>
            </string>
            <string id="user_data" label="User data pointer" enable="$parent.init_callback.getValue()">
               <!--               <string id="user_data" label="User data pointer" enable="$parent.callback_fcn.getValue()!=``">-->
               <description>Definition of the user data pointer ID. When empty the NULL is provided in the initializaton function for the callback function.</description>
               <validation>
                  <constraint when_expr="$parent.init_callback.getValue()" cond_expr="(($this.getValue() == ``) || isCIdentifier($this.getValue()))" level="error" description="The user data pointer is not valid C identifier."/>
               </validation>
            </string>
         </struct>
      </user_types>
      <settings>
         <struct id="dma_channels" label="DMA channels">
            <bool id="enable_rx_dma_channel" label="Enable Rx DMA channel"></bool>
            <reference id="dma_rx_channel" label="Rx DMA channel" type="dma_channel_t" config_set_id="fsl_dma_peripheral" component_id="system" options="dma_function=RX" enable="$parent.enable_rx_dma_channel.getValue()"/>
            <bool id="enable_tx_dma_channel" label="Enable Tx DMA channel"></bool>
            <reference id="dma_tx_channel" label="Tx DMA channel" type="dma_channel_t" config_set_id="fsl_dma_peripheral" component_id="system" options="dma_function=TX" enable="$parent.enable_tx_dma_channel.getValue()"/>
         </struct>
         <reference id="lpuart_dma_handle" label="LPUART DMA handle" type="lpuart_dma_t"/>
      </settings>
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="common_code_templates"/>
            <from component_id="system" config_set_id="fsl_dma_peripheral"/>
         </import>
         <def fragment="LPUART_DMA_transfer_handle_init" public="true">
            <expr>leftPadding(`/* Create the LPUART DMA handle */`,1)</expr><br/>
            <expr>leftPadding(`LPUART_TransferCreateHandleDMA(`, 1) + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL, `) 
               + `&amp;` + $this.lpuart_dma_handle.lpuart_DMA_handle_id.getValue() + `, ` +
               + ($this.lpuart_dma_handle.init_callback.getValue() ? $this.lpuart_dma_handle.callback_fcn.getValue() : `NULL`) + `, `  
               + (($this.lpuart_dma_handle.init_callback.getValue() &amp;&amp; ($this.lpuart_dma_handle.user_data.getValue() != ``)) ? $this.lpuart_dma_handle.user_data.getValue() : `NULL`) + `, `  
               + ($this.dma_channels.enable_tx_dma_channel.getValue() ? (`&amp;` + $this.dma_channels.dma_tx_channel.DMA_handle.getValue()) : `NULL`) + `, `
               + ($this.dma_channels.enable_rx_dma_channel.getValue() ? (`&amp;` + $this.dma_channels.dma_rx_channel.DMA_handle.getValue()) : `NULL`) +
               + `);`</expr><br/>
         </def>
      </fragment_defs>
      <code>
         <section target="includes">
            <fragment id="include">
               <param id="name">lpuart</param>
               <param id="filename">fsl_lpuart_dma.h</param>
            </fragment>
         </section>
         <section target="defines">            
            <!-- RX -->
            <fragment id="DMA_definitions" apply_to="$this.dma_channels.dma_rx_channel" if_expr="$this.dma_channels.enable_rx_dma_channel.getValue()"/>
            <!-- TX -->
            <fragment id="DMA_definitions" apply_to="$this.dma_channels.dma_tx_channel" if_expr="$this.dma_channels.enable_tx_dma_channel.getValue()"/>
         </section> 
         <section target="global_vars">
            <!-- RX -->
            <fragment id="DMA_handle_definition" apply_to="$this.dma_channels.dma_rx_channel" if_expr="$this.dma_channels.enable_rx_dma_channel.getValue()"/>
            <!-- TX -->
            <fragment id="DMA_handle_definition" apply_to="$this.dma_channels.dma_tx_channel" if_expr="$this.dma_channels.enable_tx_dma_channel.getValue()"/>
            <!-- UART DMA handle -->
            <fragment id="global_var">
               <param id="name" expr="$this.lpuart_dma_handle.lpuart_DMA_handle_id.getValue()"/>
               <param id="type" expr="`lpuart_dma_handle_t`"/>
            </fragment>
         </section>   
         <section target="global_vars_extern">
            <!-- RX -->
            <fragment id="DMAMUX_handle_declaration" apply_to="$this.dma_channels.dma_rx_channel" if_expr="$this.dma_channels.enable_rx_dma_channel.getValue()"/>
            <!-- TX -->
            <fragment id="DMAMUX_handle_declaration" apply_to="$this.dma_channels.dma_tx_channel" if_expr="$this.dma_channels.enable_tx_dma_channel.getValue()"/>
            <!-- user data pointer of the callback function -->
            <fragment id="extern_var" if_expr="$this.lpuart_dma_handle.init_callback.getValue() &amp;&amp; ($this.lpuart_dma_handle.user_data.getValue() != ``)">
               <param id="name" expr="$this.lpuart_dma_handle.user_data.getValue()"/>
               <param id="type" expr="`void *`"/>
            </fragment>
            <!-- UART DMA handle -->
            <fragment id="extern_var">
               <param id="name" expr="$this.lpuart_dma_handle.lpuart_DMA_handle_id.getValue()"/>
               <param id="type" expr="`lpuart_dma_handle_t`"/>
            </fragment>
         </section>   
         <section target="init_function_body">
            <!-- RX -->
            <fragment id="DMAMUX_source_init" apply_to="$this.dma_channels.dma_rx_channel" if_expr="$this.dma_channels.enable_rx_dma_channel.getValue()"/>
            <!-- TX -->
            <fragment id="DMAMUX_source_init" apply_to="$this.dma_channels.dma_tx_channel" if_expr="$this.dma_channels.enable_tx_dma_channel.getValue()"/>
            <!-- RX -->
            <fragment id="DMA_handle_init" apply_to="$this.dma_channels.dma_rx_channel" if_expr="$this.dma_channels.enable_rx_dma_channel.getValue()"/>
            <!-- TX -->
            <fragment id="DMA_handle_init" apply_to="$this.dma_channels.dma_tx_channel" if_expr="$this.dma_channels.enable_tx_dma_channel.getValue()"/>
            <fragment id="LPUART_DMA_transfer_handle_init"/>
         </section> 
         <section target="callback_function_extern">
            <!-- Transfer callback function declaration -->
            <fragment id="extern_fcn_def" if_expr="$this.lpuart_dma_handle.init_callback.getValue() ">
               <param id="name" expr="$this.lpuart_dma_handle.callback_fcn.getValue()"/>
               <param id="type">void</param>
               <param id="params">LPUART_Type *,lpuart_dma_handle_t *,status_t ,void *</param>
               <param id="description" expr="`LPUART DMA callback function for the ` + $instance.getID() +` component (init. function `+ $instance.getFnGroupName() + `)` "/>
            </fragment>
         </section>
      </code>
      <validation>
         <constraint cond_expr="$this.dma_channels.enable_rx_dma_channel.getValue() || $this.dma_channels.enable_tx_dma_channel.getValue()" level="warning" description="Both Rx and Tx DMA requests are disabled. The DMA transfer handles will not be initialized."/>
         <dependency resource_type="SWComponent" resource_id="platform.drivers.lpuart_dma" level="Warning" description_expr="$components.system.#global.err_missing_driver.getValue().formatMessage(`fsl_uart_dma`, ` (required for the DMA mode)`)">
            <feature name="enabled" evaluation="equal">
               <data expr="true"/>
            </feature>
         </dependency>
         <dependency resource_type="SWComponent" resource_id="platform.drivers.lpuart_dma" level="Warning" description_expr="$components.system.#global.err_driver_version.getValue().formatMessage(`fsl_uart_dma`, ` (required for the DMA mode)`)">
            <feature name="version" evaluation="compatible">
               <data type="Version" expr="`2.2.4`"/>
            </feature>
         </dependency>
      </validation>
      <quick_selections>
         <quick_selection id="QuickSelection1" label="Rx /Tx transfer enabled">
            <set id="dma_channels.enable_rx_dma_channel">true</set>
            <set id="dma_channels.enable_tx_dma_channel">true</set>
            <set id="dma_channels.dma_tx_channel.DMAn">1</set>
         </quick_selection>
         <default>QuickSelection1</default>
      </quick_selections>
   </config_set>
   <!-- FreeRTOS mode -->
   <config_set id="fsl_lpuart_freertos" label="FreeRTOS configuration" from_source="fsl_lpuart_freertos.h">
      <description>FreeRTOS configuration of the LPUART</description>
      <generated_types>
         <enum id="lpuart_parity_mode_t" label="LPUART parity mode" from="_lpuart_parity_mode" from_source="fsl_lpuart.h">
            <item id="kLPUART_ParityDisabled" label="Parity disabled"/>
            <item id="kLPUART_ParityEven" label="Parity enabled, type even, bit setting: PE|PT = 10"/>
            <item id="kLPUART_ParityOdd" label="Parity enabled, type odd, bit setting: PE|PT = 11"/>
         </enum>
         <enum id="lpuart_stop_bit_count_t" label="LPUART stop bit count" from="_lpuart_stop_bit_count" from_source="fsl_lpuart.h">
            <item id="kLPUART_OneStopBit" label="One stop bit"/>
            <item id="kLPUART_TwoStopBit" label="Two stop bits"/>
         </enum>
         <struct id="lpuart_rtos_config_t" label="LPUART RTOS configuration structure" from="_lpuart_rtos_config">
            <fixme id="base" label="UART base address" type="LPUART_Type *">
               <description>UART base address</description>
            </fixme>
            <integer id="srcclk" label="UART source clock in Hz" type="uint32_t">
               <description>UART source clock in Hz</description>
            </integer>
            <integer id="baudrate" label="Desired communication speed" type="uint32_t">
               <description>Desired communication speed</description>
            </integer>
            <reference id="parity" label="Parity setting" type="lpuart_parity_mode_t">
               <description>Parity setting</description>
            </reference>
            <reference id="stopbits" label="Number of stop bits to use" type="lpuart_stop_bit_count_t">
               <description>Number of stop bits to use</description>
            </reference>
            <fixme id="buffer" label="Buffer for background reception" type="uint8_t *">
               <description>Buffer for background reception</description>
            </fixme>
            <integer id="buffer_size" label="Size of buffer for background reception" type="uint32_t">
               <description>Size of buffer for background reception</description>
            </integer>
         </struct>
      </generated_types>
      <user_types>
         <struct id="lpuart_rtos_config_t" label="LPUART configuration structure" from="_lpuart_rtos_config">
<!--            <integer id="srcclk" label="LPUART source clock frequency [Hz]" type="uint32_t" options="remove_from_struct_init">
               <description>LPUART clock source selection is part of the SIM (System Integration Module) configuration that is MCU specific. Set the value of this setting according to the configuration of the SIM device.</description>
               <validation>
                  <constraint cond_expr="$this.getValue() &gt; 0" level="error" description="The LPUART source clock freqnency must be set (non-zero value is expected)."/>
               </validation>
            </integer>-->
            <variable id="clockSourceUId" value="`LpuartClock`"/>
            <dynamic_enum id="clockSource" label="Clock source" options="remove_from_struct_init" items="createArray().addItemToList(`LpuartClock`, getPeripheralClock($instance.getPeripheral(), `LpuartClock`), ($instance.getPeripheral() + `_CLK_SRC`),true)" >
               <description>LPUART clock source.</description>
               <validation>
                  <dependency when_expr="($parent.srcclk.getEnumItemId() != `GetFreq`) &amp;&amp; ($parent.srcclk.getEnumItemId() != `custom`)" resource_type="ClockOutput" resource_id_expr="getPeripheralClockSignal($instance.getPeripheral(),$parent.clockSourceUId.getValue())"
                     description_expr="(getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()).regexMatch(`.*-.*`)?(getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()).regexSubstr(`(.*)-`,1) + `is inactive.`): (getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()) + `is inactive.`))"
                     level="Error">
                     <feature name="frequency" evaluation="greaterThan">
                        <data expr="0" unit="Hz" type="Frequency"/>
                     </feature>
                  </dependency>
               </validation>
            </dynamic_enum>
            <dynamic_enum id="srcclk" label="Clock source frequency" options="remove_from_struct_init" 
               items="getClockFunctionalGroups().arrayToEnumItems(
                     enumItem -> true,
                     enumItem -> enumItem,
                     enumItem -> frequencyToString(getPeripheralClockFrequency($instance.getPeripheral(), $parent.clockSource.getEnumItemId(), enumItem)) + ` (` + enumItem + `)`,
                     enumItem -> getPeripheralClockFrequency($instance.getPeripheral(), $parent.clockSource.getEnumItemId(), enumItem))" >
               <description>Selection of the clock source frequency. Note: LPUART clock source selection is part of the SIM (System Integration Module) configuration, see the LPUART clock settings in the Clocks tool.</description>
               <validation>
                  <constraint cond_expr="$this.getEnumItemValue() != 0" level="error" description="Clock source frequency cannot be 0 when it is used."/>
               </validation>
               <custom_value_support default="0" validation_expr="x -> x.toHertz() >= 0" />
            </dynamic_enum> 
            <integer id="baudrate" label="LPUART baud rate" type="uint32_t"  min_expr="1"/>
            <reference id="parity" label="Parity mode" type="lpuart_parity_mode_t"/>
            <reference id="stopbits" label="Number of stop bits" type="lpuart_stop_bit_count_t"/> <!-- available="featureDefined(`FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT`) &amp;&amp; getFeature(`FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT`)" -->
            <info id="buffer" label="The ID of the buffer" value="$instance.getFnGroupPrefix() + $instance.getID() + `_background_buffer`" options="add_to_struct">
               <description>The ID of data background buffer for transfers.</description>
            </info>
            <integer id="buffer_size" label="Buffer size in bytes" type="uint32_t" min_expr="1">
               <description>The size of the buffer (number of bytes that are transfered.</description>
            </integer>
         </struct>
      </user_types>
      <settings>
         <reference id="lpuart_rtos_configuration" label="LPUART RTOS Configuration" type="lpuart_rtos_config_t">
            <description>LPUART RTOS configuration.</description>
         </reference>
         <variable id="rtos_peripheral_id" value="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`)" ></variable>
<!--         <variable id="rtos_clock_source_id" value="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_CLOCK_SOURCE_FREQUENCY`)" ></variable>-->
         <variable id="buffer_size_id" value="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_BACKGROUND_BUFFER_SIZE`)" ></variable>
         <variable id="rtos_config_id" value="$instance.getFnGroupPrefix() + $instance.getID() + `_rtos_config`" ></variable>
         <variable id="rtos_handle_id" value="$instance.getFnGroupPrefix() + $instance.getID() + `_rtos_handle`" ></variable>
         <variable id="lpuart_handle_id" value="$instance.getFnGroupPrefix() + $instance.getID() + `_lpuart_handle`" ></variable>
         <variable id="var_shared_IRQn_rx_tx" value="getResource(
            `interrupts`, 
            $instance.getCoreId()
            ).searchInArray
            ( varItem -> 
            (   
            ((varItem.getSetting(`devices`).searchInArray
            (
            item -> (item.getSetting(`function`).getValue() == `serial_rx` &amp;&amp; (item.getSetting(`id`).getValue() == $instance.getPeripheral()))
            )
            ) >=0
            &amp;&amp;
            (varItem.getSetting(`devices`).searchInArray
            (
            item -> (item.getSetting(`function`).getValue() == `serial_tx` &amp;&amp; (item.getSetting(`id`).getValue() == $instance.getPeripheral()))
            )
            ) >=0)
            ||
            (varItem.getSetting(`devices`).searchInArray
            (
            item -> (item.getSetting(`function`).getValue() == `serial_rx_tx` &amp;&amp; (item.getSetting(`id`).getValue() == $instance.getPeripheral()))
            )
            ) >=0
            )
            ) >=0"/>
         <reference id="interrupt_rx_tx" label="Rx/Tx interrupt priority setting" type="interrupt_vector_t" config_set_id="fsl_interrupt_peripheral" component_id="system" options="irq_without_enable_control;without_handler_settings" available="$parent.var_shared_IRQn_rx_tx.value() == `true`">
            <description>Configuration of Rx/Tx interrupt priority (by default FreeRTOS sets interrupt to lower priority than the default level).</description>
         </reference>
         <reference id="interrupt_rx" label="Rx interrupt priority setting" type="interrupt_vector_t" config_set_id="fsl_interrupt_peripheral" component_id="system" options="irq_function=serial_rx;irq_without_enable_control;without_handler_settings" available="!$parent.interrupt_rx_tx.isAvailable()">
            <description>Configuration of RX interrupt priority (by default FreeRTOS sets interrupt to lower priority than the default level).</description>
         </reference>
         <reference id="interrupt_tx" label="Tx interrupt priority setting" type="interrupt_vector_t" config_set_id="fsl_interrupt_peripheral" component_id="system" options="irq_function=serial_tx;irq_without_enable_control;without_handler_settings" available="!$parent.interrupt_rx_tx.isAvailable()">
            <description>Configuration of TX interrupt priority (by default FreeRTOS sets interrupt to lower priority than the default level).</description>
         </reference>
      </settings>
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="fsl_interrupt_peripheral"/>
            <from component_id="system" config_set_id="common_code_templates"/>
         </import>
         <def fragment="lpuart_rtos_config_struct_init">
            <expr>`lpuart_rtos_config_t ` + $configSet.rtos_config_id.getValue() + ` = {`</expr><br/>
            <expr>leftPadding(`.base = ` + $configSet.rtos_peripheral_id.getValue() + `,`, 1)</expr><br/> 
            <fragment id="field" apply_to="$this.baudrate">
               <param id="paddingLevel" expr="1"></param>
               <param id="_last" expr="false"></param>
            </fragment>
            <expr>leftPadding(`.srcclk = ` + $this.srcclk.getEnumItemValue().toHertz() + `UL,`, 1)</expr><br/> 
            <fragment id="field" apply_to="$this.parity">
              <param id="paddingLevel" expr="1"></param>
               <param id="_last" expr="false"></param>
            </fragment>
            <fragment id="field" apply_to="$this.stopbits">
               <param id="paddingLevel" expr="1"></param>
               <param id="_last" expr="false"></param>
            </fragment>
            <fragment id="field" apply_to="$this.buffer">
               <param id="paddingLevel" expr="1"></param>
               <param id="_last" expr="false"></param>
            </fragment>
            <expr>leftPadding(`.buffer_size = ` + $configSet.buffer_size_id.getValue(), 1)</expr><br/> 
            <text>};</text><br/>
         </def>
         <def fragment="lpuart_rtos_init">
<!--            <expr>leftPadding(`/* LPUART clock source initialization */`,1)</expr><br/>-->
<!--            <expr>leftPadding($this.rtos_config_id.getValue() + `.srcclk = ` + $this.rtos_clock_source_id.getValue() + `;`,1)</expr><br/>-->
            <expr>leftPadding(`/* LPUART rtos initialization */`,1)</expr><br/>
            <expr>leftPadding(`LPUART_RTOS_Init(&amp;` + $this.rtos_handle_id.getValue() + `, &amp;` + $this.lpuart_handle_id.getValue() + `, &amp;` + $this.rtos_config_id.getValue() + `);`, 1)</expr><br/>
         </def>
      </fragment_defs>
      <code>
         <section target="includes">
            <fragment id="include">
               <param id="name">common</param>
               <param id="filename">fsl_common.h</param>
            </fragment>
            <fragment id="include">
               <param id="name">lpuart</param>
               <param id="filename">fsl_lpuart.h</param>
            </fragment>
            <fragment id="include">
               <param id="name">lpuart</param>
               <param id="filename">fsl_lpuart_freertos.h</param>
            </fragment>
            <fragment id="include">
               <param id="name">clock</param>
               <param id="filename">fsl_clock.h</param>
            </fragment>
         </section>
         <section target="defines">
            <fragment id="define">
               <param id="name" expr="$this.rtos_peripheral_id.getValue()"/>
               <param id="value" expr="$instance.getPeripheral()"/>
               <param id="description">Definition of peripheral ID</param>
            </fragment>
<!--            <fragment id="define">
               <param id="name" expr="$this.rtos_clock_source_id.getValue()"/>
<!-\-               <param id="value" expr="`CLOCK_GetFreq(` + $instance.getPeripheral() + `_CLK_SRC)`"/>-\->
               <param id="value" expr="$this.lpuart_rtos_configuration.lpuartSrcClkFreq.getCValue()+`UL`"/>
               <param id="description">Definition of the clock source frequency</param>
            </fragment>-->
            <fragment id="define">
               <param id="name" expr="$this.buffer_size_id.getValue()"/>
               <param id="value" expr="$this.lpuart_rtos_configuration.buffer_size.getValue()"/>
               <param id="description">Definition of the backround buffer size</param>
            </fragment>
            <fragment id="IRQ_definitions"  if_expr="$this.interrupt_rx_tx.isAvailable()" apply_to="$this.interrupt_rx_tx"/>
            <fragment id="IRQ_definitions"  if_expr="$this.interrupt_rx.isAvailable()" apply_to="$this.interrupt_rx"/>
            <fragment id="IRQ_definitions"  if_expr="$this.interrupt_tx.isAvailable()" apply_to="$this.interrupt_tx"/>
         </section>                  
         <section target="global_vars">
            <fragment id="global_var">
               <param id="name" expr="$this.rtos_handle_id.getValue()" />
               <param id="type" >lpuart_rtos_handle_t</param>
            </fragment>
            <fragment id="global_var">
               <param id="name" expr="$this.lpuart_handle_id.getValue()" />
               <param id="type" >lpuart_handle_t</param>
            </fragment>
            <fragment id="global_var_array">
               <param id="name" expr="$this.lpuart_rtos_configuration.buffer.getValue()" />
               <param id="size" expr="$this.buffer_size_id.getValue()" />
               <param id="type" >uint8_t</param>
            </fragment>
            <fragment id="lpuart_rtos_config_struct_init" apply_to="$this.lpuart_rtos_configuration">
               <param id="name" expr="$parent.rtos_config_id.getValue()" />
               <param id="type" >lpuart_rtos_config_t</param>
            </fragment>
         </section>
         <section target="global_vars_extern">
            <fragment id="extern_var">
               <param id="name" expr="$this.rtos_handle_id.getValue()" />
               <param id="type" >lpuart_rtos_handle_t</param>
            </fragment>
            <fragment id="extern_var">
               <param id="name" expr="$this.lpuart_handle_id.getValue()" />
               <param id="type" >lpuart_handle_t</param>
            </fragment>
            <fragment id="extern_var" apply_to="$this.lpuart_rtos_configuration">
               <param id="name" expr="$parent.rtos_config_id.getValue()" />
               <param id="type" >lpuart_rtos_config_t</param>
            </fragment>
         </section>
         <section target="init_function_body">
            <fragment id="lpuart_rtos_init"/>
            <fragment id="IRQn_set_priority_default" if_expr="$this.interrupt_rx_tx.isAvailable()" apply_to="$this.interrupt_rx_tx"/>
            <fragment id="IRQn_set_priority_default" if_expr="$this.interrupt_rx.isAvailable()" apply_to="$this.interrupt_rx"/>
            <fragment id="IRQn_set_priority_default" if_expr="$this.interrupt_tx.isAvailable()" apply_to="$this.interrupt_tx"/>
         </section>
      </code>
      <validation>
         <!-- RxD and TxD is always enabled in the RTOS mode initialization -->
         <dependency resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.uart_tx`" description_expr="$components.system.#global.err_routed_signal.getValue().formatMessage(`TX`, $instance.getPeripheral())" level="Warning">
            <feature name="routed" evaluation="equal">
               <data expr="true"/>
            </feature>
         </dependency>
         <dependency resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.uart_rx`" description_expr="$components.system.#global.err_routed_signal.getValue().formatMessage(`RX`, $instance.getPeripheral())"  level="Warning">
            <feature name="routed" evaluation="equal">
               <data expr="true"/>
            </feature>
         </dependency>
         <dependency resource_type="SWComponent" resource_id="platform.drivers.lpuart_freertos" level="Warning" description_expr="$components.system.#global.err_missing_driver.getValue().formatMessage(`fsl_uart_freertos`, ` (required for the FreeRTOS mode)`)">
            <feature name="enabled" evaluation="equal">
               <data expr="true"/>
            </feature>
         </dependency>
         <dependency resource_type="SWComponent" resource_id="platform.drivers.lpuart_freertos" level="Warning" description_expr="$components.system.#global.err_driver_version.getValue().formatMessage(`fsl_uart_freertos`, ` (required for the FreeRTOS mode)`)">
            <feature name="version" evaluation="compatible">
               <data type="Version" expr="`2.2.4`"/>
            </feature>
         </dependency>
      </validation>
      <quick_selections>
         <quick_selection id="QuickSelection1" label="115200-N,8,1">
            <set id="lpuart_rtos_configuration.baudrate">115200</set>
            <set id="lpuart_rtos_configuration.parity">kLPUART_ParityDisabled</set>
            <set id="lpuart_rtos_configuration.stopbits">kLPUART_OneStopBit</set>
         </quick_selection>
         <quick_selection id="QuickSelection2" label="57600-N,8,1">
            <set id="lpuart_rtos_configuration.baudrate">57600</set>
            <set id="lpuart_rtos_configuration.parity">kLPUART_ParityDisabled</set>
            <set id="lpuart_rtos_configuration.stopbits">kLPUART_OneStopBit</set>
         </quick_selection>
         <quick_selection id="QuickSelection3" label="38400-N,8,1">
            <set id="lpuart_rtos_configuration.baudrate">38400</set>
            <set id="lpuart_rtos_configuration.parity">kLPUART_ParityDisabled</set>
            <set id="lpuart_rtos_configuration.stopbits">kLPUART_OneStopBit</set>
         </quick_selection>
         <quick_selection id="QuickSelection4" label="19200-N,8,1">
            <set id="lpuart_rtos_configuration.baudrate">19200</set>
            <set id="lpuart_rtos_configuration.parity">kLPUART_ParityDisabled</set>
            <set id="lpuart_rtos_configuration.stopbits">kLPUART_OneStopBit</set>
         </quick_selection>
         <quick_selection id="QuickSelection5" label="9600-N,8,1">
            <set id="lpuart_rtos_configuration.baudrate">9600</set>
            <set id="lpuart_rtos_configuration.parity">kLPUART_ParityDisabled</set>
            <set id="lpuart_rtos_configuration.stopbits">kLPUART_OneStopBit</set>
         </quick_selection>
         <default>QuickSelection1</default>
      </quick_selections>
   </config_set>
</component:config_component>