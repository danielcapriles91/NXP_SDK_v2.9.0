<?xml version="1.0" encoding= "UTF-8" ?>
<component:config_component id="system" label="SYSTEM" category="System" global_only="true" xsi:schemaLocation="http://swtools.freescale.net/XSD/component/1.0 http://swtools.freescale.net/XSD/component/1.0/component-9.0.xsd" xmlns:component="http://swtools.freescale.net/XSD/component/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   <description>System Component</description>
   <user_functions>
      <!-- get core name from core ID - e.g. system::getCoreName($instance.getCoreID()) -->
      <function_def id="getCoreName">coreID -> queryFeatureAdvanced(`CPUCore`, coreID, `Name`, true)</function_def> 
      <!--  maskBitfield - mask one specific bit of the peripheral register bitfield
         Parameters:
            value - actual value of the bit (bool) / condition to mask a bitfield
            register - peripheral register name
            bitfield - peripheral bitfield name
            mask - mask value/expression   -->
      <function_def id="maskBitfield">(value, register, bitfield, mask) -> ((getBitFieldValue($instance.getPeripheral(), register, bitfield) &amp; ~(mask.toInt())) | (value == true ? (mask.toInt()) : 0))</function_def>
      <function_def id="getValueOrDefault">(node, default) -> ((node.isAvailable() &amp;&amp; node.isEnabled()) ? node.getValue() : default)</function_def>
      <function_def id="getBoolOrDefault">(node) -> ((node.isAvailable() &amp;&amp; node.isEnabled()) ? node.getValue() : false)</function_def>
      <function_def id="max">
         (a, b) -> a &gt; b ? a : b
      </function_def>
      <function_def id="decHexNumRegExpr">() -> (`(\d+)|(0x[0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,a,b,c,d,e,f]+)`)</function_def>
      <function_def id="decHexNumBpsRegExpr">() -> (`((\d+)|(0x[0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,a,b,c,d,e,f]+))(\s*)[b,B][p,P][s,S]`)</function_def>
      <!-- regular expression for the <float number>% specification of the duty cycle in percents  -->
      <function_def id="floatNumPercentRegExpr">() -> (`([\d]*[\./]*[\d]+)%`)</function_def>
      <!-- Function for checking whether the string is a float number + '%" for duty cycle specification in timers 
      Parameters:
         str - string to be checked whether it contains the <float value>%
      Return value: true/false -->
      <function_def id="isFloatNumPercentValue">(str) -> (str.regexMatch(system::floatNumPercentRegExpr()) &amp;&amp; str.regexSubstr(system::floatNumPercentRegExpr(),1).isFloat())</function_def>
      <!-- Function for checking whether the string is a float number + '%" for duty cycle specification in timers 
      Parameters:
         str - string to be checked whether it contains the <float value>%
      Return value: true/false -->
      <function_def id="getFloatNumPercentValue">(str) -> (system::isFloatNumPercentValue(str) ? str.regexSubstr(system::floatNumPercentRegExpr(),1).toFloat() : `N/A`)</function_def>
      <!--  boolToInt - converts boolean to integer value. If undefined or in case of other input value it returns -1.
         Parameters:
            x - boolean or string value: true/false `true`/`false` -->
      <function_def id="boolToInt">x -> ((x != `false`) ? ((x == `true`) ? 1 : -1) : 0)</function_def>
      <function_def id="IntToBool">x -> ((x == 0) ? false : true)</function_def>
      
      <!-- CLOCK GATE REGISTER INITIALIZATION FUNCTIONS -->
      <!-- The clockGateExists function returns true if the clock gate exists (in the clockGates resources) for the specified peripheral and submodule (optional).
      Parameters:
         - peripheral - name of the MCU peripheral (e.g. $instance.getPeripheral())
         - submodule - name of the submodule or empty string (the parameter value is ignored when empty)
      -->
      <function_def id="clockGateExists">(peripheral, submodule) -> (getResource(`clockGates`, $instance.getCoreId())
         .anyMatch(i -> i.getSetting(`peripherals`).anyMatch(p -> ((p.getSetting(`device`).getValue() == peripheral) &amp;&amp; ((submodule == ``) || (p.getSetting(`submodule_name`).getValue() == submodule))))))</function_def>
      <!-- The getClockGate function returns the clock gate structure (first found structure from the the clockGates resources) for the specified peripheral and submodule (optional).
      Parameters:
         - peripheral - name of the MCU peripheral (e.g. $instance.getPeripheral())
         - submodule - name of the submodule or empty string (the parameter value is ignored when empty)
      -->
      <function_def id="getClockGate">(peripheral, submodule) -> (getResource(`clockGates`, $instance.getCoreId())
         .findFirst(i -> i.getSetting(`peripherals`).anyMatch(p -> ((p.getSetting(`device`).getValue() == peripheral) &amp;&amp; ((submodule == ``) || (p.getSetting(`submodule_name`).getValue() == submodule))))))</function_def>
      <!-- The getClockGate function returns the array of clock gate structures (from the the clockGates resources) for the specified peripheral and submodule (optional).
      Parameters:
         - peripheral - name of the MCU peripheral (e.g. $instance.getPeripheral())
         - submodule - name of the submodule or empty string (the parameter value is ignored when empty)
      -->
      <function_def id="getAllClockGates">(peripheral, submodule) -> (getResource(`clockGates`, $instance.getCoreId())
         .filter(i -> i.getSetting(`peripherals`).anyMatch(p -> ((p.getSetting(`device`).getValue() == peripheral) &amp;&amp; ((submodule == ``) || (p.getSetting(`submodule_name`).getValue() == submodule))))))</function_def>
      <!-- The getClockGateRegister function returns clock gate peripheral for the specified peripheral and submodule (optional).
      Parameters:
         - peripheral - name of the MCU peripheral (e.g. $instance.getPeripheral())
         - submodule - name of the submodule or empty string (the parameter value is ignored when empty)
      -->
      <function_def id="getClockGatePeripheral">(peripheral, submodule) -> (system::clockGateExists(peripheral, submodule)  
         ? system::getClockGate(peripheral, submodule).getSetting(`control.peripheral`).getValue()
         : ``
         )</function_def>
      <!-- The getClockGatePeripheral function returns clock gate peripheral for the current instance of the peripheral (without submodule).
      Paremters: no parameters   
      -->
      <function_def id="getInstanceClockGatePeripheral">() -> system::getClockGatePeripheral($instance.getPeripheral(), ``)</function_def>
      <!-- The getClockGateRegister function returns clock gate register for the specified peripheral and submodule (optional).
      Parameters:
         - peripheral - name of the MCU peripheral (e.g. $instance.getPeripheral())
         - submodule - name of the submodule or empty string (the parameter value is ignored when empty)
      -->
      <function_def id="getClockGateRegister">(peripheral, submodule) -> (system::clockGateExists(peripheral, submodule) 
         ? system::getClockGate(peripheral, submodule).getSetting(`control.register`).getValue()
         : ``
         )</function_def>
      <!-- The getClockGateRegister function returns clock gate register for the current instance of the peripheral (without submodule).
      Paremters: no parameters   
      -->
      <function_def id="getInstanceClockGateRegister">() -> system::getClockGateRegister($instance.getPeripheral(), ``)</function_def>
      <!-- The getClockGateBitfield function returns clock gate bitfield for the specified peripheral and submodule (optional).
      Parameters:
         - peripheral - name of the MCU peripheral (e.g. $instance.getPeripheral())
         - submodule - name of the submodule or empty string (the parameter value is ignored when empty)
      -->
      <function_def id="getClockGateBitfield">(peripheral, submodule) -> (system::clockGateExists(peripheral, submodule) 
         ? system::getClockGate(peripheral, submodule).getSetting(`control.bitfield`).getValue()
         : ``
         )</function_def>
      <!-- The getInstanceClockGateBitfield function returns clock gate bitfield for the current instance of the peripheral (without submodule).
      Paremters: no parameters   
      -->
      <function_def id="getInstanceClockGateBitfield">() -> system::getClockGateBitfield($instance.getPeripheral(), ``)</function_def>
      <!-- The getClockGateEnableValue function returns clock gate enable value for the specified peripheral and submodule (optional).
      Parameters:
         - peripheral - name of the MCU peripheral (e.g. $instance.getPeripheral())
         - submodule - name of the submodule or empty string (the parameter value is ignored when empty)
      -->
      <function_def id="getClockGateEnableValue">(peripheral, submodule) -> (system::clockGateExists(peripheral, submodule) 
         ? system::getClockGate(peripheral, submodule).getSetting(`control.enabled`).getValue().toInt()
         : ``
         )</function_def>
      <!-- The getInstanceClockGateEnableValue function returns clock gate enable value for the current instance of the peripheral (without submodule).
      Paremters: no parameters   
      -->
      <function_def id="getInstanceClockGateEnableValue">() -> system::getClockGateEnableValue($instance.getPeripheral(), ``)</function_def>
      
      <!-- The getClockGateEnable function returns clock gate initialization code (register write access by using mask) for the specified peripheral and submodule (optional).
      Parameters:
         - peripheral - name of the MCU peripheral (e.g. $instance.getPeripheral())
         - submodule - name of the submodule or empty string (the parameter value is ignored when empty)
      -->
      <function_def id="getClockGateEnable">(peripheral, submodule) -> ((!system::clockGateExists(peripheral, submodule)) 
          ? ``
          : system::getAllClockGates(peripheral, submodule)
          .map(cg -> (cg.getSetting(`control.enabled`).getValue() == `1`) 
                     ? (cg.getSetting(`control.peripheral`).getValue() + `->` + cg.getSetting(`control.register`).getValue() + ` |= ` + cg.getSetting(`control.peripheral`).getValue() + `_` + cg.getSetting(`control.register`).getValue() + `_` + cg.getSetting(`control.bitfield`).getValue() + `_MASK;`)
                     : (cg.getSetting(`control.peripheral`).getValue() + `->` + cg.getSetting(`control.register`).getValue() + ` &amp;= ~` + cg.getSetting(`control.peripheral`).getValue() + `_` + cg.getSetting(`control.register`).getValue() + `_` + cg.getSetting(`control.bitfield`).getValue() + `_MASK;`)).
          reduce(``,(last, i) -> last + ((last == ``) ? `` : `&#xA;`) + i)
                                                                        )</function_def>
      <!-- The getClockGateEnableSubmoduleIndex function returns clock gate initialization code (register write access by using mask) for the specified peripheral and index of the submodule.
      Parameters:
         - peripheral - name of the MCU peripheral (e.g. $instance.getPeripheral())
         - submodule - index of the submodule or empty string (the parameter value is ignored when empty)
      -->
      <function_def id="getClockGateEnableSubmoduleIndex">(peripheral, submodule) -> ((!system::clockGateExists(peripheral, submodule)) 
         ? ``
         : system::getAllClockGates(peripheral, submodule)
         .map(cg -> (cg.getSetting(`control.enabled`).getValue() == `1`) 
                    ? (cg.getSetting(`control.peripheral`).getValue() + `->` + cg.getSetting(`control.register`).getValue() + ` |= ` + cg.getSetting(`control.peripheral`).getValue() + `_` + cg.getSetting(`control.register`).getValue() + `_` + cg.getSetting(`control.bitfield`).getValue() + `_MASK;`)
                    : (cg.getSetting(`control.peripheral`).getValue() + `->` + cg.getSetting(`control.register`).getValue() + ` &amp;= ~` + cg.getSetting(`control.peripheral`).getValue() + `_` + cg.getSetting(`control.register`).getValue() + `_` + cg.getSetting(`control.bitfield`).getValue() + `_MASK;`)).
         reduce(``,(last, i) -> last + ((last == ``) ? `` : `&#xA;`) + i)
         )</function_def>
      <!-- SOFTWARE RESET REGISTER INITIALIZATION FUNCTIONS -->
      <!-- The swResetExists function returns true if the software reset exists (in the swResets resources) for the specified peripheral and submodule (optional).
      Parameters:
         - peripheral - name of the MCU peripheral (e.g. $instance.getPeripheral())
         - submodule - name of the submodule or empty string (the parameter value is ignored when empty)
      -->
      <function_def id="swResetExists">(peripheral, submodule) -> (getResource(`swReset`, $instance.getCoreId())
         .anyMatch(i -> i.getSetting(`peripherals`).anyMatch(p -> ((p.getSetting(`device`).getValue() == peripheral) &amp;&amp; ((submodule == ``) || (p.getSetting(`submodule_name`).getValue() == submodule))))))</function_def>
      <!-- The getSwReset function returns the software reset structure (first found structure from the the swReset resources) for the specified peripheral and submodule (optional).
      Parameters:
         - peripheral - name of the MCU peripheral (e.g. $instance.getPeripheral())
         - submodule - name of the submodule or empty string (the parameter value is ignored when empty)
      -->
      <function_def id="getSwReset">(peripheral, submodule) -> (getResource(`swReset`, $instance.getCoreId())
         .findFirst(i -> i.getSetting(`peripherals`).anyMatch(p -> ((p.getSetting(`device`).getValue() == peripheral) &amp;&amp; ((submodule == ``) || (p.getSetting(`submodule_name`).getValue() == submodule))))))</function_def>
      <!-- The getSwReset function returns the array of software reset structures (from the the swReset resources) for the specified peripheral and submodule (optional).
      Parameters:
         - peripheral - name of the MCU peripheral (e.g. $instance.getPeripheral())
         - submodule - name of the submodule or empty string (the parameter value is ignored when empty)
      -->
      <function_def id="getAllSwResets">(peripheral, submodule) -> (getResource(`swReset`, $instance.getCoreId())
         .filter(i -> i.getSetting(`peripherals`).anyMatch(p -> ((p.getSetting(`device`).getValue() == peripheral) &amp;&amp; ((submodule == ``) || (p.getSetting(`submodule_name`).getValue() == submodule))))))</function_def>
      <!-- The getSwResetRegister function returns software reset peripheral for the specified peripheral and submodule (optional).
      Parameters:
         - peripheral - name of the MCU peripheral (e.g. $instance.getPeripheral())
         - submodule - name of the submodule or empty string (the parameter value is ignored when empty)
      -->
      <function_def id="getSwResetPeripheral">(peripheral, submodule) -> (system::swResetExists(peripheral, submodule)  
         ? system::getSwReset(peripheral, submodule).getSetting(`control.peripheral`).getValue()
         : ``
         )</function_def>
      <!-- The getSwResetPeripheral function returns software reset peripheral for the current instance of the peripheral (without submodule).
      Paremters: no parameters   
      -->
      <function_def id="getInstanceSwResetPeripheral">() -> system::getSwResetPeripheral($instance.getPeripheral(), ``)</function_def>
      <!-- The getSwResetRegister function returns software reset register for the specified peripheral and submodule (optional).
      Parameters:
         - peripheral - name of the MCU peripheral (e.g. $instance.getPeripheral())
         - submodule - name of the submodule or empty string (the parameter value is ignored when empty)
      -->
      <function_def id="getSwResetRegister">(peripheral, submodule) -> (system::swResetExists(peripheral, submodule) 
         ? system::getSwReset(peripheral, submodule).getSetting(`control.register`).getValue()
         : ``
         )</function_def>
      <!-- The getSwResetRegister function returns software reset register for the current instance of the peripheral (without submodule).
      Paremters: no parameters   
      -->
      <function_def id="getInstanceSwResetRegister">() -> system::getSwResetRegister($instance.getPeripheral(), ``)</function_def>
      <!-- The getSwResetBitfield function returns software reset bitfield for the specified peripheral and submodule (optional).
      Parameters:
         - peripheral - name of the MCU peripheral (e.g. $instance.getPeripheral())
         - submodule - name of the submodule or empty string (the parameter value is ignored when empty)
      -->
      <function_def id="getSwResetBitfield">(peripheral, submodule) -> (system::swResetExists(peripheral, submodule) 
         ? system::getSwReset(peripheral, submodule).getSetting(`control.bitfield`).getValue()
         : ``
         )</function_def>
      <!-- The getInstanceSwResetBitfield function returns software reset bitfield for the current instance of the peripheral (without submodule).
      Paremters: no parameters   
      -->
      <function_def id="getInstanceSwResetBitfield">() -> system::getSwResetBitfield($instance.getPeripheral(), ``)</function_def>
      <!-- The getSwResetEnableValue function returns software reset enable value for the specified peripheral and submodule (optional).
      Parameters:
         - peripheral - name of the MCU peripheral (e.g. $instance.getPeripheral())
         - submodule - name of the submodule or empty string (the parameter value is ignored when empty)
      -->
      <function_def id="getSwResetEnableValue">(peripheral, submodule) -> (system::swResetExists(peripheral, submodule) 
         ? system::getSwReset(peripheral, submodule).getSetting(`control.enabled`).getValue().toInt()
         : ``
         )</function_def>
      <!-- The getInstanceSwResetEnableValue function returns software reset enable value for the current instance of the peripheral (without submodule).
      Paremters: no parameters   
      -->
      <function_def id="getInstanceSwResetEnableValue">() -> system::getSwResetEnableValue($instance.getPeripheral(), ``)</function_def>
      <!-- The getSwResetDisableValue function returns software reset disable value for the specified peripheral and submodule (optional).
      Parameters:
         - peripheral - name of the MCU peripheral (e.g. $instance.getPeripheral())
         - submodule - name of the submodule or empty string (the parameter value is ignored when empty)
      -->
      <function_def id="getSwResetDisableValue">(peripheral, submodule) -> (system::swResetExists(peripheral, submodule) 
         ? system::getSwReset(peripheral, submodule).getSetting(`control.disabled`).getValue().toInt()
         : ``
         )</function_def>
      <!-- The getInstanceSwResetDisableValue function returns software reset disable value for the current instance of the peripheral (without submodule).
      Paremters: no parameters   
      -->
      <function_def id="getInstanceSwResetDisableValue">() -> system::getSwResetDisableValue($instance.getPeripheral(), ``)</function_def>
      <!-- REGISTER INITIALIZATION FUNCTIONS -->
      <!-- Function return definition of the register with commented bitfield value (for register initialization components. Bitfields are ordered according to bitfield offset in the register.
      Parameters:
         - periphName - name of the MCU peripheral
         - regName - name of the register
         - name - name of the definition -->
      <function_def id="getFullRegDefine">(periphName, regName, name) -> `/* ` + periphName + `_` + regName + `: ` + getBitfields(periphName, regName).filter(b -> b != ``).sort((a,b) -> getBitfieldOffset(periphName,regName,b) - getBitfieldOffset(periphName,regName,a)).map(x -> x + `=` + getBitFieldValue(periphName,regName,x)).reduce(``,(last, i) -> last + ((last == ``) ? `` : `, `) + i) + ` */&#xA;#define ` + name + ` ` + getRegisterValue(periphName, regName).toString(16) + `U` + `&#xA;`</function_def>
      <!-- Function return definition of the register with commented bitfield value (for register initialization components. Bitfields are filtered (only assigned bitfields are included in the comment) and ordered according to bitfield offset in the register.
      Parameters:
         - node - node of component (for example: $instance, $configSet, a setting of a config set)
         - periphName - name of the MCU peripheral
         - regName - name of the register
         - name - name of the definition -->
      <function_def id="getAssignedRegDefine">(node, periphName, regName, name) -> `/* ` + periphName + `_` + regName + `: ` + getAssignedBitFields(node, periphName, regName).filter(b -> b != ``).sort((a,b) -> getBitfieldOffset(periphName,regName,b) - getBitfieldOffset(periphName,regName,a)).map(x -> x + `=` + getBitFieldValue(periphName,regName,x)).reduce(``,(last, i) -> last + ((last == ``) ? `` : `, `) + i) + ` */&#xA;#define ` + name + ` ` + getRegisterValue(periphName, regName).toString(16) + `U` + `&#xA;`</function_def>
      <!--Parameters:
      - node - the setting node whose available option "custom_assign" overwrites the assigned register value
      - peripheral - name of the MCU peripheral
      - register - name of the register
      - name - name of the definition  -->
      <function_def id="getAssignedRegOrCustomDefine">(node, peripheral, register, name) -> `/* ` + peripheral + `_` + register + `: ` + (node.hasOption(`custom_assign`) ? `Runtime value` : getBitfields(peripheral, register).filter(b -> b != ``).sort((a,b) -> getBitfieldOffset(peripheral, register, b) - getBitfieldOffset(peripheral, register, a)).map(x -> x + `=` + getBitFieldValue(peripheral,register,x)).reduce(``,(last, i) -> last + ((last == ``) ? `` : `, `) + i)) + ` */&#xA;#define ` + name + ` ` + (node.hasOption(`custom_assign`) ? node.optionValue(`custom_assign`) : getRegisterValue(peripheral, register).toString(16) + `U`) + `&#xA;`</function_def>
      <!-- TIMING FUNCTIONS -->
      <!-- Validate the input value (string) that represents an integer value, frequency value or perid. 
        Parameters:
            - Value - string representation of the value
                There are supported the following formats: 
                - integer number; range min_val – max_val, e.g. “1 - 4294967296 (0x100000000)”; hexadecimal format is supported.
                - frequency value must be in format float_number [Hz, kHz, MHz or GHz].
                - period value must be in format float_number [ns, us, ms, s, m, h or d].
        Result: boolean value: true - the input value is a valid value
      -->
      <function_def id="validateValueFreqPeriod"> (x, min_val, max_val) -> (x.regexMatch(system::decHexNumRegExpr())) ? 
                                                            ((x.toInt() &gt;= min_val) &amp;&amp; (x.toInt() &lt;= max_val)) 
                                                            : (((x.isFreq()) || (x.isTime())) &amp;&amp; (!(x.isFreq() &amp;&amp; x.isTime())))
      </function_def>
      <!-- Only value and frequency are valid inputs; period is not a valid input --> 
      <function_def id="validateValueFreq"> (x, min_val, max_val) -> (x.regexMatch(system::decHexNumRegExpr())) ? 
                                                            ((x.toInt() &gt;= min_val) &amp;&amp; (x.toInt() &lt;= max_val)) 
                                                            : (x.isFreq() &amp;&amp; (!(x.isFreq() &amp;&amp; x.isTime())))
      </function_def>
      <!-- Only value and period are valid inputs; frequency is not a valid input --> 
      <function_def id="validateValuePeriod"> (x, min_val, max_val) -> (x.regexMatch(system::decHexNumRegExpr())) ? 
                                                            ((x.toInt() &gt;= min_val) &amp;&amp; (x.toInt() &lt;= max_val)) 
                                                            : (x.isTime() &amp;&amp; (!(x.isFreq() &amp;&amp; x.isTime())))
      </function_def>
      <!-- Only value of baudrate (bps) and value of divider --> 
      <function_def id="validateValueBps"> (x, min_val, max_val) -> (x.regexMatch(system::decHexNumRegExpr())) ? 
         ((x.toInt() &gt;= min_val) &amp;&amp; (x.toInt() &lt;= max_val)) 
         : (x.regexMatch(system::decHexNumBpsRegExpr()))
      </function_def>
      <!-- Validate value/time units or a duty in percentage: <float_value>% -->
      <function_def id="validateValuePeriodDuty"> (x, min_val, max_val) -> 
         (x.regexMatch(system::decHexNumRegExpr())) 
         ? ((x.toInt() &gt;= min_val) &amp;&amp; (x.toInt() &lt;= max_val)) 
         : (system::isFloatNumPercentValue(x))
         ? ((system::getFloatNumPercentValue(x) &gt;= 0) &amp;&amp; (system::getFloatNumPercentValue(x) &lt;= 100.0))
         : (x.isTime() &amp;&amp; (!(x.isFreq() &amp;&amp; x.isTime())))
      </function_def>   
      <!-- Compute a real/integer value of a prescaler/modulo from a value (direct value of the prescaler/modulo, or baudrate)
        Parameters:
            - value - string that represents an integer value, baudrate value in Bps
            - clkSrcFreq - clock source frequency that is used for computation of the result value from the frequency or period value. The value can be a string that represent a freqeuncy value
        Result: value of the prescaler/modulo (Real of Integer)
      -->
      <!-- getIntDividerValueBps returns integer value -->
      <function_def id="getIntDividerValueBps">
         (value, clkSrcFreq) -> value.regexMatch(system::decHexNumRegExpr()) ? 
         value.toInt()
         : (((clkSrcFreq != ``) &amp;&amp; (clkSrcFreq != `N/A`) &amp;&amp; (clkSrcFreq.toHertz() &gt; 0)) ?
            ((  value.regexMatch(system::decHexNumBpsRegExpr()) &amp;&amp; (value.regexSubstr(system::decHexNumBpsRegExpr(),1).toInt() &gt; 0)) ?
            toInt(clkSrcFreq.toHertz() * 1.0 / value.regexSubstr(system::decHexNumBpsRegExpr(),1).toInt())
            : `N/A`)
         : `N/A`
         )
      </function_def>
      <!-- Compute a real/integer value of a prescaler/modulo from a value (direct value of the prescaler/modulo, frequency or period)
        Parameters:
            - value - string that represents an integer value, frequency or period
            - clkSrcFreq - clock source frequency that is used for computation of the result value from the frequency or period value. The value can be a string that represent a freqeuncy value
        Result: value of the prescaler/modulo (Real of Integer)
      -->
       <!-- getRealDividerValue returns real (rational) value -->
      <function_def id="getRealDividerValue">
        (value, clkSrcFreq) -> value.regexMatch(system::decHexNumRegExpr()) ? 
            value.toInt()
            : (((clkSrcFreq != ``) &amp;&amp; (clkSrcFreq != `N/A`) &amp;&amp; (clkSrcFreq.toHertz() &gt; 0)) ?
                ((value.isFreq() &amp;&amp; (value.getFreqFloat(`Hz`,`Hz`) &gt; 0)) ?
                    (clkSrcFreq.toHertz() * 1.0 / value.getFreqFloat(`Hz`,`Hz`))
                    : (value.isTime() ? 
                        (1.0 * value.getTimeFloat(`ps`,`s`) * clkSrcFreq.toHertz() / 1.0e12) 
                        : `N/A`)
                )
                : `N/A`
            )
      </function_def>
      <!-- getIntDividerValue returns integer value -->
      <function_def id="getIntDividerValue">
        (value, clkSrcFreq) -> value.regexMatch(system::decHexNumRegExpr()) ? 
            value.toInt()
            : (((clkSrcFreq != ``) &amp;&amp; (clkSrcFreq != `N/A`) &amp;&amp; (clkSrcFreq.toHertz() &gt; 0)) ?
                ((value.isFreq() &amp;&amp; (value.getFreqFloat(`Hz`,`Hz`) &gt; 0)) ?
                    toInt(clkSrcFreq.toHertz() * 1.0 / value.getFreqFloat(`Hz`,`Hz`))
                    : (value.isTime() ? 
                        toInt(1.0 * value.getTimeFloat(`ps`,`s`) * clkSrcFreq.toHertz() / 1.0e12) 
                        : `N/A`)
                )
                : `N/A`
            )
      </function_def>
      <!-- Compute a real/integer value of match register from a value (direct value of the duty, float_number%, frequency or period)
      Parameters:
         - value - string that represents an integer value, frequency or period
         - moduloValue - modulo value (integer) of the timer that is used for calculatuion when percentage is used.
         - clkSrcFreq - clock source frequency that is used for computation of the result value from the frequency or period value. The value can be a string that represent a freqeuncy value
      Result: value of the match value (Integer)
      -->      
      <function_def id="getDutyCycleValue">
         (value, moduloValue, clkSrcFreq) -> value.regexMatch(system::decHexNumRegExpr()) 
         ? value.toInt()
         : (system::isFloatNumPercentValue(value)) 
         ? (isInt(moduloValue) ? toInt(moduloValue / 100.0 * system::getFloatNumPercentValue(value)) : `N/A`)  
         : (((clkSrcFreq != ``) &amp;&amp; (clkSrcFreq != `N/A`) &amp;&amp; (clkSrcFreq.toHertz() &gt; 0)) 
            ? ((value.isFreq() &amp;&amp; (value.getFreqFloat(`Hz`,`Hz`) &gt; 0)) 
               ? toInt(clkSrcFreq.toHertz() * 1.0 / value.getFreqFloat(`Hz`,`Hz`))
               : (value.isTime() 
                  ? toInt(1.0 * value.getTimeFloat(`ps`,`s`) * clkSrcFreq.toHertz() / 1.0e12) 
                  : `N/A`
                 )
              )
            : `N/A`
           )
      </function_def>
      <!-- Compute a real/integer value of a prescaler/modulo from a value (direct value of the prescaler/modulo, frequency or period). The clock source frequency is a rational.
        Parameters:
            - value - string that represents an integer value, frequency or period
            - clkSrcFreq - clock source frequency a s rational number. The value is used for computation of the result value from the frequency or period value
        Result: value of the prescaler/modulo (Real of Integer)
      -->
       <!-- getRealDividerValueRationalClk returns real (rational) value -->
      <function_def id="getRealDividerValueRationalClk">
        (value, clkSrcFreq) -> value.regexMatch(system::decHexNumRegExpr()) ? 
            value.toInt()
            : (((clkSrcFreq != ``) &amp;&amp; (clkSrcFreq != `N/A`) &amp;&amp; (clkSrcFreq &gt; 0)) ?
                ((value.isFreq() &amp;&amp; (value.getFreqFloat(`Hz`,`Hz`) &gt; 0)) ?
                    (clkSrcFreq * 1.0 / value.getFreqFloat(`Hz`,`Hz`))
                    : (value.isTime() ? 
                        (1.0 * value.getTimeFloat(`ps`,`s`) * clkSrcFreq / 1.0e12) 
                        : `N/A`)
                )
                : `N/A`
            )
      </function_def>
       <!-- getIntDividerValueRationalClk returns integer value -->
      <function_def id="getIntDividerValueRationalClk">
        (value, clkSrcFreq) -> value.regexMatch(system::decHexNumRegExpr()) ? 
            value.toInt()
            : (((clkSrcFreq != ``) &amp;&amp; (clkSrcFreq != `N/A`) &amp;&amp; (clkSrcFreq &gt; 0)) ?
                ((value.isFreq() &amp;&amp; (value.getFreqFloat(`Hz`,`Hz`) &gt; 0)) ?
                    toInt(clkSrcFreq * 1.0 / value.getFreqFloat(`Hz`,`Hz`))
                    : (value.isTime() ? 
                        toInt(1.0 * value.getTimeFloat(`ps`,`s`) * clkSrcFreq / 1.0e12) 
                        : `N/A`)
                )
                : `N/A`
            )
      </function_def>
       <!-- Calculation of the frequency and period from the input clock source frequency and divider (prescaler/modulo value). The result string is formatted for info item setting. 
        Parameters:
            - divider - the calculated divider value (prescaler or modulo value); it is usually an integer number
            - clkSrcFreq - clock source frequency (string that represent a frequency value)
        Result: Formatted frequency and period as string 
      -->
      <function_def id="calculateFreqPeriod"> 
         (divider, clkSrcFreq) -> ((divider != `N/A`) &amp;&amp; (divider != 0) &amp;&amp; (clkSrcFreq.isFreq()) &amp;&amp; (clkSrcFreq.toHertz() &gt; 0)) ?
            frequencyToString(1.0 * clkSrcFreq.toHertz() / divider, 4) + `; ` + timeToString(1000000.0 / (1.0 * clkSrcFreq.toHertz() / divider)) 
             : `N/A`
      </function_def>
      <!-- calculatePeriod returns the period only -->
      <function_def id="calculatePeriod"> 
         (divider, clkSrcFreq) -> ((divider != `N/A`) &amp;&amp; (divider != 0) &amp;&amp; (clkSrcFreq.isFreq()) &amp;&amp; (clkSrcFreq.toHertz() &gt; 0)) ?
            timeToString(1000000.0 / (1.0 * clkSrcFreq.toHertz() / divider)) 
             : `N/A`
      </function_def>
      <!-- calculateFreq returns the frequency only -->
      <function_def id="calculateFreq"> 
         (divider, clkSrcFreq) -> ((divider != `N/A`) &amp;&amp; (divider != 0) &amp;&amp; (clkSrcFreq.isFreq()) &amp;&amp; (clkSrcFreq.toHertz() &gt; 0)) ?
         frequencyToString(1.0 * clkSrcFreq.toHertz() / divider, 4) 
             : `N/A`
      </function_def>
      <!-- calculateBps returns the baudrate in bps only -->
      <function_def id="calculateBps"> 
         (divider, clkSrcFreq) -> ((divider != `N/A`) &amp;&amp; (divider != 0) &amp;&amp; (clkSrcFreq.isFreq()) &amp;&amp; (clkSrcFreq.toHertz() &gt; 0)) ?
         toInt(1.0 * clkSrcFreq.toHertz() / divider) + ` bps` 
         : `N/A`
      </function_def>
      <!-- calculateTicksFreqPeriod returns the ticks (for timers), frequency  and period
           This function has been designed for timer components for calculation of timer ticks. -->
      <function_def id="calculateTicksFreqPeriod"> 
         (divider, clkSrcFreq) -> ((divider != `N/A`) &amp;&amp; (divider != 0)) 
           ? (toInt(divider) + ` ticks` +  
             (((clkSrcFreq.isFreq()) &amp;&amp; (clkSrcFreq.toHertz() &gt; 0)) 
             ? (`; ` + frequencyToString(1.0 * clkSrcFreq.toHertz() / divider, 4) + `; ` + timeToString(1000000.0 / (1.0 * clkSrcFreq.toHertz() / divider)))
              : ``))
           : (divider == 0) ? `0 ticks`  : `N/A`
      </function_def>
      <!-- calculateTicksPeriod returns the ticks (for timers) and period
           This function has been designed for timer components for calculation of PWM duty in ticks and time period. -->
      <function_def id="calculateTicksPeriod"> 
         (divider, clkSrcFreq) -> ((divider != `N/A`) &amp;&amp; (divider != 0)) 
         ? (toInt(divider) + ` ticks` +  
         (((clkSrcFreq.isFreq()) &amp;&amp; (clkSrcFreq.toHertz() &gt; 0)) 
         ? (`; ` + timeToString(1000000.0 / (1.0 * clkSrcFreq.toHertz() / divider)))
         : ``))
         : (divider == 0) ? `0 ticks`  : `N/A`
      </function_def>
      <!-- Calculation of the frequency and period from the input clock source frequency and divider (prescaler/modulo value). The result string is formatted for info item setting. 
        Parameters:
            - divider - the calculated divider value (prescaler or modulo value); it is usually an integer number
            - clkSrcFreq - clock source frequency as a rational number
        Result: Formatted frequency and period as string 
      -->
      <function_def id="calculateFreqPeriodRationalClk"> 
         (divider, clkSrcFreq) -> ((divider != `N/A`) &amp;&amp; (divider != 0) &amp;&amp; (clkSrcFreq != `N/A`) &amp;&amp; (clkSrcFreq &gt; 0)) ?
           frequencyToString(1.0 * clkSrcFreq / divider, 4) + `; ` + timeToString(1000000.0 / (1.0 * clkSrcFreq / divider)) 
             : `N/A`
      </function_def> 
      <!-- calculatePeriodRationalClk returns the period only -->
      <function_def id="calculatePeriodRationalClk"> 
         (divider, clkSrcFreq) -> ((divider != `N/A`) &amp;&amp; (divider != 0) &amp;&amp; (clkSrcFreq != `N/A`) &amp;&amp; (clkSrcFreq &gt; 0)) ?
            timeToString(1000000.0 / (1.0 * clkSrcFreq / divider)) 
             : `N/A`
      </function_def> 
      <!-- calculateFreqRationalClk returns the frequency only -->
      <function_def id="calculateFreqRationalClk"> 
         (divider, clkSrcFreq) -> ((divider != `N/A`) &amp;&amp; (divider != 0) &amp;&amp; (clkSrcFreq != `N/A`) &amp;&amp; (clkSrcFreq &gt; 0)) ?
           frequencyToString(1.0 * clkSrcFreq / divider, 4) 
             : `N/A`
      </function_def> 
       <!-- Calculation of the frequency from the input clock source frequency and divider (prescaler/modulo value). The result is an integer number. 
        Parameters:
            - divider - the calculated divider value (prescaler or modulo value); it is usually an integer number
            - clkSrcFreq - clock source frequency (string that represent a frequency value)
        Result: Frequency value as an integer number (rational) 
      -->
      <function_def id="calculateIntFreq">
          (divider, clkSrcFreq) -> ((divider != `N/A`) &amp;&amp; (divider != `0`) &amp;&amp; (clkSrcFreq.isFreq()) &amp;&amp; (clkSrcFreq.toHertz() &gt; 0)) ?
                             toInt(1.0 * clkSrcFreq.toHertz() / divider) 
                             : `N/A`
      </function_def>            
      <!-- Calculation of the frequency from the input clock source frequency and divider (prescaler/modulo value). The result is a real number (rational). 
        Parameters:
            - divider - the calculated divider value (prescaler or modulo value); it is usually an integer number
            - clkSrcFreq - clock source frequency (string that represent a frequency value)
        Result: Frequency value as a real number (rational) 
      -->
      <function_def id="calculateRealFreq">
          (divider, clkSrcFreq) -> ((divider != `N/A`) &amp;&amp; (divider != `0`) &amp;&amp; (clkSrcFreq.isFreq()) &amp;&amp; (clkSrcFreq.toHertz() &gt; 0)) ?
                             (1.0 * clkSrcFreq.toHertz() / divider) 
                             : `N/A`
      </function_def>            
      <!-- Calculation of the frequency from the input clock source frequency and divider (prescaler/modulo value). The result is a real number (rational). 
        Parameters:
            - divider - the calculated divider value (prescaler or modulo value); it is usually an integer number
            - clkSrcFreq - clock source frequency as a real number (rational number)
        Result: Frequency value as a real number (rational) 
      -->
      <function_def id="calculateRealFreqRationalClk">
          (divider, clkSrcFreq) -> ((divider != `N/A`) &amp;&amp; (divider != `0`) &amp;&amp; (clkSrcFreq &gt; 0)) ?
                             (1.0 * clkSrcFreq / divider) 
                             : `N/A`
      </function_def>
      <!-- The countInterrupts() function return number of specified interrupts of the active CPU core. 
           Parameters:
                peripheral - ID of the peripheral or empty string. Usually the $instance.getPeripheral() is used as the parameter. When empty string is used the parameter is ignored in filtering of interrupts. 
                function - unified ID of the interrupt function or empty string. When empty string is used the parameter is ignored in filtering of interrupts.
                channel - unified ID of the channel (usually number) or empty string. When empty string is used the parameter is ignored in filtering of interrupts.
      --> 
      <function_def id="countInterrupts">(peripheral, function, channel) -> (getResource(`interrupts`, $instance.getCoreId())
         .countOccurrences(item -> (item.getSetting(`devices`).searchInArray(devItem -> 
         (((peripheral == ``) || (devItem.getSetting(`id`).getValue() == peripheral)) &amp;&amp;
         ((function == ``) || (devItem.getSetting(`function`).getValue() == function)) &amp;&amp;
         ((channel == ``) || (devItem.getSetting(`channel`).getValue() == channel)))) >= 0), false))
      </function_def>
      <!-- The floatToSignedFixedPoint() function return number in signed fixed-point integer. 
           Parameters:
                float_number - float number which should be convert into signet fixed-point number.
                int_part - how many bits is reserved for integer part of signed fixed-point number.
                fractial_part - how many bits is reserved for fractial part of signed-fixed point number.
                
      --> 
      <function_def id="floatToSignedFixedPoint"> 
         (float_number, int_part, fractal_part) -> ( (float_number &lt; 2**(int_part-1)) &amp;&amp; (float_number &gt;= -(2**(int_part-1)))) 
         ? (float_number.toInt() &lt;&lt; fractal_part) + toInt((float_number - float_number.toInt()) * 2**fractal_part)
         : `N/A`
      </function_def>
      <!-- The signedToUnsignedInteger() function return unsigned integer. 
           Parameters:
                int_number - signed number which should be converted in to unsigned integer.
                number_of_bits - integer bit size(8,16,32,64 etc.).
      --> 
      <function_def id="signedToUnsignedInteger">
         (int_number, number_of_bits) -> ((int_number &lt; 2**(number_of_bits-1)) &amp;&amp; (int_number &gt;= -(2**(number_of_bits-1))))
         ? ( int_number &lt; 0)
         ? ((2**number_of_bits) + int_number)
         : int_number
         : `N/A`
      </function_def>
   </user_functions>
   <config_set id="fsl_common" label="TBD" from_source="fsl_common.h">
      <description>TBD</description>
      <generated_types>
         <integer id="status_t" label="Type used for all status and error return values." type="int32_t"/>
      </generated_types>
      <user_types>
      </user_types>
      <settings>
      </settings>
      <quick_selections>
      </quick_selections>
   </config_set>
   <config_set id="fsl_edma" label="TBD" from_source="fsl_edma.h">
      <description>TBD</description>
      <generated_types>
         <enum id="edma_transfer_size_t" label="eDMA transfer configuration" from="_edma_transfer_size">
            <item id="kEDMA_TransferSize1Bytes" label="Source/Destination data transfer size is 1 byte every time"/>
            <item id="kEDMA_TransferSize2Bytes" label="Source/Destination data transfer size is 2 bytes every time"/>
            <item id="kEDMA_TransferSize4Bytes" label="Source/Destination data transfer size is 4 bytes every time"/>
            <item id="kEDMA_TransferSize16Bytes" label="Source/Destination data transfer size is 16 bytes every time"/>
            <item id="kEDMA_TransferSize32Bytes" label="Source/Destination data transfer size is 32 bytes every time"/>
         </enum>
         <enum id="edma_modulo_t" label="eDMA modulo configuration" from="_edma_modulo">
            <item id="kEDMA_ModuloDisable" label="Disable modulo"/>
            <item id="kEDMA_Modulo2bytes" label="Circular buffer size is 2 bytes."/>
            <item id="kEDMA_Modulo4bytes" label="Circular buffer size is 4 bytes."/>
            <item id="kEDMA_Modulo8bytes" label="Circular buffer size is 8 bytes."/>
            <item id="kEDMA_Modulo16bytes" label="Circular buffer size is 16 bytes."/>
            <item id="kEDMA_Modulo32bytes" label="Circular buffer size is 32 bytes."/>
            <item id="kEDMA_Modulo64bytes" label="Circular buffer size is 64 bytes."/>
            <item id="kEDMA_Modulo128bytes" label="Circular buffer size is 128 bytes."/>
            <item id="kEDMA_Modulo256bytes" label="Circular buffer size is 256 bytes."/>
            <item id="kEDMA_Modulo512bytes" label="Circular buffer size is 512 bytes."/>
            <item id="kEDMA_Modulo1Kbytes" label="Circular buffer size is 1 K bytes."/>
            <item id="kEDMA_Modulo2Kbytes" label="Circular buffer size is 2 K bytes."/>
            <item id="kEDMA_Modulo4Kbytes" label="Circular buffer size is 4 K bytes."/>
            <item id="kEDMA_Modulo8Kbytes" label="Circular buffer size is 8 K bytes."/>
            <item id="kEDMA_Modulo16Kbytes" label="Circular buffer size is 16 K bytes."/>
            <item id="kEDMA_Modulo32Kbytes" label="Circular buffer size is 32 K bytes."/>
            <item id="kEDMA_Modulo64Kbytes" label="Circular buffer size is 64 K bytes."/>
            <item id="kEDMA_Modulo128Kbytes" label="Circular buffer size is 128 K bytes."/>
            <item id="kEDMA_Modulo256Kbytes" label="Circular buffer size is 256 K bytes."/>
            <item id="kEDMA_Modulo512Kbytes" label="Circular buffer size is 512 K bytes."/>
            <item id="kEDMA_Modulo1Mbytes" label="Circular buffer size is 1 M bytes."/>
            <item id="kEDMA_Modulo2Mbytes" label="Circular buffer size is 2 M bytes."/>
            <item id="kEDMA_Modulo4Mbytes" label="Circular buffer size is 4 M bytes."/>
            <item id="kEDMA_Modulo8Mbytes" label="Circular buffer size is 8 M bytes."/>
            <item id="kEDMA_Modulo16Mbytes" label="Circular buffer size is 16 M bytes."/>
            <item id="kEDMA_Modulo32Mbytes" label="Circular buffer size is 32 M bytes."/>
            <item id="kEDMA_Modulo64Mbytes" label="Circular buffer size is 64 M bytes."/>
            <item id="kEDMA_Modulo128Mbytes" label="Circular buffer size is 128 M bytes."/>
            <item id="kEDMA_Modulo256Mbytes" label="Circular buffer size is 256 M bytes."/>
            <item id="kEDMA_Modulo512Mbytes" label="Circular buffer size is 512 M bytes."/>
            <item id="kEDMA_Modulo1Gbytes" label="Circular buffer size is 1 G bytes."/>
            <item id="kEDMA_Modulo2Gbytes" label="Circular buffer size is 2 G bytes."/>
         </enum>
         <enum id="edma_bandwidth_t" label="Bandwidth control." from="_edma_bandwidth">
            <item id="kEDMA_BandwidthStallNone" label="No eDMA engine stalls."/>
            <item id="kEDMA_BandwidthStall4Cycle" label="eDMA engine stalls for 4 cycles after each read/write."/>
            <item id="kEDMA_BandwidthStall8Cycle" label="eDMA engine stalls for 8 cycles after each read/write."/>
         </enum>
         <enum id="edma_channel_link_type_t" label="Channel link type." from="_edma_channel_link_type">
            <item id="kEDMA_LinkNone" label="No channel link"/>
            <item id="kEDMA_MinorLink" label="Channel link after each minor loop"/>
            <item id="kEDMA_MajorLink" label="Channel link while major loop count exhausted"/>
         </enum>
         <enum id="edma_interrupt_enable_t" label="eDMA interrupt source" from="_edma_interrupt_enable">
            <item id="kEDMA_ErrorInterruptEnable" label="Enable interrupt while channel error occurs."/>
            <item id="kEDMA_MajorInterruptEnable" label="Enable interrupt while major count exhausted."/>
            <item id="kEDMA_HalfInterruptEnable" label="Enable interrupt while major count to half value."/>
         </enum>
         <enum id="edma_transfer_type_t" label="eDMA transfer type" from="_edma_transfer_type">
            <item id="kEDMA_MemoryToMemory" label="Transfer from memory to memory"/>
            <item id="kEDMA_PeripheralToMemory" label="Transfer from peripheral to memory"/>
            <item id="kEDMA_MemoryToPeripheral" label="Transfer from memory to peripheral"/>
         </enum>
         <struct id="edma_config_t" label="eDMA global configuration structure." from="_edma_config">
            <bool id="enableContinuousLinkMode" label="Enable (true) continuous link mode.">
               <description>Enable (true) continuous link mode. Upon minor loop completion, the channel activates again if that channel has a minor loop channel link enabled and the link channel is itself.</description>
            </bool>
            <bool id="enableHaltOnError" label="Enable (true) transfer halt on error.">
               <description>Enable (true) transfer halt on error. Any error causes the HALT bit to set. Subsequently, all service requests are ignored until the HALT bit is cleared.</description>
            </bool>
            <bool id="enableRoundRobinArbitration" label="Enable (true) round robin channel arbitration method or fixed priority arbitration is used for channel selection">
               <description>Enable (true) round robin channel arbitration method or fixed priority arbitration is used for channel selection</description>
            </bool>
            <bool id="enableDebugMode" label="Enable(true) eDMA debug mode.">
               <description>Enable(true) eDMA debug mode. When in debug mode, the eDMA stalls the start of a new channel. Executing channels are allowed to complete.</description>
            </bool>
         </struct>
         <struct id="edma_transfer_config_t" label="eDMA transfer configuration" from="_edma_transfer_config">
            <description>This structure configures the source/destination transfer attribute. This figure shows the eDMA&apos;s transfer model: 
 | Transfer Size | | Minor Loop |_______________| Major loop Count 1 | Bytes | Transfer Size | | ____________|_______________|____________________|&gt; Minor loop complete 
 | | | |_______________| Major Loop Count 2 | | | | |_______________|____________________|&gt; Minor loop Complete------------------------------------------------------&gt; Transfer complete</description>
            <integer id="srcAddr" label="Source data address." type="uint32_t">
               <description>Source data address.</description>
            </integer>
            <integer id="destAddr" label="Destination data address." type="uint32_t">
               <description>Destination data address.</description>
            </integer>
            <reference id="srcTransferSize" label="Source data transfer size." type="edma_transfer_size_t">
               <description>Source data transfer size.</description>
            </reference>
            <reference id="destTransferSize" label="Destination data transfer size." type="edma_transfer_size_t">
               <description>Destination data transfer size.</description>
            </reference>
            <integer id="srcOffset" label="Sign-extended offset applied to the current source address to form the next-state value as each source read is completed." type="int16_t">
               <description>Sign-extended offset applied to the current source address to form the next-state value as each source read is completed.</description>
            </integer>
            <integer id="destOffset" label="Sign-extended offset applied to the current destination address to form the next-state value as each destination write is completed." type="int16_t">
               <description>Sign-extended offset applied to the current destination address to form the next-state value as each destination write is completed.</description>
            </integer>
            <integer id="minorLoopBytes" label="Bytes to transfer in a minor loop" type="uint32_t">
               <description>Bytes to transfer in a minor loop</description>
            </integer>
            <integer id="majorLoopCounts" label="Major loop iteration count." type="uint32_t">
               <description>Major loop iteration count.</description>
            </integer>
         </struct>
         <struct id="edma_channel_Preemption_config_t" label="eDMA channel priority configuration" from="_edma_channel_Preemption_config">
            <bool id="enableChannelPreemption" label="If true: a channel can be suspended by other channel with higher priority">
               <description>If true: a channel can be suspended by other channel with higher priority</description>
            </bool>
            <bool id="enablePreemptAbility" label="If true: a channel can suspend other channel with low priority">
               <description>If true: a channel can suspend other channel with low priority</description>
            </bool>
            <integer id="channelPriority" label="Channel priority" type="uint8_t">
               <description>Channel priority</description>
            </integer>
         </struct>
         <struct id="edma_minor_offset_config_t" label="eDMA minor offset configuration" from="_edma_minor_offset_config">
            <bool id="enableSrcMinorOffset" label="Enable(true) or Disable(false) source minor loop offset.">
               <description>Enable(true) or Disable(false) source minor loop offset.</description>
            </bool>
            <bool id="enableDestMinorOffset" label="Enable(true) or Disable(false) destination minor loop offset.">
               <description>Enable(true) or Disable(false) destination minor loop offset.</description>
            </bool>
            <integer id="minorOffset" label="Offset for a minor loop mapping." type="uint32_t">
               <description>Offset for a minor loop mapping.</description>
            </integer>
         </struct>
         <struct id="edma_tcd_t" label="eDMA TCD." from="_edma_tcd">
            <description>This structure is same as TCD register which is described in reference manual, and is used to configure the scatter/gather feature as a next hardware TCD.</description>
            <fixme id="SADDR" label="SADDR register, used to save source address" type="__IO uint32_t">
               <description>SADDR register, used to save source address</description>
            </fixme>
            <fixme id="SOFF" label="SOFF register, save offset bytes every transfer" type="__IO uint16_t">
               <description>SOFF register, save offset bytes every transfer</description>
            </fixme>
            <fixme id="ATTR" label="ATTR register, source/destination transfer size and modulo" type="__IO uint16_t">
               <description>ATTR register, source/destination transfer size and modulo</description>
            </fixme>
            <fixme id="NBYTES" label="Nbytes register, minor loop length in bytes" type="__IO uint32_t">
               <description>Nbytes register, minor loop length in bytes</description>
            </fixme>
            <fixme id="SLAST" label="SLAST register" type="__IO uint32_t">
               <description>SLAST register</description>
            </fixme>
            <fixme id="DADDR" label="DADDR register, used for destination address" type="__IO uint32_t">
               <description>DADDR register, used for destination address</description>
            </fixme>
            <fixme id="DOFF" label="DOFF register, used for destination offset" type="__IO uint16_t">
               <description>DOFF register, used for destination offset</description>
            </fixme>
            <fixme id="CITER" label="CITER register, current minor loop numbers, for unfinished minor loop." type="__IO uint16_t">
               <description>CITER register, current minor loop numbers, for unfinished minor loop.</description>
            </fixme>
            <fixme id="DLAST_SGA" label="DLASTSGA register, next stcd address used in scatter-gather mode" type="__IO uint32_t">
               <description>DLASTSGA register, next stcd address used in scatter-gather mode</description>
            </fixme>
            <fixme id="CSR" label="CSR register, for TCD control status" type="__IO uint16_t">
               <description>CSR register, for TCD control status</description>
            </fixme>
            <fixme id="BITER" label="BITER register, begin minor loop count." type="__IO uint16_t">
               <description>BITER register, begin minor loop count.</description>
            </fixme>
         </struct>
         <fixme id="edma_callback" label="Define callback function for eDMA." type="void(*"/>
         <struct id="edma_handle_t" label="eDMA transfer handle structure" from="_edma_handle">
            <reference id="callback" label="Callback function for major count exhausted." type="edma_callback">
               <description>Callback function for major count exhausted.</description>
            </reference>
            <fixme id="userData" label="Callback function parameter." type="void *">
               <description>Callback function parameter.</description>
            </fixme>
            <fixme id="base" label="eDMA peripheral base address." type="DMA_Type *">
               <description>eDMA peripheral base address.</description>
            </fixme>
            <fixme id="tcdPool" label="Pointer to memory stored TCDs." type="edma_tcd_t *">
               <description>Pointer to memory stored TCDs.</description>
            </fixme>
            <integer id="channel" label="eDMA channel number." type="uint8_t">
               <description>eDMA channel number.</description>
            </integer>
            <integer id="header" label="The first TCD index." type="int8_t">
               <description>The first TCD index. Should point to the next TCD to be loaded into the eDMA engine.</description>
            </integer>
            <integer id="tail" label="The last TCD index." type="int8_t">
               <description>The last TCD index. Should point to the next TCD to be stored into the memory pool.</description>
            </integer>
            <integer id="tcdUsed" label="The number of used TCD slots." type="int8_t">
               <description>The number of used TCD slots. Should reflect the number of TCDs can be used/loaded in the memory.</description>
            </integer>
            <integer id="tcdSize" label="The total number of TCD slots in the queue." type="int8_t">
               <description>The total number of TCD slots in the queue.</description>
            </integer>
            <integer id="flags" label="The status of the current channel." type="uint8_t">
               <description>The status of the current channel.</description>
            </integer>
         </struct>
      </generated_types>
      <user_types>
      </user_types>
      <settings>
      </settings>
      <quick_selections>
      </quick_selections>
   </config_set>
   <config_set id="fsl_dmamux" label="TBD" from_source="fsl_dmamux.h">
      <description>TBD</description>
      <generated_types/>
      <user_types>
      </user_types>
      <settings>
      </settings>
      <quick_selections>
      </quick_selections>
   </config_set>
   
   <!-- MCU specific config set  -->
   
   <config_set id="SYSTEM_IO" label="TBD" from_source="MK64F12.h">
      <description>TBD</description>
      <generated_types>
         <enum id="IRQn_Type" label="" from="IRQn">
            <item id="NotAvail_IRQn" label="Not available device specific interrupt"/>
            <item id="NonMaskableInt_IRQn" label="Non Maskable Interrupt"/>
            <item id="HardFault_IRQn" label="Cortex-M4 SV Hard Fault Interrupt"/>
            <item id="MemoryManagement_IRQn" label="Cortex-M4 Memory Management Interrupt"/>
            <item id="BusFault_IRQn" label="Cortex-M4 Bus Fault Interrupt"/>
            <item id="UsageFault_IRQn" label="Cortex-M4 Usage Fault Interrupt"/>
            <item id="SVCall_IRQn" label="Cortex-M4 SV Call Interrupt"/>
            <item id="DebugMonitor_IRQn" label="Cortex-M4 Debug Monitor Interrupt"/>
            <item id="PendSV_IRQn" label="Cortex-M4 Pend SV Interrupt"/>
            <item id="SysTick_IRQn" label="Cortex-M4 System Tick Interrupt"/>
            <item id="DMA0_IRQn" label="DMA Channel 0 Transfer Complete"/>
            <item id="DMA1_IRQn" label="DMA Channel 1 Transfer Complete"/>
            <item id="DMA2_IRQn" label="DMA Channel 2 Transfer Complete"/>
            <item id="DMA3_IRQn" label="DMA Channel 3 Transfer Complete"/>
            <item id="DMA4_IRQn" label="DMA Channel 4 Transfer Complete"/>
            <item id="DMA5_IRQn" label="DMA Channel 5 Transfer Complete"/>
            <item id="DMA6_IRQn" label="DMA Channel 6 Transfer Complete"/>
            <item id="DMA7_IRQn" label="DMA Channel 7 Transfer Complete"/>
            <item id="DMA8_IRQn" label="DMA Channel 8 Transfer Complete"/>
            <item id="DMA9_IRQn" label="DMA Channel 9 Transfer Complete"/>
            <item id="DMA10_IRQn" label="DMA Channel 10 Transfer Complete"/>
            <item id="DMA11_IRQn" label="DMA Channel 11 Transfer Complete"/>
            <item id="DMA12_IRQn" label="DMA Channel 12 Transfer Complete"/>
            <item id="DMA13_IRQn" label="DMA Channel 13 Transfer Complete"/>
            <item id="DMA14_IRQn" label="DMA Channel 14 Transfer Complete"/>
            <item id="DMA15_IRQn" label="DMA Channel 15 Transfer Complete"/>
            <item id="DMA_Error_IRQn" label="DMA Error Interrupt"/>
            <item id="MCM_IRQn" label="Normal Interrupt"/>
            <item id="FTFE_IRQn" label="FTFE Command complete interrupt"/>
            <item id="Read_Collision_IRQn" label="Read Collision Interrupt"/>
            <item id="LVD_LVW_IRQn" label="Low Voltage Detect, Low Voltage Warning"/>
            <item id="LLWU_IRQn" label="Low Leakage Wakeup Unit"/>
            <item id="WDOG_EWM_IRQn" label="WDOG Interrupt"/>
            <item id="RNG_IRQn" label="RNG Interrupt"/>
            <item id="I2C0_IRQn" label="I2C0 interrupt"/>
            <item id="I2C1_IRQn" label="I2C1 interrupt"/>
            <item id="SPI0_IRQn" label="SPI0 Interrupt"/>
            <item id="SPI1_IRQn" label="SPI1 Interrupt"/>
            <item id="I2S0_Tx_IRQn" label="I2S0 transmit interrupt"/>
            <item id="I2S0_Rx_IRQn" label="I2S0 receive interrupt"/>
            <item id="UART0_LON_IRQn" label="UART0 LON interrupt"/>
            <item id="UART0_RX_TX_IRQn" label="UART0 Receive/Transmit interrupt"/>
            <item id="UART0_ERR_IRQn" label="UART0 Error interrupt"/>
            <item id="UART1_RX_TX_IRQn" label="UART1 Receive/Transmit interrupt"/>
            <item id="UART1_ERR_IRQn" label="UART1 Error interrupt"/>
            <item id="UART2_RX_TX_IRQn" label="UART2 Receive/Transmit interrupt"/>
            <item id="UART2_ERR_IRQn" label="UART2 Error interrupt"/>
            <item id="UART3_RX_TX_IRQn" label="UART3 Receive/Transmit interrupt"/>
            <item id="UART3_ERR_IRQn" label="UART3 Error interrupt"/>
            <item id="ADC0_IRQn" label="ADC0 interrupt"/>
            <item id="CMP0_IRQn" label="CMP0 interrupt"/>
            <item id="CMP1_IRQn" label="CMP1 interrupt"/>
            <item id="FTM0_IRQn" label="FTM0 fault, overflow and channels interrupt"/>
            <item id="FTM1_IRQn" label="FTM1 fault, overflow and channels interrupt"/>
            <item id="FTM2_IRQn" label="FTM2 fault, overflow and channels interrupt"/>
            <item id="CMT_IRQn" label="CMT interrupt"/>
            <item id="RTC_IRQn" label="RTC interrupt"/>
            <item id="RTC_Seconds_IRQn" label="RTC seconds interrupt"/>
            <item id="PIT0_IRQn" label="PIT timer channel 0 interrupt"/>
            <item id="PIT1_IRQn" label="PIT timer channel 1 interrupt"/>
            <item id="PIT2_IRQn" label="PIT timer channel 2 interrupt"/>
            <item id="PIT3_IRQn" label="PIT timer channel 3 interrupt"/>
            <item id="PDB0_IRQn" label="PDB0 Interrupt"/>
            <item id="USB0_IRQn" label="USB0 interrupt"/>
            <item id="USBDCD_IRQn" label="USBDCD Interrupt"/>
            <item id="Reserved71_IRQn" label="Reserved interrupt 71"/>
            <item id="DAC0_IRQn" label="DAC0 interrupt"/>
            <item id="MCG_IRQn" label="MCG Interrupt"/>
            <item id="LPTMR0_IRQn" label="LPTimer interrupt"/>
            <item id="PORTA_IRQn" label="Port A interrupt"/>
            <item id="PORTB_IRQn" label="Port B interrupt"/>
            <item id="PORTC_IRQn" label="Port C interrupt"/>
            <item id="PORTD_IRQn" label="Port D interrupt"/>
            <item id="PORTE_IRQn" label="Port E interrupt"/>
            <item id="SWI_IRQn" label="Software interrupt"/>
            <item id="SPI2_IRQn" label="SPI2 Interrupt"/>
            <item id="UART4_RX_TX_IRQn" label="UART4 Receive/Transmit interrupt"/>
            <item id="UART4_ERR_IRQn" label="UART4 Error interrupt"/>
            <item id="UART5_RX_TX_IRQn" label="UART5 Receive/Transmit interrupt"/>
            <item id="UART5_ERR_IRQn" label="UART5 Error interrupt"/>
            <item id="CMP2_IRQn" label="CMP2 interrupt"/>
            <item id="FTM3_IRQn" label="FTM3 fault, overflow and channels interrupt"/>
            <item id="DAC1_IRQn" label="DAC1 interrupt"/>
            <item id="ADC1_IRQn" label="ADC1 interrupt"/>
            <item id="I2C2_IRQn" label="I2C2 interrupt"/>
            <item id="CAN0_ORed_Message_buffer_IRQn" label="CAN0 OR&apos;d message buffers interrupt"/>
            <item id="CAN0_Bus_Off_IRQn" label="CAN0 bus off interrupt"/>
            <item id="CAN0_Error_IRQn" label="CAN0 error interrupt"/>
            <item id="CAN0_Tx_Warning_IRQn" label="CAN0 Tx warning interrupt"/>
            <item id="CAN0_Rx_Warning_IRQn" label="CAN0 Rx warning interrupt"/>
            <item id="CAN0_Wake_Up_IRQn" label="CAN0 wake up interrupt"/>
            <item id="SDHC_IRQn" label="SDHC interrupt"/>
            <item id="ENET_1588_Timer_IRQn" label="Ethernet MAC IEEE 1588 Timer Interrupt"/>
            <item id="ENET_Transmit_IRQn" label="Ethernet MAC Transmit Interrupt"/>
            <item id="ENET_Receive_IRQn" label="Ethernet MAC Receive Interrupt"/>
            <item id="ENET_Error_IRQn" label="Ethernet MAC Error and miscelaneous Interrupt"/>
         </enum>
         <enum id="dma_request_source_t" label="Structure for the DMA hardware request." from="_dma_request_source">
            <description>Defines the structure for the DMA hardware request collections. The user can configure the hardware request into DMAMUX to trigger the DMA transfer accordingly. The index of the hardware request varies according to the to SoC.</description>
            <item id="kDmaRequestMux0Disable" label="DMAMUX TriggerDisabled."/>
            <item id="kDmaRequestMux0Reserved1" label="Reserved1"/>
            <item id="kDmaRequestMux0UART0Rx" label="UART0 Receive."/>
            <item id="kDmaRequestMux0UART0Tx" label="UART0 Transmit."/>
            <item id="kDmaRequestMux0UART1Rx" label="UART1 Receive."/>
            <item id="kDmaRequestMux0UART1Tx" label="UART1 Transmit."/>
            <item id="kDmaRequestMux0UART2Rx" label="UART2 Receive."/>
            <item id="kDmaRequestMux0UART2Tx" label="UART2 Transmit."/>
            <item id="kDmaRequestMux0UART3Rx" label="UART3 Receive."/>
            <item id="kDmaRequestMux0UART3Tx" label="UART3 Transmit."/>
            <item id="kDmaRequestMux0UART4" label="UART4 Transmit or Receive."/>
            <item id="kDmaRequestMux0UART5" label="UART5 Transmit or Receive."/>
            <item id="kDmaRequestMux0I2S0Rx" label="I2S0 Receive."/>
            <item id="kDmaRequestMux0I2S0Tx" label="I2S0 Transmit."/>
            <item id="kDmaRequestMux0SPI0Rx" label="SPI0 Receive."/>
            <item id="kDmaRequestMux0SPI0Tx" label="SPI0 Transmit."/>
            <item id="kDmaRequestMux0SPI1" label="SPI1 Transmit or Receive."/>
            <item id="kDmaRequestMux0SPI2" label="SPI2 Transmit or Receive."/>
            <item id="kDmaRequestMux0I2C0" label="I2C0."/>
            <item id="kDmaRequestMux0I2C1I2C2" label="I2C1 and I2C2."/>
            <item id="kDmaRequestMux0I2C1" label="I2C1 and I2C2."/>
            <item id="kDmaRequestMux0I2C2" label="I2C1 and I2C2."/>
            <item id="kDmaRequestMux0FTM0Channel0" label="FTM0 C0V."/>
            <item id="kDmaRequestMux0FTM0Channel1" label="FTM0 C1V."/>
            <item id="kDmaRequestMux0FTM0Channel2" label="FTM0 C2V."/>
            <item id="kDmaRequestMux0FTM0Channel3" label="FTM0 C3V."/>
            <item id="kDmaRequestMux0FTM0Channel4" label="FTM0 C4V."/>
            <item id="kDmaRequestMux0FTM0Channel5" label="FTM0 C5V."/>
            <item id="kDmaRequestMux0FTM0Channel6" label="FTM0 C6V."/>
            <item id="kDmaRequestMux0FTM0Channel7" label="FTM0 C7V."/>
            <item id="kDmaRequestMux0FTM1Channel0" label="FTM1 C0V."/>
            <item id="kDmaRequestMux0FTM1Channel1" label="FTM1 C1V."/>
            <item id="kDmaRequestMux0FTM2Channel0" label="FTM2 C0V."/>
            <item id="kDmaRequestMux0FTM2Channel1" label="FTM2 C1V."/>
            <item id="kDmaRequestMux0FTM3Channel0" label="FTM3 C0V."/>
            <item id="kDmaRequestMux0FTM3Channel1" label="FTM3 C1V."/>
            <item id="kDmaRequestMux0FTM3Channel2" label="FTM3 C2V."/>
            <item id="kDmaRequestMux0FTM3Channel3" label="FTM3 C3V."/>
            <item id="kDmaRequestMux0FTM3Channel4" label="FTM3 C4V."/>
            <item id="kDmaRequestMux0FTM3Channel5" label="FTM3 C5V."/>
            <item id="kDmaRequestMux0FTM3Channel6" label="FTM3 C6V."/>
            <item id="kDmaRequestMux0FTM3Channel7" label="FTM3 C7V."/>
            <item id="kDmaRequestMux0ADC0" label="ADC0."/>
            <item id="kDmaRequestMux0ADC1" label="ADC1."/>
            <item id="kDmaRequestMux0CMP0" label="CMP0."/>
            <item id="kDmaRequestMux0CMP1" label="CMP1."/>
            <item id="kDmaRequestMux0CMP2" label="CMP2."/>
            <item id="kDmaRequestMux0DAC0" label="DAC0."/>
            <item id="kDmaRequestMux0DAC1" label="DAC1."/>
            <item id="kDmaRequestMux0CMT" label="CMT."/>
            <item id="kDmaRequestMux0PDB" label="PDB0."/>
            <item id="kDmaRequestMux0PortA" label="PTA."/>
            <item id="kDmaRequestMux0PortB" label="PTB."/>
            <item id="kDmaRequestMux0PortC" label="PTC."/>
            <item id="kDmaRequestMux0PortD" label="PTD."/>
            <item id="kDmaRequestMux0PortE" label="PTE."/>
            <item id="kDmaRequestMux0IEEE1588Timer0" label="ENET IEEE 1588 timer 0."/>
            <item id="kDmaRequestMux0IEEE1588Timer1" label="ENET IEEE 1588 timer 1."/>
            <item id="kDmaRequestMux0IEEE1588Timer2" label="ENET IEEE 1588 timer 2."/>
            <item id="kDmaRequestMux0IEEE1588Timer3" label="ENET IEEE 1588 timer 3."/>
            <item id="kDmaRequestMux0AlwaysOn58" label="DMAMUX Always Enabled slot."/>
            <item id="kDmaRequestMux0AlwaysOn59" label="DMAMUX Always Enabled slot."/>
            <item id="kDmaRequestMux0AlwaysOn60" label="DMAMUX Always Enabled slot."/>
            <item id="kDmaRequestMux0AlwaysOn61" label="DMAMUX Always Enabled slot."/>
            <item id="kDmaRequestMux0AlwaysOn62" label="DMAMUX Always Enabled slot."/>
            <item id="kDmaRequestMux0AlwaysOn63" label="DMAMUX Always Enabled slot."/>
         </enum>
      </generated_types>
      <user_types>
      </user_types>
      <settings>
      </settings>
      <quick_selections>
      </quick_selections>
   </config_set>  
   
   <!-- SYSTEM RESOURCES DEFINITIONS -->
   
   <!-- Interrupt definition based on info item -->
   <config_set id="fsl_interrupt_peripheral" label="Interrupt" from_source="fsl_common.h">
      <description>Fsl interrupt resource</description>
      <generated_types/>
      <user_types>
         <enum id="enable_interrupt_t">
            <item id="enabled" label="Enabled in initialization" value="true">
               <description>The interrupt request of the NVIC is enabled by the EnableIRQ() function in the initialization code.</description>
            </item>
            <item id="noInit" label="Not initialized" value="false">
               <description>The interrupt request of the NVIC is not initialized (disabled by default).</description>
            </item>
         </enum>
         <struct id="interrupt_vector_t" label="NVIC interrupt vector type." from="IRQn" public="true">
            <!-- Support of the DSC INTC and ARM NVIC -->
            <variable id="intController" value="(featureDefined(`SOC_INTC_COUNT`) &amp;&amp; getFeature(`SOC_INTC_COUNT`)) ? `INTC` : `NVIC`"/>
            <variable id="intControllerName" value="(featureDefined(`SOC_INTC_COUNT`) &amp;&amp; getFeature(`SOC_INTC_COUNT`)) ? `INTC (Interrupt Controller peripheral)` : `NVIC (Nested Vectored Interrupt Controller peripheral)`"/>
            <!-- Available interrupt settings for all cores -->
            <variable id="int_settings_list" value="$components.system.#global.core_ids.getValue().flatMap(x->getResource(`interrupts`,x).filter(
               enumItem -> (enumItem.getSetting(`devices`).anyMatch(
               item -> (((!$parent.hasOption(`irq_function`)) || (item.getSetting(`function`).getValue() == $parent.optionValue(`irq_function`))) &amp;&amp; 
               ((!$parent.hasOption(`irq_channel`)) || (item.getSetting(`channel`).getValue() == $parent.optionValue(`irq_channel`)))  &amp;&amp;
               ((!$parent.hasOption(`irq_channel_reference`)) || (item.getSetting(`channel`).getValue() == $parent.getParent().getSetting(`irq_channel`).getValue()))  &amp;&amp;
               (($parent.hasOption(`all_devices`)) ? true : ($parent.hasOption(`irq_device`) ? ($parent.optionValue(`irq_device`) == item.getSetting(`id`).getValue()) : (item.getSetting(`id`).getValue() == $instance.getPeripheral()))))
               )) &amp;&amp; 
               enumItem.getSetting(`devices`).noneMatch(item -> item.getSetting(`function`).getValue() == `reserved`) &amp;&amp; 
               enumItem.getSetting(`devices`).noneMatch(item -> item.getSetting(`function`).getValue() == `reset`)))"></variable>
            <!-- Available interrupt settings for current core -->
            <variable id="core_int_settings" value="$parent.int_settings_list.getValue().filter(x -> x.getParent().getID() == $instance.getCoreId())"></variable>
            <variable id="isIRQnValid" value="$parent.IRQn.getCValue() != `` &amp;&amp; $parent.IRQn.getCValue() != `noInt` &amp;&amp; $parent.IRQn.getCValue() != `otherCoreInt`"></variable>
            <dynamic_enum id="IRQn" label="Interrupt" options="system_irqn;REGISTERS_REFRESH" 
               items="$parent.int_settings_list.getValue().size() != 0 
               ?  
               ($parent.int_settings_list.getValue().anyMatch(x -> x.getParent().getID() == $instance.getCoreId()) 
                  ?
                  $parent.core_int_settings.getValue().arrayToEnumItems(
                  enumItem -> true, 
                  enumItem -> enumItem.getSetting(`id`).getValue(),
                  enumItem -> enumItem.getSetting(`id`).getValue(),
                  enumItem -> enumItem.getSetting(`id`).getValue()) 
                  : 
                  createArray().addItemToList(`otherCoreInt`, `Interrupt not supported on ` + system::getCoreName($instance.getCoreID()) + ` core`, 0, true, `No interrupt vector supported on ` + system::getCoreName($instance.getCoreID()) + ` core`))
               : createArray().addItemToList(`noInt`, `Interrupt not supported`, 0, true, `No interrupt vector is supported`)">
               <validation>
                  <constraint cond_expr="$this.getCValue() != ``" level="error" description="An interrupt must be selected."/>
                  <constraint cond_expr="$this.getCValue() != `noInt`" level="error" description_expr="`No interrupt vector is supported for ` + $instance.getPeripheral() + ` peripheral.`"/>
                  <constraint cond_expr="$this.getCValue() != `otherCoreInt`" level="error" description_expr="`Interrupt for ` + $instance.getPeripheral() + ` peripheral is supported on different core.`"/>
                  <constraint level="info" description_expr="`The ` + $this.getValue() + ` is shared in multiple components/settings.`" cond_expr="!$parent.isInterruptShared.getValue()"/>
                  <constraint level="warning" when_expr="!$parent.hasOption(`without_handler_settings`) &amp;&amp; !$parent.enableTemplateISR.getValue(false) &amp;&amp; $parent.isIRQnValid.getValue()"
                     description_expr="`The ` + $this.getCValue() + ` vector is used multiple times with following handler names: `  + $components.system.#global.duplicit_irqs.getValue().filter(x -> (x.getValue() == $this.getValue())).map(x->x.getParent().getSetting(`IRQhandler`).getValue()) +`. Use the same custom handler name for sharing the interrupt vector, otherwise the interrupt vector will be initialized multiple times.`"
                     cond_expr="$components.system.#global.duplicit_irqs.getValue().noneMatch(x->((x.getValue() == $this.getValue()) &amp;&amp; (x.getParent().getSetting(`IRQhandler`).getValue() != $parent.IRQhandler.getValue())))"/>
               </validation>
            </dynamic_enum>
            <variable id="isInterruptShared" value="(!$parent.hasOption(`without_handler_settings`) &amp;&amp; !$parent.enableTemplateISR.getValue(false)) &amp;&amp; $parent.isIRQnValid.getValue()
               ?  
               ($components.system.#global.duplicit_irqs.getValue().anyMatch(x-> x.getValue() == $parent.IRQn.getValue()))
               : false">
            </variable>
            <variable id="irqData" value="(!$parent.isIRQnValid.getValue() || ($parent.intController.getValue() != `INTC`)) ? `` : ($parent.core_int_settings.getValue().findFirst(item -> (item.getSetting(`id`).getValue() == $parent.IRQn.getCValue())))" available="$parent.intController.getValue() == `INTC`"/>
            <!-- interrupt vector number of the INTC device  - defined for all interrupt vectors -->
            <variable id="vectorNumber" value="(($parent.irqData.getValue() == ``) || (!$parent.irqData.getValue().nodeExists(`devices`)) ) ? `` 
               : $parent.irqData.getValue().getSetting(`devices`).findFirst(device -> device.getSetting(`id`).getValue() == `INTC`).getSetting(`channel`).getValue()" available="$parent.intController.getValue() == `INTC`"/>
            <!-- Interrupt request ID of the IRQn_Type that is used for DSC INTC implementation support - it represents index of the IPR register in the INTC. If the irq is not defined the IPR (interrupt priority rregister) is not support for the interrupt vector-->
            <variable id="irqId" value="(($parent.irqData.getValue() == ``) || (!$parent.irqData.getValue().nodeExists(`irq`))) ? `` : $parent.irqData.getValue().getSetting(`irq`).getValue()" available="$parent.intController.getValue() == `INTC`"/>
            <!-- Interrupt priority variables -->
            <variable id="iprReg" value="(($parent.irqData.getValue() == ``) || (!$parent.irqData.getValue().nodeExists(`iprReg`))) ? `` : $parent.irqData.getValue().getSetting(`iprReg`).getValue()" available="$parent.intController.getValue() == `INTC`"/>
            <variable id="iprBitfield" value="(($parent.irqData.getValue() == ``) || (!$parent.irqData.getValue().nodeExists(`iprBitfield`))) ? `` : $parent.irqData.getValue().getSetting(`iprBitfield`).getValue()" available="$parent.intController.getValue() == `INTC`"/>
            <variable id="iprBitfieldAccess" value="(($parent.irqData.getValue() == ``) || (!$parent.irqData.getValue().nodeExists(`iprBitfield`)) || (!$parent.irqData.getValue().nodeExists(`iprReg`))) ? `` : `INTC_` + $parent.iprReg.getValue() + `_` + $parent.iprBitfield.getValue()" available="$parent.intController.getValue() == `INTC`"/>
            <variable id="iprBitfieldMask" value="(($parent.irqData.getValue() == ``) || (!$parent.irqData.getValue().nodeExists(`iprBitfield`)) &amp;&amp; ($parent.irqData.getValue().nodeExists(`iprReg`))) ? `` : $parent.iprBitfieldAccess.getValue() + `_MASK`" available="$parent.intController.getValue() == `INTC`"/>
            <variable id="iprBitfieldShift" value="(($parent.irqData.getValue() == ``) || (!$parent.irqData.getValue().nodeExists(`iprBitfield`)) &amp;&amp; ($parent.irqData.getValue().nodeExists(`iprReg`))) ? `` : $parent.iprBitfieldAccess.getValue() + `_SHIFT`" available="$parent.intController.getValue() == `INTC`"/>
            <variable id="iprValue0" value="(($parent.irqData.getValue() == ``) || (!$parent.irqData.getValue().nodeExists(`iprValue0`))) ? `` : $parent.irqData.getValue().getSetting(`iprValue0`).getValue()" available="$parent.intController.getValue() == `INTC`"/>
            <variable id="iprValue1" value="(($parent.irqData.getValue() == ``) || (!$parent.irqData.getValue().nodeExists(`iprValue1`))) ? `` : $parent.irqData.getValue().getSetting(`iprValue1`).getValue()" available="$parent.intController.getValue() == `INTC`"/>
            <variable id="iprValue2" value="(($parent.irqData.getValue() == ``) || (!$parent.irqData.getValue().nodeExists(`iprValue2`))) ? `` : $parent.irqData.getValue().getSetting(`iprValue2`).getValue()" available="$parent.intController.getValue() == `INTC`"/>
            <variable id="iprValue3" value="(($parent.irqData.getValue() == ``) || (!$parent.irqData.getValue().nodeExists(`iprValue3`))) ? `` : $parent.irqData.getValue().getSetting(`iprValue3`).getValue()" available="$parent.intController.getValue() == `INTC`"/>
            <variable id="iprValues" value="createArray()
               .addItemToList(`iprVal0`, $parent.iprValue0.getValue(),`0`,$parent.iprValue0.getValue() != ``)
               .addItemToList(`iprVal1`, $parent.iprValue1.getValue(),`1`,$parent.iprValue1.getValue() != ``)
               .addItemToList(`iprVal2`, $parent.iprValue2.getValue(),`2`,$parent.iprValue2.getValue() != ``)
               .addItemToList(`iprVal3`, $parent.iprValue3.getValue(),`3`,$parent.iprValue3.getValue() != ``)
               .addItemToList(`fastInt0`, `Fast interrupt 0`,`3`,($parent.iprReg.getValue() != ``) &amp;&amp; ($parent.iprValue3.getValue() != ``))
               .addItemToList(`fastInt1`, `Fast interrupt 1`,`3`,($parent.iprReg.getValue() != ``) &amp;&amp; ($parent.iprValue3.getValue() != ``))
               .addItemToList(`noInit`, `Not initialized`,`0`,true)
               " available="$parent.intController.getValue() == `INTC`"></variable>
            <dynamic_enum id="dsc_enable_interrrupt" label="Interrupt enable/priority" options="REGISTERS_REFRESH" items="$parent.iprValues.getValue().arrayToEnumItems(
               enumItem -> true,
               enumItem -> enumItem.getId(),
               enumItem -> enumItem.getLabel(),
               enumItem -> enumItem.getValue())" 
               available="$parent.intController.getValue() == `INTC`" >
               <description>Enable the interrupt request and priority of the nested interrupt vector controller (NVIC) in the initialiation code. Each fast interrupt 0 and fast interrupt 1 priority can be selected for one interrupt of the MCU only (it is limited by available registers for configuration of fast interrupt 0 and 1 routines).</description>
               <validation>
                  <constraint when_expr="($this.getEnumItemId() == `fastInt0`) || ($this.getEnumItemId() == `fastInt1`)" cond_expr="$components.system.#global.all_interrupt_config.getValue().countOccurrences(x->((x.getSetting(`dsc_enable_interrrupt`).isAvailable()) &amp;&amp; (x.getSetting(`dsc_enable_interrrupt`).isEnabled()) &amp;&amp; (x.getSetting(`dsc_enable_interrrupt`).getEnumItemId() == $this.getEnumItemId()) &amp;&amp; (x.getSetting(`IRQn`).getEnumItemId() != $parent.IRQn.getEnumItemId()))) == 0"
                     level="error" description_expr="`The ` + $this.getEnumItemLabel() + ` priority can be used once only in this project.`"/>
<!--                  <constraint cond_expr="$group.getChildren().countOccurrences(component -> component.get)" level=""/>-->
                  <constraint cond_expr="$this.getComponentInstances(`intc_reg`).countOccurrences(component -> component.isAvailable() &amp;&amp; component.isEnabled()) &gt; 0" level="error" 
                     description_expr="`The ` + $group.getLabel() + ` functional group does not contain any enabled instance of the intc component but an interrupt is used. Add one instance of the intc component in this functional group (or enable existing one).`"/>
               </validation>
               <assign when="$parent.iprReg.getValue() != ``">
                  <register peripheral="INTC" name="" bitfield="" name_expr="$parent.iprReg.getValue()"
                     bitfield_expr="$parent.iprBitfield.getValue()" 
                     value="$this.getEnumItemValue().toInt()"
                     reverse_value="x -> ((x == 3) &amp;&amp; getRegisterValue($parent.intController.getValue(),`FIM0`) == $parent.vectorNumber.getValue().toInt()) 
                                          ? `fastInt0` 
                                          : (((x == 3) &amp;&amp; (getRegisterValue($parent.intController.getValue(),`FIM1`) == $parent.vectorNumber.getValue().toInt())) 
                                          ? `fastInt1` 
                                          : `iprVal` + x)"/>                 
               </assign>
<!--           The assignment must be done on one place due to limitation of the Peripherals tool. 
               The assignemnt will be done in each functional group in the intc component by using variables.
               
               <assign when="$this.getEnumItemId() == `fastInt0`">
                  <register peripheral="INTC" name="FIM0" bitfield="FAST_INTERRUPT_0" value="$parent.vectorNumber.getValue().toInt()"/>
               </assign>
               <assign when="$this.getEnumItemId() == `fastInt1`">
                  <register peripheral="INTC" name="FIM1" bitfield="FAST_INTERRUPT_1" value="$parent.vectorNumber.getValue().toInt()"/>
               </assign>-->
            </dynamic_enum>
            <reference id="enable_interrrupt" label="Interrupt request" type="enable_interrupt_t" available="($parent.intController.getValue() == `NVIC`) &amp;&amp; (!$parent.hasOption(`irq_without_enable_control`))">
               <description>Enable the interrupt request of the nested interrupt vector controller (NVIC) in the initialiation code.</description>
            </reference>
            <bool id="enable_priority" label="Enable priority initialization" available="$parent.intController.getValue() == `NVIC`">
               <description>When enabled the interrupt priority setting is enabled and priority initialization code is generated.</description>
            </bool>
            <integer id="priority" label="Priority" type="uint8_t" enable="($parent.intController.getValue() == `NVIC`) &amp;&amp; $parent.enable_priority.getValue()" available="$parent.intController.getValue() == `NVIC`">
               <description>The interrupt priority. The range of supported values is core specific. See the MCU reference manual for supported values for each core (e.g. NVIC device specific information).</description>
               <validation>
                  <constraint when_expr="$this.isEnabled()" cond_expr="$components.system.#global.duplicit_irqs.getValue().countOccurrences(x->(x.getParent().getSetting(`priority`).isEnabled() &amp;&amp; x.getParent().getSetting(`priority`).getValue() != $this.getValue()) ) == 0"
                     level="warning" description_expr="`The priority of the ` + $parent.IRQn.getValue() + ` is initialized multiple times with different priority value.`"/>
                  <constraint when_expr="$this.isEnabled()" cond_expr="$components.system.#global.duplicit_irqs.getValue().countOccurrences(x->(x.getParent().getSetting(`priority`).isEnabled() &amp;&amp; x.getParent().getSetting(`priority`).getValue() == $this.getValue()) ) &lt; 2"
                     level="info" description_expr="`The priority of the ` + $parent.IRQn.getValue() + ` is initialized multiple times.`"/>
               </validation>
            </integer>
            <bool id="useDefaultISR" label="Use default ISR" available="$parent.hasOption(`irq_generate_handler`)">
               <description>Use template Interrupt Service Routine (ISR) which is defined in periherals.c file.</description>
            </bool>
            <variable id="enableTemplateISR" value="$parent.hasOption(`irq_generate_handler`) ? $parent.useDefaultISR.getValue() : false"></variable>
            <bool id="enable_custom_name" label="Enable custom handler name" available="!$parent.hasOption(`without_handler_settings`) &amp;&amp; !$parent.enableTemplateISR.getValue()">
               <description>When is this option enabled a user custom name of the handler is allowed to set in a settings below.
                  Note: The interrupt handler is used for implementation of the interrupt function. User must define this interrupt function that is added into interrupt vector table. 
                  For example definition of the function "void MY_DEVICE_IRQHANDLER(void)"; the MY_DEVICE_IRQHANDLER identifier is replaced by the definition in peripherals.h 
                  (e.g. FTM0_IRQHandler) that is available in the startup file for the interrupt vector table, i.e. the defined function is included in the interrupt vector table. 
               </description>
            </bool>
            <string id="handler_custom_name" label="Interrupt handler name" available="(!$parent.hasOption(`without_handler_settings`)) &amp;&amp; ($parent.enable_custom_name.getValue()) &amp;&amp; !$parent.enableTemplateISR.getValue()">
               <description>The interrupt handler is used for implementation of the interrupt function. User must define this interrupt function that is added into interrupt vector table. 
                  For example definition of the function "void MY_DEVICE_IRQHANDLER(void)"; the MY_DEVICE_IRQHANDLER identifier is replaced by the definition in peripherals.h 
                  (e.g. FTM0_IRQHandler) that is available in the startup file for the interrupt vector table, i.e. the defined function is included in the interrupt vector table.</description>
               <validation>
                  <constraint cond_expr="isCIdentifier($this.getValue())" level="error" description_expr="`The handler name: `+ $this.getCValue() +` is not valid C identifier!`"/>
                  <constraint when_expr="!$parent.isInterruptShared.getValue()" cond_expr="$components.system.#global.duplicit_ids.getValue().noneMatch(x -> x.getValue() == $this.getValue())" level="warning" description_expr="`The handler name ` + $this.getValue() + ` is a duplicate.`"/>  
               </validation>
            </string>
            <info id="handler_default_name" label="Interrupt handler name" value="$parent.hasOption(`without_handler_settings`) ? `N/A` : ($parent.enable_custom_name.getValue() ? $parent.handler_custom_name.getValue() : 
                  ($parent.hasOption(`irq_custom_name`) ? $parent.optionValue(`irq_custom_name`) : 
                     (toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + 
                     ($parent.hasOption(`irq_function`) ? ($parent.hasOption(`irq_function_replace`)? (`_` + $parent.optionValue(`irq_function_replace`)) :(`_` + $parent.optionValue(`irq_function`))) : ``) +  
                     ($parent.hasOption(`irq_channel`) ? (`_` + $parent.optionValue(`irq_channel`)) : ``) + 
                     ($parent.hasOption(`irq_channel_reference`) ? (`_` + $parent.getParent().getSetting(`irq_channel`).getValue()) : ``)))) + 
                     toUpperCase(`_IRQHandler`))" available="(!$parent.hasOption(`without_handler_settings`)) &amp;&amp; (!$parent.enable_custom_name.getValue()) &amp;&amp; !$parent.enableTemplateISR.getValue()">
               <description>The interrupt handler is used for implementation of the interrupt function. User must define this interrupt function that is added into interrupt vector table. 
                  For example definition of the function "void DEVICEx_IRQHANDLER(void)"; the DEVICEx_IRQHANDLER identifier is replaced by the definition in peripherals.h 
                  (e.g. FTM0_IRQHandler) that is available in the startup file for the interrupt vector table, i.e. the defined function is included in the interrupt vector table. 
               </description>
               <validation>
                  <constraint cond_expr="isCIdentifier($this.getValue())" level="error" description_expr="`The handler name: `+ $this.getCValue() +` is not valid C identifier!`"/>
                  <constraint when_expr="!$parent.isInterruptShared.getValue()" cond_expr="$components.system.#global.duplicit_ids.getValue().noneMatch(x -> x.getValue() == $this.getValue())" level="warning" description_expr="`The handler name ` + $this.getValue() + ` is a duplicate.`"/>  
               </validation>
            </info>
            <variable id="deviceIRQhandler" value="!$parent.isIRQnValid.getValue() ? `` : ($parent.core_int_settings.getValue().findFirst(item -> (item.getSetting(`id`).getValue() == $parent.IRQn.getCValue())).getSetting(`handler_id`).getValue())"></variable>
            <variable id="IRQhandler" value="$parent.hasOption(`without_handler_settings`) ? `N/A` : ($parent.enable_custom_name.getValue() ? $parent.handler_custom_name.getValue() : $parent.handler_default_name.getValue())" available="!$parent.hasOption(`without_handler_settings`) &amp;&amp; !$parent.enableTemplateISR.getValue()">
               <options_expr>
                  <option id="id_check"/>
               </options_expr>
            </variable>
            <variable id="IRQprefixId" value="($parent.hasOption(`irq_custom_name`) ? $parent.optionValue(`irq_custom_name`): 
               (toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
               ($parent.hasOption(`irq_function`) ? ($parent.hasOption(`irq_function_replace`)? (`_` + $parent.optionValue(`irq_function_replace`)) : (`_` + $parent.optionValue(`irq_function`))) : ``) +  
               ($parent.hasOption(`irq_channel`) ? (`_` + $parent.optionValue(`irq_channel`)) : ``) +  
               ($parent.hasOption(`irq_channel_reference`) ? (`_` + $parent.getParent().getSetting(`irq_channel`).getValue()) : ``))))"/>
            <variable id="arm_errata_838869" value="leftPadding(`/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F&#10;   `,1) + 
               leftPadding(`Store immediate overlapping exception return operation might vector to incorrect interrupt. */&#10;`,1) +
               leftPadding(`#if defined __CORTEX_M &amp;&amp; (__CORTEX_M == 4U)&#10;`,1) +
               leftPadding(`__DSB();&#10;`,2) +
               leftPadding(`#endif&#10;`,1)" ></variable>
            <variable id="pragma_begin" value="($parent.intController.getValue() == `INTC`)
                                                ? ((($parent.dsc_enable_interrrupt.getEnumItemId() == `fastInt0`) || ($parent.dsc_enable_interrrupt.getEnumItemId() == `fastInt1`))
                                                   ? `#pragma interrupt fast&#10;`
                                                   : `#pragma interrupt alignsp saveall&#10;`)
                                                : ``"></variable>
            <variable id="pragma_end" value="($parent.intController.getValue() == `INTC`) 
                                                ? `#pragma interrupt off&#10;` 
                                                : ``"></variable>
            <variable id="IRQHandlerDeclaration" 
               value="`/* ` + $parent.IRQn.getValue() + ` interrupt vector's handler external declaration */&#10;` + 
               $parent.pragma_begin.getValue() + 
               `extern void ` + (($parent.hasOption(`without_handler_settings`) || $parent.enableTemplateISR.getValue(false) || $parent.IRQhandler.getValue()==`N/A`) ? $parent.deviceIRQhandler.getValue(``) : $parent.IRQhandler.getValue()) + `(void);&#10;` + 
               $parent.pragma_end.getValue() 
               ">   
            </variable>
            <variable id="copyToClipBoardText" 
               value="`/* ` + $parent.IRQn.getValue() + ` interrupt handler */&#10;` + 
               $parent.pragma_begin.getValue() + 
               `void ` + (($parent.hasOption(`without_handler_settings`) || $parent.enableTemplateISR.getValue(false) || $parent.IRQhandler.getValue()==`N/A`) ? $parent.deviceIRQhandler.getValue(``) : $parent.IRQhandler.getValue()) + `(void) {&#10;` + 
               ($parent.hasOption(`irq_handler_insert`)? ($parent.optionValue(`irq_handler_insert`) + `&#10;`) :(leftPadding(`/*  Place your code here */&#10;`,1))) + 
               (($parent.hasOption(`irq_handler_remove_arm_errata_838869`) || ($parent.intController.getValue() != `NVIC`)) ? `` : $parent.arm_errata_838869.getValue()) + 
               `}&#10;` + 
               $parent.pragma_end.getValue() 
               ">   
            </variable>
            <info id="copyToClipBoard" label="Handler template" available="!$parent.hasOption(`without_handler_settings`) &amp;&amp; !$parent.enableTemplateISR.getValue()" value="$parent.copyToClipBoardText.getValue()" options="UI_INFO_COPY_BUTTON">
               <description>Copy template of interrupt handler.</description>
            </info>
         </struct>
      </user_types>
      <settings>
      </settings>
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="common_code_templates"/>  
         </import>
         <!-- IRQ macroprocessor definitions IRQn, IRQ_PRIORITY and IRQHandler 
              The interrupt_vector_t structure must be handled as $this
         -->
         <def fragment="IRQ_definitions" public="true">
            <fragment id="define">
<!--               <param id="name" expr="($this.hasOption(`irq_custom_name`) ? $this.optionValue(`irq_custom_name`): 
                                       (toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
                                       ($this.hasOption(`irq_function`) ? ($this.hasOption(`irq_function_replace`)? (`_` + $this.optionValue(`irq_function_replace`)) : (`_` + $this.optionValue(`irq_function`))) : ``) +  
                                       ($this.hasOption(`irq_channel`) ? (`_` + $this.optionValue(`irq_channel`)) : ``) +  
                                       ($this.hasOption(`irq_channel_reference`) ? (`_` + $parent.irq_channel.getValue()) : ``)))) + 
                                       toUpperCase(`_IRQn`)"/>-->
               <param id="name" expr="$this.IRQprefixId.getValue() + toUpperCase(`_IRQn`)"/>
               <param id="value" expr="$this.IRQn.getValue()"/> 
               <param id="description" expr="$instance.getID() + ` interrupt vector ID (number).`"/>
            </fragment>
            <!-- Interrupt number for DSC INTC (index of the IPR) -->
            <fragment id="define" if_expr="$this.irqId.isAvailable() &amp;&amp; $this.irqId.getValue() != ``">
               <param id="name" expr="$this.IRQprefixId.getValue() + toUpperCase(`_IRQ`)"/>
               <param id="value" expr="$this.irqId.getValue()"/> 
               <param id="description" expr="$instance.getID() + ` interrupt priority register (interrupt priority register/bitfield index).`"/>
            </fragment>
            <fragment id="define" if_expr="($this.intController.getValue() == `NVIC`) &amp;&amp; $this.enable_priority.getValue()">
<!--               <param id="name" expr="($this.hasOption(`irq_custom_name`) ? $this.optionValue(`irq_custom_name`):
                                       (toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + 
                                       ($this.hasOption(`irq_function`) ? ($this.hasOption(`irq_function_replace`)? (`_` + $this.optionValue(`irq_function_replace`)) : (`_` + $this.optionValue(`irq_function`))) : ``) +  
                                       ($this.hasOption(`irq_channel`) ? (`_` + $this.optionValue(`irq_channel`)) : ``) +  
                                       ($this.hasOption(`irq_channel_reference`) ? (`_` + $parent.irq_channel.getValue()) : ``)))) + 
                                       toUpperCase(`_IRQ_PRIORITY`)"/>-->
               <param id="name" expr="$this.IRQprefixId.getValue() + toUpperCase(`_IRQ_PRIORITY`)"/>
               <param id="value" expr="$this.priority.getCValue()"/>
               <param id="description" expr="$instance.getID() + ` interrupt vector priority.`"/>
            </fragment>
            <fragment id="define" if_expr="$this.IRQhandler.isAvailable()">
               <param id="name" expr="$this.IRQhandler.getValue()"/>
               <param id="value" expr="$this.deviceIRQhandler.getValue()"/> 
               <param id="description" expr="$instance.getID() + ` interrupt handler identifier.`"/>
            </fragment>
            <!-- Generated ISR or the fast interrupt0/1 require declaration of the IRQ handler for initialization of the fast interrupt registers. -->
            <if expr="($this.intController.getValue() == `INTC`) &amp;&amp; ($this.iprReg.getValue() != ``) &amp;&amp; ($this.useDefaultISR.getValue(false) || ((($this.dsc_enable_interrrupt.getEnumItemId() == `fastInt0`) || ($this.dsc_enable_interrrupt.getEnumItemId() == `fastInt1`))  &amp;&amp; ($this.IRQhandler.isAvailable())))">
               <expr>$this.IRQHandlerDeclaration.getValue()</expr>
            </if>
         </def>
         <def fragment="IRQn_enable_default" public="true">
            <if expr="($this.intController.getValue() == `NVIC`) &amp;&amp; $this.enable_interrrupt.isAvailable() &amp;&amp; ($this.enable_interrrupt.getEnumItemValue() == `true`)">
            <expr>leftPadding(`/* Enable interrupt `, 1)</expr><expr>$this.IRQn.getValue()</expr><text> request in the NVIC. */</text><br/>
            <expr>leftPadding(`EnableIRQ(`, 1) + ($this.hasOption(`irq_custom_name`) ? $this.optionValue(`irq_custom_name`) : (toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
                                              ($this.hasOption(`irq_function`) ? ($this.hasOption(`irq_function_replace`)? (`_` + $this.optionValue(`irq_function_replace`)) :(`_` + $this.optionValue(`irq_function`))) : ``) +  
                                              ($this.hasOption(`irq_channel`) ? (`_` + $this.optionValue(`irq_channel`)) : ``) +  
                                              ($this.hasOption(`irq_channel_reference`) ? (`_` + $parent.irq_channel.getValue()) : ``)))) + 
                                              toUpperCase(`_IRQn`)
                                + `);`</expr><br/>
            </if>
            <if expr="($this.intController.getValue() == `NVIC`) &amp;&amp; $this.enable_interrrupt.isAvailable() &amp;&amp; ($this.enable_interrrupt.getEnumItemValue() == `false`)">
               <expr>leftPadding(`/* Interrupt `, 1)</expr><expr>$this.IRQn.getValue()</expr><text> request in the NVIC is not initialized (disabled by default). */</text><br/>
               <expr>leftPadding(`/* It can be enabled later by EnableIRQ(`, 1) + ($this.hasOption(`irq_custom_name`) ? $this.optionValue(`irq_custom_name`) : (toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
                  ($this.hasOption(`irq_function`) ? ($this.hasOption(`irq_function_replace`)? (`_` + $this.optionValue(`irq_function_replace`)) :(`_` + $this.optionValue(`irq_function`))) : ``) +  
                  ($this.hasOption(`irq_channel`) ? (`_` + $this.optionValue(`irq_channel`)) : ``) +  
                  ($this.hasOption(`irq_channel_reference`) ? (`_` + $parent.irq_channel.getValue()) : ``)))) + 
                  toUpperCase(`_IRQn`)
                  + `);  function call. */`</expr><br/>
            </if>
<!--            <!-\- DSC INTC code -\->
            <if expr="($this.intController.getValue() == `INTC`) &amp;&amp; ($this.iprReg.getValue() != ``) &amp;&amp; ($this.dsc_enable_interrrupt.getEnumItemId() != `noInit`)">
               <expr>leftPadding(`/* Set interrupt priority `, 1)</expr><expr>$this.IRQn.getValue()</expr><text> request in the INTC. */</text><br/>
               <expr>leftPadding(`INTC->`, 1) + $this.iprReg.getValue() + ` = (INTC->` + $this.iprReg.getValue() + ` &amp; ~` + $this.iprBitfieldMask.getValue() + `) | ` +  $this.iprBitfieldAccess.getValue() + `(` + $this.dsc_enable_interrrupt.getEnumItemValue() + `);`</expr><br/>
            </if>
            <!-\- Fast interrupt 0 intialization -\->
            <if expr="($this.intController.getValue() == `INTC`) &amp;&amp; ($this.iprReg.getValue() != ``) &amp;&amp; ($this.dsc_enable_interrrupt.getEnumItemId() == `fastInt0`)  &amp;&amp; ($this.IRQhandler.isAvailable())">
               <expr>leftPadding(`/* Fast interrupt 0 initialization */`, 1)</expr><br/>
               <expr>leftPadding(`INTC->FIM0 = ((uint32_t)(` + $this.IRQprefixId.getValue() + toUpperCase(`_IRQn`) + `)) &amp; INTC_FIM0_FAST_INTERRUPT_0_MASK;`, 1)</expr><br/>
<!-\-           <expr>leftPadding(`INTC->FIM0 = (` + $this.vectorNumber.getValue() + `);`, 1)</expr><br/>  -\->
               <expr>leftPadding(`INTC->FIVAL0 = ((uint32_t)(` + $this.IRQhandler.getValue() + `)) &amp; 0xffff;`, 1)</expr><br/>  
               <expr>leftPadding(`INTC->FIVAH0 = ((uint32_t)(` + $this.IRQhandler.getValue() + `) &gt;&gt; 16) &amp; 0xffff;`, 1)</expr><br/>  
            </if>
            <if expr="($this.intController.getValue() == `INTC`) &amp;&amp; ($this.iprReg.getValue() != ``) &amp;&amp; ($this.dsc_enable_interrrupt.getEnumItemId() == `fastInt1`)  &amp;&amp; ($this.IRQhandler.isAvailable())">
               <expr>leftPadding(`/* Fast interrupt 1 initialization */`, 1)</expr><br/>
               <expr>leftPadding(`INTC->FIM1 = ((uint32_t)(` + $this.IRQprefixId.getValue() + toUpperCase(`_IRQn`) + `)) &amp; INTC_FIM1_FAST_INTERRUPT_1_MASK;`, 1)</expr><br/>
               <expr>leftPadding(`INTC->FIVAL1 = ((uint32_t)(` + $this.IRQhandler.getValue() + `)) &amp; 0xffff;`, 1)</expr><br/>  
               <expr>leftPadding(`INTC->FIVAH1 = ((uint32_t)(` + $this.IRQhandler.getValue() + `) &gt;&gt; 16) &amp; 0xffff;`, 1)</expr><br/>  
            </if>-->
         </def>
         <def fragment="INTC_IRQn_enable_default" public="true">
            <!-- DSC INTC code -->
            <if expr="($this.intController.getValue() == `INTC`) &amp;&amp; ($this.iprReg.getValue() != ``) &amp;&amp; ($this.dsc_enable_interrrupt.getEnumItemId() != `noInit`)">
               <expr>leftPadding(`/* Set the interrupt priority: `, 1)</expr><expr>$this.dsc_enable_interrrupt.getEnumItemLabel() + ` of the ` + $this.IRQn.getValue()</expr><text> request in the INTC. */</text><br/>
               <expr>leftPadding(`INTC->`, 1) + $this.iprReg.getValue() + ` = (INTC->` + $this.iprReg.getValue() + ` &amp; ~` + $this.iprBitfieldMask.getValue() + `) | ` +  $this.iprBitfieldAccess.getValue() + `(` + $this.dsc_enable_interrrupt.getEnumItemValue() + `);`</expr><br/>
            </if>
            <!-- Fast interrupt 0 intialization -->
            <if expr="($this.intController.getValue() == `INTC`) &amp;&amp; ($this.iprReg.getValue() != ``) &amp;&amp; ($this.dsc_enable_interrrupt.getEnumItemId() == `fastInt0`)  &amp;&amp; ($this.useDefaultISR.getValue(false) || $this.IRQhandler.isAvailable())">
               <expr>leftPadding(`/* Fast interrupt 0 initialization */`, 1)</expr><br/>
               <expr>leftPadding(`INTC->FIM0 = ((uint32_t)(` + $this.IRQprefixId.getValue() + toUpperCase(`_IRQn`) + `)) &amp; INTC_FIM0_FAST_INTERRUPT_0_MASK;`, 1)</expr><br/>
               <!--           <expr>leftPadding(`INTC->FIM0 = (` + $this.vectorNumber.getValue() + `);`, 1)</expr><br/>  -->
               <expr>leftPadding(`INTC->FIVAL0 = ((uint32_t)(` + ($this.useDefaultISR.getValue(false) ? $this.deviceIRQhandler.getValue() : $this.IRQhandler.getValue()) + `)) &amp; 0xffff;`, 1)</expr><br/>  
               <expr>leftPadding(`INTC->FIVAH0 = ((uint32_t)(` + ($this.useDefaultISR.getValue(false) ? $this.deviceIRQhandler.getValue() : $this.IRQhandler.getValue()) + `) &gt;&gt; 16) &amp; 0xffff;`, 1)</expr><br/>  
            </if>
            <if expr="($this.intController.getValue() == `INTC`) &amp;&amp; ($this.iprReg.getValue() != ``) &amp;&amp; ($this.dsc_enable_interrrupt.getEnumItemId() == `fastInt1`)  &amp;&amp; ($this.useDefaultISR.getValue(false) || $this.IRQhandler.isAvailable())">
               <expr>leftPadding(`/* Fast interrupt 1 initialization */`, 1)</expr><br/>
               <expr>leftPadding(`INTC->FIM1 = ((uint32_t)(` + $this.IRQprefixId.getValue() + toUpperCase(`_IRQn`) + `)) &amp; INTC_FIM1_FAST_INTERRUPT_1_MASK;`, 1)</expr><br/>
               <expr>leftPadding(`INTC->FIVAL1 = ((uint32_t)(` + ($this.useDefaultISR.getValue(false) ? $this.deviceIRQhandler.getValue() : $this.IRQhandler.getValue()) + `)) &amp; 0xffff;`, 1)</expr><br/>  
               <expr>leftPadding(`INTC->FIVAH1 = ((uint32_t)(` + ($this.useDefaultISR.getValue(false) ? $this.deviceIRQhandler.getValue() : $this.IRQhandler.getValue()) + `) &gt;&gt; 16) &amp; 0xffff;`, 1)</expr><br/>  
            </if>
         </def>   
         <def fragment="IRQn_set_priority_default" public="true">
            <if expr="($this.intController.getValue() == `NVIC`) &amp;&amp; $this.enable_priority.getValue()">
               <expr>leftPadding(`/* Interrupt vector `, 1) + $this.IRQn.getValue()</expr><text> priority settings in the NVIC. */</text><br/>
               <expr>leftPadding(`NVIC_SetPriority(`, 1) + ($this.hasOption(`irq_custom_name`) ? $this.optionValue(`irq_custom_name`) : (toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
                                                         ($this.hasOption(`irq_function`) ? ($this.hasOption(`irq_function_replace`)? (`_` + $this.optionValue(`irq_function_replace`)) : (`_` + $this.optionValue(`irq_function`))) : ``) +  
                                                         ($this.hasOption(`irq_channel`) ? (`_` + $this.optionValue(`irq_channel`)) : ``) +  
                                                         ($this.hasOption(`irq_channel_reference`) ? (`_` + $parent.irq_channel.getValue()) : ``)))) + 
                                                         toUpperCase(`_IRQn`) + 
                                           `, ` + 
                                            ($this.hasOption(`irq_custom_name`) ? $this.optionValue(`irq_custom_name`) : (toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + 
                                                         ($this.hasOption(`irq_function`) ? ($this.hasOption(`irq_function_replace`)? (`_` + $this.optionValue(`irq_function_replace`)) : (`_` + $this.optionValue(`irq_function`))) : ``) +  
                                                         ($this.hasOption(`irq_channel`) ? (`_` + $this.optionValue(`irq_channel`)) : ``) +  
                                                         ($this.hasOption(`irq_channel_reference`) ? (`_` + $parent.irq_channel.getValue()) : ``)))) + 
                                                         toUpperCase(`_IRQ_PRIORITY`)
                                        +`);`</expr><br/>
            </if>   
         </def>

         <!-- IRQn_enable fragment definition -->
         <!-- Parameters:
                  IRQn - ID of the interrupt request that is defined as the enum type in the IO maps of the MCU (MCU specific type)
                  irq_enabled - true or false - when true the EnableIRQ() function call is generated
         -->
         <def fragment="IRQn_enable" public="true">
            <assert expr="paramExists(`irq_enabled`)" message_expr="`The parameter irq_enable does not exists in the IRQn_enable fragment, component: ` + $instance.getID() + `config set:` + $this.getID()"/>
            <if expr="(paramExists(`irq_enabled`) &amp;&amp;  ($param.irq_enabled == true)) || (!paramExists(`irq_enabled`))">
               <expr>leftPadding(`/* Enable interrupt `, 1) </expr><expr>$param.IRQn</expr><text> request in the NVIC */</text><br/>
               <expr>leftPadding(`EnableIRQ(` + $param.IRQn + `);`, 1)</expr><br/>
            </if>
            <if expr="(paramExists(`irq_enabled`) &amp;&amp;  ($param.irq_enabled == false)) ">
               <expr>leftPadding(`/* Interrupt `, 1) </expr><expr>$param.IRQn</expr><text> request in the NVIC is not initialized (disabled by default). */</text><br/>
               <expr>leftPadding(`/* It can be enabled later by EnableIRQ(` + $param.IRQn + `); function call. */`, 1)</expr><br/>
            </if>
         </def>
         
         <!-- IRQn_set_priority fragment definition -->
         <!-- Parameters:
                  IRQn - ID of the interrupt request that is defined as the enum type in the IO maps of the MCU (MCU specific type)
                  priority - the interrupt vector priority number (range is defined according to CPU core type - CM4, CM0P,...)
         -->
         <def fragment="IRQn_set_priority" public="true">
            <expr>leftPadding(`/* Interrupt vector `, 1) + $param.IRQn</expr><text> priority settings in the NVIC */</text><br/>
            <expr>leftPadding(`NVIC_SetPriority(`, 1) + $param.IRQn + `, `+ $param.priority +`);`</expr><br/>
         </def>
         <!-- IRQn_handler_function fragment definition -->
         <!-- Generation of IRQ handler function based on copy to clipboard template  -->
         <def fragment="IRQn_handler_function" public="true">
            <if expr="$this.enableTemplateISR.getValue(false)">
               <expr>$this.copyToClipBoardText.getValue()</expr><br/>
            </if>
         </def>
      </fragment_defs>
      <code></code>
      <quick_selections>
      </quick_selections>
   </config_set>


   <!-- eDMA definition based on info item -->
   <config_set id="fsl_edma_peripheral" label="eDMA" from_source="fsl_common.h">
      <description>fsl eDMA channel request</description>
      <generated_types/>
      <user_types>
         <struct id="edma_channel_t" label="eDMA channel type" public="true">
            <string id="channel_prefix_id" label="Channel ID" available="$parent.hasOption(`channel_prefix_id`)">
               <description>The identifier that is used as a part of the channels defines in header file.</description>
               <validation>
                  <constraint cond_expr="isCIdentifier($this.getValue())" level="error" description="The prefix name is not valid C identifier!"/>
                  <constraint cond_expr="$components.system.#global.duplicit_edma_prefixes.getValue().countOccurrences(x->(x.getSetting(`channel_prefix_id`).getValue() == $this.getValue())) == 0" level="warning" description_expr="`The ID ` + $this.getValue() + ` is a duplicate.`"/>
               </validation>
            </string>
            <!-- FSL_FEATURE_EDMA_MODULE_CHANNEL feature define the number of the eDMA channels -->
            <integer type="uint8_t" id="eDMAn" label="eDMA channel" max_expr="(featureDefined(`FSL_FEATURE_EDMA_MODULE_CHANNEL`)? (getFeature(`FSL_FEATURE_EDMA_MODULE_CHANNEL`).toInt() - 1):255)">
               <description>The eDMA channel number of the eDMA device (the range is MCU specific)</description>
               <validation>
                  <constraint cond_expr="$components.system.#global.duplicit_edma_channels.getValue().noneMatch(x->(x.getSetting(`eDMAn`).getValue() == $this.getValue()))" 
                     level="warning" description_expr="`The eDMA channel ` + $this.getValue() + ` is used more than once.`"/>
               </validation>
            </integer>
            <!-- Available dma settings for all cores -->
            <variable id="dma_settings_list" value="(featureDefined(`SOC_EDMA_COUNT`) &amp;&amp; getFeature(`SOC_EDMA_COUNT`)) ? 
               $components.system.#global.core_ids.getValue().flatMap(x->getResource(`dmamux`,x).filter(
               enumItem -> (enumItem.getSetting(`devices`).anyMatch(
               item -> (((!$parent.hasOption(`dma_function`)) || ($parent.optionValue(`dma_function`) ==``) || (item.getSetting(`function`).getValue() == $parent.optionValue(`dma_function`))) &amp;&amp; 
               ((!$parent.hasOption(`dma_channel`)) || (item.getSetting(`channel`).getValue() == $parent.optionValue(`dma_channel`)))  &amp;&amp;
               (($parent.hasOption(`all_devices`)) || (item.getSetting(`device`).getValue() == ($parent.hasOption(`device`) ? $parent.optionValue(`device`) : $instance.getPeripheral()))))
               )))) : createArray()"></variable>
            <!-- Available dma settings for current core -->
            <variable id="core_dma_settings" value="$parent.dma_settings_list.getValue().filter(x -> x.getParent().getID() == $instance.getCoreId())"></variable>
            <variable id="isDmaSrcValid" value="(featureDefined(`SOC_EDMA_COUNT`) &amp;&amp; getFeature(`SOC_EDMA_COUNT`)) &amp;&amp; $parent.eDMA_source.getValue() != `` &amp;&amp; $parent.eDMA_source.getValue() != `none` &amp;&amp; $parent.eDMA_source.getValue() != `otherCoreDma`"></variable>
            <dynamic_enum id="eDMA_source" label="eDMA request" 
               items="$parent.dma_settings_list.getValue().size() != 0 
               ?  
                  ($parent.dma_settings_list.getValue().anyMatch(x -> x.getParent().getID() == $instance.getCoreId()) 
                  ?
                  $parent.core_dma_settings.getValue().arrayToEnumItems(
                  enumItem -> true, 
                  enumItem -> enumItem.getSetting(`id`).getValue(),
                  enumItem -> `#` + enumItem.getSetting(`requestNumber`).getValue() + `: `+ enumItem.getSetting(`label`).getValue(),
                  enumItem -> enumItem.getSetting(`requestNumber`).getValue())
                     .addItemToList(`dmaMuxDisable`, `DMAMUX disable`,`dmaMuxDisable_` + $parent.dma_prefix_define.getValue() + $parent.getParent().getId(), $parent.hasOption(`all_devices`) &amp;&amp; featureDefined(`SOC_DMAMUX_COUNT`) &amp;&amp; (getFeature(`SOC_DMAMUX_COUNT`) != 0))
                     .addItemToList(`dmaMuxAlwaysOn`, `DMAMUX always on`,`dmaMuxAlwaysOn_` + $parent.dma_prefix_define.getValue()+ $parent.getParent().getId(), $parent.hasOption(`all_devices`) &amp;&amp; featureDefined(`DMAMUX_HAS_A_ON`) &amp;&amp; getFeature(`DMAMUX_HAS_A_ON`) != 0)
                  : 
                  createArray().addItemToList(`otherCoreDma`, `eDMA not supported on ` + system::getCoreName($instance.getCoreID()) + ` core`, 0, true, `No eDMA request supported on ` + system::getCoreName($instance.getCoreID()) + ` core`))
               :
               createArray().addItemToList(`none`, `eDMA not supported`, ``, true, `No eDMA request is supported`)"
               available="!$parent.hasOption(`without_dmamux_init`) || ($parent.hasOption(`without_dmamux_init`) &amp;&amp; ($parent.optionValue(`without_dmamux_init`) == `false`))">  <!-- Item ID, label and value (identifier) are last three parameters of the arrayToEnumItems function -->
               <description>
eDMA source of request *(#request number)* that is muxed through the DMAMUX device.  

*Note:* If the **DMAMUX disable** option is available, it supports the use without the source of the eDMA request and without the enabled channel in DMAMUX.
               </description>
               <validation>
                  <constraint cond_expr="$this.getCValue() != ``" level="error" description="A DMAMUX channel (eDMA request) must be selected."/>
                  <constraint cond_expr="$this.getCValue() != `none`" level="error" description_expr="`eDMA is not supported for ` + $instance.getPeripheral() + ` peripheral.`"/>
                  <constraint cond_expr="$this.getCValue() != `otherCoreDma`" level="error" description_expr="`eDMA request for ` + $instance.getPeripheral() + ` peripheral is supported on different core.`"/>
                  <constraint when_expr="$parent.isDmaSrcValid.getValue()" cond_expr="$components.system.#global.duplicit_edma_requests.getValue().noneMatch(x->(x.getSetting(`eDMA_source`).getEnumItemValue() == $this.getEnumItemValue()))" 
                     level="warning" description_expr="`The eDMA request #` + $this.getEnumItemValue() + ` is used more than once.`"/>
               </validation>
            </dynamic_enum>            
            <variable id="enableTrigger" value="($parent.enableDmamuxTrigger.isAvailable() &amp;&amp; $parent.enableDmamuxTrigger.isEnabled() &amp;&amp; $parent.enableDmamuxTrigger.getValue()) || 
               ($parent.enableTriggerPIT.isAvailable() &amp;&amp; $parent.enableTriggerPIT.isEnabled() &amp;&amp; $parent.enableTriggerPIT.getValue()) || 
               ($parent.enableTriggerInput.isAvailable() &amp;&amp; $parent.enableTriggerInput.isEnabled() &amp;&amp; $parent.enableTriggerInput.getValue())">
            </variable>
            <bool id="enableDmamuxTrigger" label="Enable periodic trigger" available="(!$parent.hasOption(`without_periodic_trigger`)) &amp;&amp; queryFeature(`PeripheralUnifiedSignal`, $parent.dmamux_instance.getValue() + `.dmamux_trig.0`, `Exists`) &amp;&amp; featureDefined(`DMAMUX_HAS_TRIG`) &amp;&amp; getFeature(`DMAMUX_HAS_TRIG`) != 0 "
               enable="queryFeature(`PeripheralUnifiedSignal`, $parent.dmamux_instance.getValue() + `.dmamux_trig.` + $parent.eDMAn.getValue(), `Exists`)">
               <description>
Channels can provide a special periodic triggering capability that can be used to provide an automatic mechanism to transmit bytes, frames, or packets at fixed intervals without the need for processor intervention.  
*NOTE:* The trigger configuration is done in Pins tool.
               </description>
               <validation>
                  <dependency when_expr="$this.getValue()"
                     resource_type="PeripheralUnifiedSignal" level="Warning"
                     resource_id_expr="$parent.dmamux_instance.getValue() + `.dmamux_trig.` + $parent.eDMAn.getValue()"
                     description_expr="`DMAMUX trigger ` + $parent.eDMAn.getValue() + ` is not routed.`">
                     <feature name="routed">
                        <data expr="true"></data>
                     </feature>
                  </dependency>
               </validation>
            </bool>
            <bool id="enableTriggerPIT" label="Enable periodic trigger" available="(!$parent.hasOption(`without_periodic_trigger`)) &amp;&amp; featureDefined(`PIT_TIMER_COUNT`) &amp;&amp; featureDefined(`DMAMUX_HAS_TRIG`) &amp;&amp; getFeature(`DMAMUX_HAS_TRIG`) != 0 &amp;&amp; !$parent.enableDmamuxTrigger.isAvailable()"
               enable="featureDefined(`PIT_TIMER_COUNT`) &amp;&amp; getFeature(`PIT_TIMER_COUNT`) &gt; $parent.eDMAn.getValue()">
               <description>The first 4 channels of the DMAMUX (0-3) provide a special periodic triggering capability that can be used to provide an automatic mechanism to transmit bytes, frames, or packets at fixed intervals without the need for processor intervention.
                  The trigger is generated by the periodic interrupt timer (PIT); as such, the configuration of the periodic triggering interval is done via configuration registers in the PIT.
               </description>
               <validation>
                  <constraint when_expr="$this.getValue()" cond_expr="$components.system.#global.all_enabled_instances.getValue().anyMatch(x -> 
                     (x.isCalledFromDefaultInit() &amp;&amp; (x.getType() == `pit` || x.getType() == `pit_reg`)) ||
                     (x.getFnGroupName() == $instance.getFnGroupName() &amp;&amp; (x.getType() == `pit` || x.getType() == `pit_reg`)))"
                     level="warning" description_expr="`Missing PIT component initialization for DMA trigger. Initialize PIT channel ` + $parent.eDMAn.getValue() +` in the project into default or the same initialization functional group in which the `+ $parent.dma_instance.getValue() +` component is located.`"/>        
               </validation>
            </bool>
            <bool id="enableTriggerInput" label="Enable periodic trigger" available="(!$parent.hasOption(`without_periodic_trigger`)) &amp;&amp; featureDefined(`DMAMUX_HAS_TRIG`) &amp;&amp; getFeature(`DMAMUX_HAS_TRIG`) != 0 &amp;&amp; !$parent.enableTriggerPIT.isAvailable() &amp;&amp; !$parent.enableDmamuxTrigger.isAvailable()"
               enable="$parent.eDMAn.getValue() &lt; 4">
               <description>
The first 4 channels of the DMAMUX (0-3) provide a special periodic triggering capability that can be used to provide an automatic mechanism to transmit bytes, frames, or packets at fixed intervals without the need for processor intervention.  
  
**NOTE:** *Please, check the trigger configuration in Pins tool. The selected channel trigger might require routing.*
               </description>
            </bool>
            <info id="triggerChannelInfo" label="Required PIT channel" value="$parent.eDMAn.getValue()" available="$parent.enableTriggerPIT.isAvailable() &amp;&amp; $parent.enableTriggerPIT.isEnabled() &amp;&amp; $parent.enableTriggerPIT.getValue()">
               <description>The trigger is generated by the periodic interrupt timer (PIT), which requires specific PIT channel to be initialized. (e.g. eDMA channel 2 requires PIT channel 2)</description>
            </info>
            <bool id="init_channel_priority" label="Preemption and priority initialization" options="UI_LABEL_BOLD" available="!$parent.hasOption(`without_priority`)">
               <description>Enables the channel priority initialization. Channel preemption allows the executing channel's data transfers to temporarily suspend in favor of starting a higher priority channel.
                  After the preempting channel has completed all its minor loop data transfers, the preempted channel is restored and resumes execution. After the restored channel completes one read/write sequence, it is again eligible for preemption. If any higher priority channel is requesting service, the restored channel is suspended and the higher priority channel is serviced.
                  Nested preemption, that is, attempting to preempt a preempting channel, is not supported.
               </description>
            </bool>
            <struct id="edma_channel_Preemption" label="eDMA channel priority configuration" options="UI_LABEL_HIDDEN"
               enable="$parent.init_channel_priority.isAvailable() &amp;&amp; $parent.init_channel_priority.getValue()" available="!$parent.hasOption(`without_priority`)">
               <bool id="enableChannelPreemption" label="Enable channel preemption">
                  <description>If enabled the channel can be suspended by other channel service request with higher priority.
                     If disabled channel cannot be suspended by a higher priority channel's service request.
                  </description>
               </bool>
               <bool id="enablePreemptAbility" label="Enable preempt ability">
                  <description>If enabled the channel can suspend other channel with lower priority. 
                     If disabled channel cannot suspend any channel, regardless of channel priority.
                  </description>
               </bool>
               <integer id="channelPriority" label="Channel arbitration priority" type="uint8_t" max_expr="15">
                  <description>
Channel arbitration priority (fixed-priority arbitration, when round-robin arbitration is disabled).
- the **highest** priority: **15**
- the **lowest** priority : **0**
                  </description>
               </integer>
            </struct>
            <bool id="enable_custom_name" label="Enable custom handle name" available="!($parent.hasOption(`without_handle`) &amp;&amp; $parent.getOptionValue(`without_handle`)) &amp;&amp; !$parent.hasOption(`force_custom_name`)">
               <description>When this option is enabled a user custom name of the eDMA handle is allowed to set in the settings below.
               </description>
            </bool>
            <string id="handle_custom_name" label="Handle name" available="!($parent.hasOption(`without_handle`) &amp;&amp; $parent.getOptionValue(`without_handle`)) &amp;&amp; ($parent.hasOption(`force_custom_name`) || ($parent.enable_custom_name.isAvailable() &amp;&amp; $parent.enable_custom_name.isAvailable() &amp;&amp; $parent.enable_custom_name.getValue()))">
               <description>The eDMA handle is used for processing of DMA requests. </description>
               <validation>
                  <constraint cond_expr="isCIdentifier($this.getValue())" level="error" description_expr="`The handle name: `+ $this.getCValue() +` is not valid C identifier!`"/>
                  <constraint cond_expr="$components.system.#global.duplicit_ids.getValue().noneMatch(x -> x.getValue() == $this.getValue())" level="warning" description_expr="`The handle name ` + $this.getValue() + ` is a duplicate.`"/>  
               </validation>
            </string>
            <info id="handle_default_name" label="Handle name" value="($parent.hasOption(`force_custom_name`) || ($parent.enable_custom_name.isAvailable() &amp;&amp; $parent.enable_custom_name.getValue())) ? $parent.handle_custom_name.getValue() : 
               $instance.getFnGroupPrefix() + $instance.getID() + 
               (($parent.hasOption(`dma_function`) &amp;&amp; ($parent.optionValue(`dma_function`) !=``)) ? (`_` + $parent.optionValue(`dma_function`)) : ``) +  
               ($parent.hasOption(`dma_channel`) ? (`_` + ($parent.hasOption(`dma_channel_name`) ? $parent.optionValue(`dma_channel_name`) : $parent.optionValue(`dma_channel`))) : ``) + 
               ($parent.hasOption(`channel_prefix_id`) ? (`_` + $parent.channel_prefix_id.getValue()) : ``) +
               ($parent.hasOption(`suffix_id`) ? (`_` + $parent.optionValue(`suffix_id`)) : ``) + 
               `_Handle`" available="!($parent.hasOption(`without_handle`) &amp;&amp; $parent.getOptionValue(`without_handle`)) &amp;&amp; (!$parent.hasOption(`force_custom_name`)) &amp;&amp; (!$parent.enable_custom_name.getValue())">
               <validation>
                  <constraint cond_expr="isCIdentifier($this.getValue())" level="error" description="The handle name is not valid C identifier!"/>
                  <constraint cond_expr="$components.system.#global.duplicit_ids.getValue().noneMatch(x -> x.getValue() == $this.getValue())" level="warning" description_expr="`The handle name ` + $this.getValue() + ` is a duplicate.`"/>  
               </validation>
            </info>
            <variable id="eDMA_handle" value="!($parent.hasOption(`without_handle`) &amp;&amp; $parent.getOptionValue(`without_handle`)) ? (($parent.hasOption(`force_custom_name`) || ($parent.enable_custom_name.isAvailable() &amp;&amp; $parent.enable_custom_name.getValue())) ? $parent.handle_custom_name.getValue() : $parent.handle_default_name.getValue()) : `N/A`" options="id_check"></variable>
            <variable id="init_dma_reference" value="$components.system.#global.all_enabled_instances.getValue().filter(x -> 
               x.getPeripheral() == $parent.dma_instance.getValue()).filter(x -> x.isCalledFromDefaultInit() || x.getFnGroupName() == $instance.getFnGroupName())"></variable>
            <info id="dma_component_ref" label="eDMA initialization reference" available="$instance.getPeripheral() != $parent.dma_instance.getValue() &amp;&amp; $parent.init_dma_reference.getValue().size() != 0"
               value="($parent.init_dma_reference.getValue().size() != 0 
               ? (($parent.init_dma_reference.getValue().anyMatch(i -> i.getFnGroupName() == $instance.getFnGroupName()) 
               ? ($parent.init_dma_reference.getValue().findFirst(i -> i.getFnGroupName() == $instance.getFnGroupName()).getLabel())
               : ($parent.init_dma_reference.getValue().findFirst(i -> i.isCalledFromDefaultInit()).getLabel())) + ` setting`) 
               : (`Missing ` + $parent.dma_instance.getValue() + ` peripheral initialization`))">
               <options_expr>
                  <option id="UI_SETTING_LINK" expr="$parent.init_dma_reference.getValue().size() != 0 ? ($parent.init_dma_reference.getValue().anyMatch(i -> i.getFnGroupName() == $instance.getFnGroupName()) ? $parent.init_dma_reference.getValue().findFirst(i -> i.getFnGroupName() == $instance.getFnGroupName()) : $parent.init_dma_reference.getValue().findFirst(i -> i.isCalledFromDefaultInit())) : $configSet" available="$parent.init_dma_reference.getValue().size() != 0"/>
                  <option id="UI_REFRESH"/>
               </options_expr>
               <description expr="`&#10;Setting reference of the eDMA peripheral component instance and DMAMUX peripheral configuration used in initialization, which calls *EDMA_Init()* and *DMAMUX_Init()* functions and includes the required SDK drivers.  &#10;
                  &#10;The **`+ $parent.dma_instance.getValue() +`** peripheral of the eDMA component must be initialized in one of the following functional groups:  &#10;`+  
                  `- in the default initialization functional group: *` + ($root.anyMatch(x -> x.isCalledFromDefaultInit()) ? $root.findFirst(x -> x.isCalledFromDefaultInit()).getID() : `no functional group is called by default initialization function`) + `*  &#10;` +
                  `- in the same functional group as ` + $instance.getPeripheral() + ` peripheral: *` + $group.getID() +`*`
                  "/>
            </info>
            <info id="dma_dependency" label_expr="$parent.dma_component_ref.getLabel()"
               available="$instance.getPeripheral() != $parent.dma_instance.getValue() &amp;&amp; $parent.init_dma_reference.getValue().size() == 0"
               value="`Missing ` + $parent.dma_instance.getValue() + ` peripheral initialization`">
               <description expr="$parent.dma_component_ref.getDescription()"></description>
               <validation>
                  <dependency resource_type="Peripheral" level="error" 
                     description_expr="`Missing eDMA component. Add ` + $parent.dma_instance.getValue() +` instance to the project into default or the same initialization functional group in which the `+ $instance.getID() +` peripheral component is located.`" resource_id_expr="$parent.dma_instance.getValue()">
                     <feature name="initialized" evaluation="equal">
                        <data expr="true" type="Boolean"/>
                     </feature>
                  </dependency>
                  <constraint cond_expr="$instance.getPeripheral() != $parent.dma_instance.getValue() &amp;&amp; 
                     $components.system.#global.all_enabled_instances.getValue().anyMatch(x -> 
                     (x.isCalledFromDefaultInit() || x.getFnGroupName() == $instance.getFnGroupName()) &amp;&amp;
                     x.getPeripheral() == $parent.dma_instance.getValue())" level="error" 
                     description_expr="$parent.dma_instance.getValue() + ` is not initialized in default or the same initialization functional group as ` + $instance.getID() + ` component.`"/>
               </validation>
            </info>
<!--            <variable id="dmamux_instance" value="getResource(`dmamux`, $instance.getCoreId()).findFirst(item -> (item.getSetting(`id`).getValue() == $parent.eDMA_source.getCValue())).getSetting(`dmamux_dev`).getValue()"></variable>-->
            <variable id="dmamux_instance" value="(featureDefined(`SOC_EDMA_COUNT`) &amp;&amp; getFeature(`SOC_EDMA_COUNT`)) ?
               ($parent.hasOption(`without_dmamux_init`) &amp;&amp; ($parent.optionValue(`without_dmamux_init`) != `false`)) ? `` : (getResource(`dmamux`, $instance.getCoreId()).countOccurrences(item -> (item.getSetting(`id`).getValue() == $parent.eDMA_source.getCValue())) &lt;= 0) ? getResource(`dmamux`, `dmaMuxInfo`).findFirst(item -> (item.getSetting(`dmaDevice`).getValue() == $parent.dma_instance.getValue())).getSetting(`muxDevice`).getValue() : getResource(`dmamux`, $instance.getCoreId()).findFirst(item -> (item.getSetting(`id`).getValue() == $parent.eDMA_source.getCValue())).getSetting(`dmamux_dev`).getValue()
                : `N/A`" 
                available="!$parent.hasOption(`without_dmamux_init`) || ($parent.hasOption(`without_dmamux_init`) &amp;&amp; ($parent.optionValue(`without_dmamux_init`) == `false`))"></variable>
<!--            <info label="DMA instance" id="dma_instance" value="`DMA` + getResource(`dmamux`, $instance.getCoreId()).findFirst(item -> (item.getSetting(`id`).getValue() == $parent.eDMA_source.getCValue())).getSetting(`dmamux_dev`).getValue().regexSubstr(`.*DMAMUX(\d*)`,1)"></info>-->
            <variable id="dma_instance" value="(featureDefined(`SOC_EDMA_COUNT`) &amp;&amp; getFeature(`SOC_EDMA_COUNT`)) ?
                getResource(`dmamux`, `dmaMuxInfo`).findFirst(item -> (($parent.hasOption(`without_dmamux_init`) &amp;&amp; ($parent.optionValue(`without_dmamux_init`) != `false`)) || (getResource(`dmamux`, $instance.getCoreId()).countOccurrences(item -> (item.getSetting(`id`).getValue() == $parent.eDMA_source.getCValue())) &lt;= 0) ? (item.getSetting(`cores`).getValue() == $instance.getCoreId()) : (item.getSetting(`muxDevice`).getValue() == $parent.dmamux_instance.getValue()))).getSetting(`dmaDevice`).getValue()
                : `N/A`"></variable>
            <!-- Substitution of the CMSIS alias that is used in the Kinetis IO maps if the there is the DMA device the CMSIS alias is DMA0 (in the IO map)  -->
            <variable id="dma_cmsis_instance" value="($parent.dma_instance.getValue() == `DMA`) ? `DMA0` : $parent.dma_instance.getValue()"></variable>
            <!-- Variables for representation of definitions-->
            <variable id="dma_request_define" value="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
               (($parent.hasOption(`dma_function`) &amp;&amp; ($parent.optionValue(`dma_function`) !=``)) ? (`_` + $parent.optionValue(`dma_function`)) : ``) +  
               ($parent.hasOption(`dma_channel`) ? (`_` + ($parent.hasOption(`dma_channel_name`) ? $parent.optionValue(`dma_channel_name`) : $parent.optionValue(`dma_channel`))) : ``) +
               ($parent.hasOption(`channel_prefix_id`) ? (`_` + $parent.channel_prefix_id.getValue()) : ``) +
               ($parent.hasOption(`suffix_id`) ? (`_` + $parent.optionValue(`suffix_id`)) : ``) +
               `_DMA_REQUEST`)" ></variable>
            <variable id="dma_channel_define" value="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
               (($parent.hasOption(`dma_function`) &amp;&amp; ($parent.optionValue(`dma_function`) !=``)) ? (`_` + $parent.optionValue(`dma_function`)) : ``) +  
               ($parent.hasOption(`dma_channel`) ? (`_` + ($parent.hasOption(`dma_channel_name`) ? $parent.optionValue(`dma_channel_name`) : $parent.optionValue(`dma_channel`))) : ``) +  
               ($parent.hasOption(`channel_prefix_id`) ? (`_` + $parent.channel_prefix_id.getValue()) : ``) +
               ($parent.hasOption(`suffix_id`) ? (`_` + $parent.optionValue(`suffix_id`)) : ``) +
               `_DMA_CHANNEL`)" ></variable>
            <variable id="dmamux_base_define" value="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
               (($parent.hasOption(`dma_function`) &amp;&amp; ($parent.optionValue(`dma_function`) !=``)) ? (`_` + $parent.optionValue(`dma_function`)) : ``) +  
               ($parent.hasOption(`dma_channel`) ? (`_` + ($parent.hasOption(`dma_channel_name`) ? $parent.optionValue(`dma_channel_name`) : $parent.optionValue(`dma_channel`))) : ``) +  
               ($parent.hasOption(`suffix_id`) ? (`_` + $parent.optionValue(`suffix_id`)) : ``) +
               `_DMAMUX_BASEADDR`)" ></variable>
            <variable id="dma_base_define" value="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
               (($parent.hasOption(`dma_function`) &amp;&amp; ($parent.optionValue(`dma_function`) !=``)) ? (`_` + $parent.optionValue(`dma_function`)) : ``) +  
               ($parent.hasOption(`dma_channel`) ? (`_` + ($parent.hasOption(`dma_channel_name`) ? $parent.optionValue(`dma_channel_name`) : $parent.optionValue(`dma_channel`))) : ``) +  
               ($parent.hasOption(`suffix_id`) ? (`_` + $parent.optionValue(`suffix_id`)) : ``) +
               `_DMA_BASEADDR`)" ></variable>
            <variable id="dma_preemption_config" value="$parent.dma_prefix_define.getValue() + `_preemption_config`"></variable>
            <variable id="dma_prefix_define" value="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
               (($parent.hasOption(`dma_function`) &amp;&amp; ($parent.optionValue(`dma_function`) !=``)) ? (`_` + $parent.optionValue(`dma_function`)) : ``) +  
               ($parent.hasOption(`dma_channel`) ? (`_` + ($parent.hasOption(`dma_channel_name`) ? $parent.optionValue(`dma_channel_name`) : $parent.optionValue(`dma_channel`))) : ``) +
               ($parent.hasOption(`channel_prefix_id`) ? (`_` + $parent.channel_prefix_id.getValue()) : ``) +
               ($parent.hasOption(`suffix_id`) ? (`_` + $parent.optionValue(`suffix_id`)) : ``))" ></variable>
         </struct>
      </user_types>
      <settings>
      </settings>
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="common_code_templates"/>  
         </import>
         <!-- DMA macroprocessor definitions  
              The edma_channel_t structure must be handled as $this
         -->
         <def fragment="DMA_channel_definitions" public="true">
            <fragment id="define" if_expr="(!$this.hasOption(`without_dmamux_init`) || ($this.hasOption(`without_dmamux_init`) &amp;&amp; ($this.optionValue(`without_dmamux_init`) == `false`)))  &amp;&amp; ($this.eDMA_source.getValue()!=`dmaMuxDisable` &amp;&amp; $this.eDMA_source.getValue()!=`dmaMuxAlwaysOn`)">
               <param id="name" expr="$this.dma_request_define.getValue()"/>
               <param id="value" expr="$this.eDMA_source.getValue()"/> 
               <param id="description" expr="$instance.getID() + ` eDMA source request.`"/>
            </fragment>
            <fragment id="define">
               <param id="name" expr="$this.dma_channel_define.getValue()"/>
               <param id="value" expr="$this.eDMAn.getCValue()"/> 
               <param id="description" expr="`Selected eDMA channel number.`"/>
            </fragment>
         </def>
         
         <def fragment="DMA_definitions" public="true">
            <fragment id="define" if_expr="(!$this.hasOption(`without_dmamux_init`) || ($this.hasOption(`without_dmamux_init`) &amp;&amp; ($this.optionValue(`without_dmamux_init`) == `false`))) &amp;&amp; ($this.eDMA_source.getValue()!=`dmaMuxDisable` &amp;&amp; $this.eDMA_source.getValue()!=`dmaMuxAlwaysOn`)">
               <param id="name" expr="$this.dma_request_define.getValue()"/>
               <param id="value" expr="$this.eDMA_source.getValue()"/> 
               <param id="description" expr="$instance.getID() + ` eDMA source request.`"/>
            </fragment>
            <fragment id="define">
               <param id="name" expr="$this.dma_channel_define.getValue()"/>
               <param id="value" expr="$this.eDMAn.getCValue()"/> 
               <param id="description" expr="`Selected eDMA channel number.`"/>
            </fragment>
            <fragment id="define" if_expr="(!$this.hasOption(`without_dmamux_init`) || ($this.hasOption(`without_dmamux_init`) &amp;&amp; ($this.optionValue(`without_dmamux_init`) == `false`)))">
               <param id="name" expr="$this.dmamux_base_define.getValue()"/>
               <param id="value" expr="$this.dmamux_instance.getValue()"/> 
               <param id="description" expr="`DMAMUX device that is used for muxing of the request.`"/>
            </fragment>
            <fragment id="define">
               <param id="name" expr="$this.dma_base_define.getValue()"/>
               <param id="value" expr="$this.dma_cmsis_instance.getValue()"/> 
               <param id="description" expr="`Used DMA device.`"/>
            </fragment>
         </def>
         <def fragment="DMAMUX_handle_declaration" public="true">
            <fragment id="extern_var" if_expr="($this.eDMA_handle.getValue() != `N/A`)">
               <param id="name" expr="$this.eDMA_handle.getValue()"/> 
               <param id="type" expr="`edma_handle_t`"/>
            </fragment>
            <fragment id="extern_const_var" if_expr="$this.init_channel_priority.isAvailable() &amp;&amp; $this.init_channel_priority.getValue()">
               <param id="name" expr="$this.dma_preemption_config.getValue()"/> 
               <param id="type" expr="`edma_channel_Preemption_config_t`"/>
            </fragment>
         </def>   
         <def fragment="DMA_handle_definition" public="true">
            <fragment id="global_var" if_expr="($this.eDMA_handle.getValue() != `N/A`)" >
               <param id="name" expr="$this.eDMA_handle.getValue()"/> 
               <param id="type" expr="`edma_handle_t`"/>
            </fragment>
            <fragment id="const_struct" apply_to="$this.edma_channel_Preemption" if_expr="$this.init_channel_priority.isAvailable() &amp;&amp; $this.init_channel_priority.getValue()">
               <param id="name" expr="$parent.dma_preemption_config.getValue()" />
               <param id="type" >edma_channel_Preemption_config_t</param>
            </fragment>
         </def>   
         <def fragment="DMAMUX_source_init" public="true">
            <if expr="$this.eDMA_source.getValue() != `dmaMuxDisable`">  
               <if expr="$this.eDMA_source.getValue() != `dmaMuxAlwaysOn`">    
                  <expr>leftPadding(`/* Set the source `, 1)</expr><expr>$this.eDMA_source.getValue()</expr><text> request in the DMAMUX */</text><br/>
                     <expr>leftPadding(`DMAMUX_SetSource(`, 1) +  $this.dmamux_base_define.getValue() + `, `
                        + $this.dma_channel_define.getValue() + `, `
                        + $this.dma_request_define.getValue() 
                        + `);`
                     </expr><br/>
               </if>
            </if>
            <fragment id="init_line" if_expr="$this.eDMA_source.getValue() == `dmaMuxAlwaysOn`">
               <param id="code" expr="`DMAMUX_EnableAlwaysOn(` + $this.dmamux_base_define.getValue() + `, ` + $this.dma_channel_define.getValue() + `, true);`"></param>
               <param id="description" expr="`Set the DMA channel` + $this.eDMAn.getValue() + ` always on`"></param>
               <param id="paddingLevel" expr="1"></param>  
            </fragment>
            <fragment id="init_line" if_expr="$this.enableTrigger.isAvailable() &amp;&amp; $this.enableTrigger.isEnabled() &amp;&amp; $this.enableTrigger.getValue()">
               <param id="code" expr="`DMAMUX_EnablePeriodTrigger(` + $this.dmamux_base_define.getValue() + `, ` + $this.dma_channel_define.getValue() + `);`"></param>
               <param id="description" expr="`Set the DMA channel ` + $this.eDMAn.getValue() + ` periodic trigger`"></param>
               <param id="paddingLevel" expr="1"></param>  
            </fragment>
            <fragment id="init_line" if_expr="$this.eDMA_source.getValue() != `dmaMuxDisable`">
               <param id="code" expr="`DMAMUX_EnableChannel(` + $this.dmamux_base_define.getValue() + `, ` + $this.dma_channel_define.getValue() + `);`"></param>
               <param id="description" expr="`Enable the channel ` + $this.eDMAn.getValue() + ` in the DMAMUX`"></param>
               <param id="paddingLevel" expr="1"></param>  
            </fragment>
            <fragment id="init_line" if_expr="$this.init_channel_priority.isAvailable() &amp;&amp; $this.init_channel_priority.getValue()">
               <param id="code" expr="`EDMA_SetChannelPreemptionConfig(` + $this.dma_base_define.getValue() + `, ` + $this.dma_channel_define.getValue() + `, &amp;` + $this.dma_preemption_config.getValue() +`);`"></param>
               <param id="description" expr="`Set the DMA ` + $this.eDMAn.getValue() + `channel priority`"></param>
               <param id="paddingLevel" expr="1"></param>  
            </fragment>
         </def>
         <def fragment="DMA_handle_init" public="true">
            <if expr="($this.eDMA_handle.getValue() != `N/A`)">
               <expr>leftPadding(`/* Create the eDMA `, 1)</expr><expr>$this.eDMA_handle.getValue()</expr><text> handle */</text><br/>
               <expr>leftPadding(`EDMA_CreateHandle(&amp;`, 1) + $this.eDMA_handle.getValue() + `, `  
                  + $this.dma_base_define.getValue() + `, `
                  + $this.dma_channel_define.getValue()
                  + `);`</expr><br/>
            </if>
         </def>
      </fragment_defs>
      <code></code>
      <quick_selections>
      </quick_selections>
   </config_set>
   
   <!-- DMA config set definition -->
   <config_set id="fsl_dma_peripheral" label="DMA" from_source="fsl_common.h">
      <description>fsl DMA channel request</description>
      <generated_types/>
      <user_types>
         <struct id="dma_channel_t" label="DMA channel type" public="true">
            <string id="channel_prefix_id" label="Channel ID" available="$parent.hasOption(`channel_prefix_id`)">
               <description>The identifier that is used as a part of the channels defines in header file.</description>
               <validation>
                  <constraint cond_expr="isCIdentifier($this.getValue())" level="error" description="The prefix name is not valid C identifier!"/>
                  <constraint cond_expr="$components.system.#global.duplicit_dma_prefixes.getValue().countOccurrences(x->(x.getSetting(`channel_prefix_id`).getValue() == $this.getValue())) == 0" level="warning" description_expr="`The ID ` + $this.getValue() + ` is a duplicate.`"/>
               </validation>
            </string>
            <!-- FSL_FEATURE_DMA_MODULE_CHANNEL feature define the number of the DMA channels -->
            <integer type="uint8_t" id="DMAn" label="DMA channel" max_expr="(featureDefined(`FSL_FEATURE_DMA_MODULE_CHANNEL`) ? (getFeature(`FSL_FEATURE_DMA_MODULE_CHANNEL`).toInt()-1) : 255)">
               <description>The DMA channel number of the DMA device (the range is MCU specific)</description>
               <validation>
               <constraint cond_expr="$components.system.#global.duplicit_dma_channels.getValue().noneMatch(x->(x.getSetting(`DMAn`).getValue() == $this.getValue()))" 
                     level="warning" description_expr="`The DMA channel ` + $this.getValue() + ` is used more than once.`"/>
               </validation>
            </integer>
            <!-- Available dma settings for all cores -->
            <variable id="dma_settings_list" value="(featureDefined(`SOC_DMA_COUNT`) &amp;&amp; getFeature(`SOC_DMA_COUNT`) &amp;&amp; featureDefined(`SOC_DMAMUX_COUNT`) &amp;&amp; getFeature(`SOC_DMAMUX_COUNT`)) ? 
               $components.system.#global.core_ids.getValue().flatMap(x->getResource(`dmamux`,x).filter(
               enumItem -> (enumItem.getSetting(`devices`).anyMatch(
               item -> (((!$parent.hasOption(`dma_function`)) || ($parent.optionValue(`dma_function`) ==``) || (item.getSetting(`function`).getValue() == $parent.optionValue(`dma_function`))) &amp;&amp; 
               ((!$parent.hasOption(`dma_channel`)) || (item.getSetting(`channel`).getValue() == $parent.optionValue(`dma_channel`)))  &amp;&amp;
               (($parent.hasOption(`all_devices`)) || (item.getSetting(`device`).getValue() == ($parent.hasOption(`device`) ? $parent.optionValue(`device`) : $instance.getPeripheral()))))
               )))) : createArray()"></variable>
            <!-- Available dma settings for current core -->
            <variable id="core_dma_settings" value="$parent.dma_settings_list.getValue().filter(x -> x.getParent().getID() == $instance.getCoreId())"></variable>
            <variable id="isDmaSrcValid" value="(featureDefined(`SOC_DMA_COUNT`) &amp;&amp; getFeature(`SOC_DMA_COUNT`) &amp;&amp; featureDefined(`SOC_DMAMUX_COUNT`) &amp;&amp; getFeature(`SOC_DMAMUX_COUNT`)) &amp;&amp; $parent.DMA_source.getValue() != `` &amp;&amp; $parent.DMA_source.getValue() != `none` &amp;&amp; $parent.DMA_source.getValue() != `otherCoreDma`"></variable>
            <dynamic_enum id="DMA_source" label="DMA request" 
               items="$parent.dma_settings_list.getValue().size() != 0 
               ?  
               ($parent.dma_settings_list.getValue().anyMatch(x -> x.getParent().getID() == $instance.getCoreId()) 
               ?
               $parent.core_dma_settings.getValue().arrayToEnumItems(
               enumItem -> true, 
               enumItem -> enumItem.getSetting(`id`).getValue(),
               enumItem -> `#` + enumItem.getSetting(`requestNumber`).getValue() + `: `+ enumItem.getSetting(`label`).getValue(),
               enumItem -> enumItem.getSetting(`requestNumber`).getValue())
               : 
               createArray().addItemToList(`otherCoreDma`, `DMA not supported on ` + system::getCoreName($instance.getCoreID()) + ` core`, 0, true, `No DMA request supported on ` + system::getCoreName($instance.getCoreID()) + ` core`))
               :
               createArray().addItemToList(`none`, `DMA not supported`, ``, true, `No DMA request is supported`)"
               available="!$parent.hasOption(`without_dmamux_init`) || ($parent.hasOption(`without_dmamux_init`) &amp;&amp; ($parent.optionValue(`without_dmamux_init`) == `false`))">  <!-- Item ID, label and value (identifier) are last three parameters of the arrayToEnumItems function -->
               <description>
DMA source of request *(#request number)* that is muxed through the DMAMUX device.  

*Note:* If the **DMAMUX disable** option is available, it supports the use without the source of the DMA request and without the enabled channel in DMAMUX.
               </description>
               <validation>
                  <constraint cond_expr="$this.getCValue() != ``" level="error" description="A DMAMUX channel (eDMA request) must be selected."/>
                  <constraint cond_expr="$this.getCValue() != `none`" level="error" description_expr="`DMA is not supported for ` + $instance.getPeripheral() + ` peripheral.`"/>
                  <constraint cond_expr="$this.getCValue() != `otherCoreDma`" level="error" description_expr="`DMA request for ` + $instance.getPeripheral() + ` peripheral is supported on different core.`"/>
                  <constraint when_expr="$parent.isDmaSrcValid.getValue()" cond_expr="$components.system.#global.duplicit_dma_requests.getValue().noneMatch(x->(x.getSetting(`DMA_source`).getEnumItemValue() == $this.getEnumItemValue()))" 
                     level="warning" description_expr="`The DMA request #` + $this.getEnumItemValue() + ` is used more than once.`"/>
               </validation>
            </dynamic_enum>
            <bool id="enable_custom_name" label="Enable custom handle name" available="!($parent.hasOption(`without_handle`) &amp;&amp; $parent.getOptionValue(`without_handle`)) &amp;&amp; !$parent.hasOption(`force_custom_name`)">
               <description>When this option is enabled a user custom name of the DMA handle is allowed to set in the settings below.
               </description>
            </bool>
            <string id="handle_custom_name" label="Handle name" available="!($parent.hasOption(`without_handle`) &amp;&amp; $parent.getOptionValue(`without_handle`)) &amp;&amp; ($parent.hasOption(`force_custom_name`) || ($parent.enable_custom_name.isAvailable() &amp;&amp; $parent.enable_custom_name.getValue()))">
               <description>The DMA handle is used for processing of DMA requests. </description>
               <validation>
                  <constraint cond_expr="isCIdentifier($this.getValue())" level="error" description_expr="`The handle name: `+ $this.getCValue() +` is not valid C identifier!`"/>
                  <constraint cond_expr="$components.system.#global.duplicit_ids.getValue().noneMatch(x -> x.getValue() == $this.getValue())" level="warning" description_expr="`The handle name ` + $this.getValue() + ` is a duplicate.`"/>  
               </validation>
            </string>
            <info id="handle_default_name" label="Handle name" value="($parent.hasOption(`force_custom_name`) || $parent.enable_custom_name.getValue()) ? $parent.handle_custom_name.getValue() : 
               $instance.getFnGroupPrefix() + $instance.getID() + 
               (($parent.hasOption(`dma_function`) &amp;&amp; ($parent.optionValue(`dma_function`) !=``)) ? (`_` + $parent.optionValue(`dma_function`)) : ``) +  
               ($parent.hasOption(`dma_channel`) ? (`_` + ($parent.hasOption(`dma_channel_name`) ? $parent.optionValue(`dma_channel_name`) : $parent.optionValue(`dma_channel`))) : ``) + 
               ($parent.hasOption(`channel_prefix_id`) ? (`_` + $parent.channel_prefix_id.getValue()) : ``) +
               ($parent.hasOption(`suffix_id`) ? (`_` + $parent.optionValue(`suffix_id`)) : ``) + 
               `_Handle`" available="!($parent.hasOption(`without_handle`) &amp;&amp; $parent.getOptionValue(`without_handle`)) &amp;&amp; ((!$parent.hasOption(`force_custom_name`)) &amp;&amp; (!$parent.enable_custom_name.getValue()))">
               <validation>
                  <constraint cond_expr="isCIdentifier($this.getValue())" level="error" description="The handle name is not valid C identifier!"/>
                  <constraint cond_expr="$components.system.#global.duplicit_ids.getValue().noneMatch(x -> (x.getValue() == $this.getValue()))" level="warning" description_expr="`The handle name ` + $this.getValue() + ` is a duplicate.`"/>  
               </validation>
            </info>
            <variable id="DMA_handle" value="!($parent.hasOption(`without_handle`) &amp;&amp; $parent.getOptionValue(`without_handle`)) ? ($parent.hasOption(`force_custom_name`) || $parent.enable_custom_name.getValue()) ? $parent.handle_custom_name.getValue() : $parent.handle_default_name.getValue() : `N/A`" options="id_check"></variable>
            <variable id="dmamux_instance" value="
                (featureDefined(`SOC_DMA_COUNT`) &amp;&amp; getFeature(`SOC_DMA_COUNT`) &amp;&amp; featureDefined(`SOC_DMAMUX_COUNT`) &amp;&amp; getFeature(`SOC_DMAMUX_COUNT`)) ?
                    ($parent.hasOption(`without_dmamux_init`) &amp;&amp; ($parent.optionValue(`without_dmamux_init`) != `false`)) || (getResource(`dmamux`, $instance.getCoreId()).countOccurrences(item -> (item.getSetting(`id`).getValue() == $parent.DMA_source.getCValue())) &lt;= 0) ? `` : getResource(`dmamux`, $instance.getCoreId()).findFirst(item -> (item.getSetting(`id`).getValue() == $parent.DMA_source.getCValue())).getSetting(`dmamux_dev`).getValue()
                    : `N/A`"
                available="!$parent.hasOption(`without_dmamux_init`) || ($parent.hasOption(`without_dmamux_init`) &amp;&amp; ($parent.optionValue(`without_dmamux_init`) == `false`))"></variable>
            <variable id="dma_instance" value="
                (featureDefined(`SOC_DMA_COUNT`) &amp;&amp; getFeature(`SOC_DMA_COUNT`) &amp;&amp; featureDefined(`SOC_DMAMUX_COUNT`) &amp;&amp; getFeature(`SOC_DMAMUX_COUNT`)) ?
                    getResource(`dmamux`, `dmaMuxInfo`).findFirst(item -> (($parent.hasOption(`without_dmamux_init`) &amp;&amp; ($parent.optionValue(`without_dmamux_init`) != `false`)) || (getResource(`dmamux`, $instance.getCoreId()).countOccurrences(item -> (item.getSetting(`id`).getValue() == $parent.DMA_source.getCValue())) &lt;= 0) ? (item.getSetting(`cores`).getValue() == $instance.getCoreId()) : (item.getSetting(`muxDevice`).getValue() == $parent.dmamux_instance.getValue()))).getSetting(`dmaDevice`).getValue()
                    : `N/A`"></variable>
            <variable id="init_dma_reference" value="$components.system.#global.all_enabled_instances.getValue().filter(x -> 
               x.getPeripheral() == $parent.dma_instance.getValue()).filter(x -> x.isCalledFromDefaultInit() || x.getFnGroupName() == $instance.getFnGroupName())"></variable>
            <info id="dma_component_ref" label="DMA initialization reference" available="$instance.getPeripheral() != $parent.dma_instance.getValue() &amp;&amp; $parent.init_dma_reference.getValue().size() != 0"
               value="($parent.init_dma_reference.getValue().size() != 0 
               ? (($parent.init_dma_reference.getValue().anyMatch(i -> i.getFnGroupName() == $instance.getFnGroupName()) 
               ? ($parent.init_dma_reference.getValue().findFirst(i -> i.getFnGroupName() == $instance.getFnGroupName()).getLabel())
               : ($parent.init_dma_reference.getValue().findFirst(i -> i.isCalledFromDefaultInit()).getLabel())) + ` setting`) 
               : (`Missing ` + $parent.dma_instance.getValue() + ` peripheral initialization`))">
               <options_expr>
                  <option id="UI_SETTING_LINK" expr="$parent.init_dma_reference.getValue().size() != 0 ? ($parent.init_dma_reference.getValue().anyMatch(i -> i.getFnGroupName() == $instance.getFnGroupName()) ? $parent.init_dma_reference.getValue().findFirst(i -> i.getFnGroupName() == $instance.getFnGroupName()) : $parent.init_dma_reference.getValue().findFirst(i -> i.isCalledFromDefaultInit())) : $configSet" available="$parent.init_dma_reference.getValue().size() != 0"/>
                  <option id="UI_REFRESH"/>
               </options_expr>
               <description expr="`&#10;Setting reference of the DMA peripheral component instance and DMAMUX peripheral configuration used in initialization, which calls *DMA_Init()* and *DMAMUX_Init()* functions and includes the required SDK drivers.  &#10;
                  &#10;The **`+ $parent.dma_instance.getValue() +`** peripheral of the DMA component must be initialized in one of the following functional groups:  &#10;`+  
                  `- in the default initialization functional group: *` + ($root.anyMatch(x -> x.isCalledFromDefaultInit()) ? $root.findFirst(x -> x.isCalledFromDefaultInit()).getID() : `no functional group is called by default initialization function`) + `*  &#10;` +
                  `- in the same functional group as ` + $instance.getPeripheral() + ` peripheral: *` + $group.getID() +`*`
                  "/>
            </info>
            <info id="dma_dependency" label_expr="$parent.dma_component_ref.getLabel()"
               available="$instance.getPeripheral() != $parent.dma_instance.getValue() &amp;&amp; $parent.init_dma_reference.getValue().size() == 0"
               value="`Missing ` + $parent.dma_instance.getValue() + ` peripheral initialization`">
               <description expr="$parent.dma_component_ref.getDescription()"></description>
               <validation>
                  <dependency resource_type="Peripheral" level="error" 
                     description_expr="`Missing DMA component. Add ` + $parent.dma_instance.getValue() +` instance to the project into default or the same initialization functional group in which the `+ $instance.getID() +` peripheral component is located.`" resource_id_expr="$parent.dma_instance.getValue()">
                     <feature name="initialized" evaluation="equal">
                        <data expr="true" type="Boolean"/>
                     </feature>
                  </dependency>
                  <constraint cond_expr="$instance.getPeripheral() != $parent.dma_instance.getValue() &amp;&amp; 
                     $components.system.#global.all_enabled_instances.getValue().anyMatch(x -> 
                     (x.isCalledFromDefaultInit() || x.getFnGroupName() == $instance.getFnGroupName()) &amp;&amp;
                     x.getPeripheral() == $parent.dma_instance.getValue())" level="error" 
                     description_expr="$parent.dma_instance.getValue() + ` is not initialized in default or the same initialization functional group as ` + $instance.getID() + ` component.`"/>
               </validation>
            </info>
            <!-- Substitution of the CMSIS alias that is used in the Kinetis IO maps if the there is the DMA device the CMSIS alias is DMA0 (in the IO map)  -->
            <variable id="dma_cmsis_instance" value="($parent.dma_instance.getValue() == `DMA`) ? `DMA0` : $parent.dma_instance.getValue()"></variable>
            <!-- Variables for representation of definitions-->
            <variable id="dma_request_define" value="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
               (($parent.hasOption(`dma_function`) &amp;&amp; ($parent.optionValue(`dma_function`) !=``)) ? (`_` + $parent.optionValue(`dma_function`)) : ``) +  
               ($parent.hasOption(`dma_channel`) ? (`_` + ($parent.hasOption(`dma_channel_name`) ? $parent.optionValue(`dma_channel_name`) : $parent.optionValue(`dma_channel`))) : ``) +
               ($parent.hasOption(`channel_prefix_id`) ? (`_` + $parent.channel_prefix_id.getValue()) : ``) +
               ($parent.hasOption(`suffix_id`) ? (`_` + $parent.optionValue(`suffix_id`)) : ``) +
               `_DMA_REQUEST`)" ></variable>
            <variable id="dma_channel_define" value="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
               (($parent.hasOption(`dma_function`) &amp;&amp; ($parent.optionValue(`dma_function`) !=``)) ? (`_` + $parent.optionValue(`dma_function`)) : ``) +  
               ($parent.hasOption(`dma_channel`) ? (`_` + ($parent.hasOption(`dma_channel_name`) ? $parent.optionValue(`dma_channel_name`) : $parent.optionValue(`dma_channel`))) : ``) +  
               ($parent.hasOption(`channel_prefix_id`) ? (`_` + $parent.channel_prefix_id.getValue()) : ``) +
               ($parent.hasOption(`suffix_id`) ? (`_` + $parent.optionValue(`suffix_id`)) : ``) +
               `_DMA_CHANNEL`)" ></variable>
            <variable id="dmamux_base_define" value="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
               (($parent.hasOption(`dma_function`) &amp;&amp; ($parent.optionValue(`dma_function`) !=``)) ? (`_` + $parent.optionValue(`dma_function`)) : ``) +  
               ($parent.hasOption(`dma_channel`) ? (`_` + ($parent.hasOption(`dma_channel_name`) ? $parent.optionValue(`dma_channel_name`) : $parent.optionValue(`dma_channel`))) : ``) +  
               ($parent.hasOption(`suffix_id`) ? (`_` + $parent.optionValue(`suffix_id`)) : ``) +
               `_DMAMUX_BASEADDR`)" ></variable>
            <variable id="dma_base_define" value="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
               (($parent.hasOption(`dma_function`) &amp;&amp; ($parent.optionValue(`dma_function`) !=``)) ? (`_` + $parent.optionValue(`dma_function`)) : ``) +  
               ($parent.hasOption(`dma_channel`) ? (`_` + ($parent.hasOption(`dma_channel_name`) ? $parent.optionValue(`dma_channel_name`) : $parent.optionValue(`dma_channel`))) : ``) +  
               ($parent.hasOption(`suffix_id`) ? (`_` + $parent.optionValue(`suffix_id`)) : ``) +
               `_DMA_BASEADDR`)" ></variable>
            <variable id="dma_prefix_define" value="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
               (($parent.hasOption(`dma_function`) &amp;&amp; ($parent.optionValue(`dma_function`) !=``)) ? (`_` + $parent.optionValue(`dma_function`)) : ``) +  
               ($parent.hasOption(`dma_channel`) ? (`_` + ($parent.hasOption(`dma_channel_name`) ? $parent.optionValue(`dma_channel_name`) : $parent.optionValue(`dma_channel`))) : ``) +
               ($parent.hasOption(`channel_prefix_id`) ? (`_` + $parent.channel_prefix_id.getValue()) : ``) +
               ($parent.hasOption(`suffix_id`) ? (`_` + $parent.optionValue(`suffix_id`)) : ``))" ></variable>
         </struct>
      </user_types>
      <settings>
      </settings>
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="common_code_templates"/>  
         </import>
         <!-- DMA macroprocessor definitions  
              The dma_channel_t structure must be handled as $this
         -->
         <def fragment="DMA_channel_definitions" public="true">
            <fragment id="define" if_expr="(!$this.hasOption(`without_dmamux_init`) || ($this.hasOption(`without_dmamux_init`) &amp;&amp; ($this.optionValue(`without_dmamux_init`) == `false`)))">
               <param id="name" expr="$this.dma_request_define.getValue()"/>
               <param id="value" expr="$this.DMA_source.getValue()"/> 
               <param id="description" expr="$instance.getID() + ` DMA source request.`"/>
            </fragment>
            <fragment id="define">
               <param id="name" expr="$this.dma_channel_define.getValue()"/>
               <param id="value" expr="$this.DMAn.getCValue()"/> 
               <param id="description" expr="`Selected DMA channel number.`"/>
            </fragment>
         </def>
         
         <def fragment="DMA_definitions" public="true">
            <fragment id="define" if_expr="(!$this.hasOption(`without_dmamux_init`) || ($this.hasOption(`without_dmamux_init`) &amp;&amp; ($this.optionValue(`without_dmamux_init`) == `false`)))">
               <param id="name" expr="$this.dma_request_define.getValue()"/>
               <param id="value" expr="$this.DMA_source.getValue()"/> 
               <param id="description" expr="$instance.getID() + ` DMA source request.`"/>
            </fragment>
            <fragment id="define">
               <param id="name" expr="$this.dma_channel_define.getValue()"/>
               <param id="value" expr="$this.DMAn.getCValue()"/> 
               <param id="description" expr="`Selected DMA channel number.`"/>
            </fragment>
            <fragment id="define" if_expr="(!$this.hasOption(`without_dmamux_init`) || ($this.hasOption(`without_dmamux_init`) &amp;&amp; ($this.optionValue(`without_dmamux_init`) == `false`)))">
               <param id="name" expr="$this.dmamux_base_define.getValue()"/>
               <param id="value" expr="$this.dmamux_instance.getValue()"/> 
               <param id="description" expr="`DMAMUX device that is used for muxing of the request.`"/>
            </fragment>
            <fragment id="define">
               <param id="name" expr="$this.dma_base_define.getValue()"/>
               <param id="value" expr="$this.dma_cmsis_instance.getValue()"/> 
               <param id="description" expr="`Used DMA device.`"/>
            </fragment>
         </def>
         <def fragment="DMAMUX_handle_declaration" public="true">
            <fragment id="extern_var" if_expr="($this.DMA_handle.getValue() != `N/A`)">
               <param id="name" expr="$this.DMA_handle.getValue()"/> 
               <param id="type" expr="`dma_handle_t`"/>
            </fragment>
         </def>   
         <def fragment="DMA_handle_definition" public="true">
            <fragment id="global_var" if_expr="($this.DMA_handle.getValue() != `N/A`)">
               <param id="name" expr="$this.DMA_handle.getValue()"/> 
               <param id="type" expr="`dma_handle_t`"/>
            </fragment>
         </def>   
         <def fragment="DMAMUX_source_init" public="true">
               <expr>leftPadding(`/* Set the source `, 1)</expr><expr>$this.DMA_source.getValue()</expr><text> request in the DMAMUX */</text><br/>
               <expr>leftPadding(`DMAMUX_SetSource(`, 1) +  $this.dmamux_base_define.getValue() + `, `
                  + $this.dma_channel_define.getValue() + `, `
                  + $this.dma_request_define.getValue() 
                  + `);`</expr><br/>
               <expr>leftPadding(`/* Enable the `, 1)</expr><expr>$this.DMAn.getValue()</expr><text> channel in the DMAMUX */</text><br/>
               <expr>leftPadding(`DMAMUX_EnableChannel(`, 1) +  $this.dmamux_base_define.getValue() + `, `
                  + $this.dma_channel_define.getValue() 
                  + `);`</expr><br/>
         </def>
         <def fragment="DMA_handle_init" public="true">
            <if expr="($this.DMA_handle.getValue() != `N/A`)">
               <expr>leftPadding(`/* Create the DMA `, 1)</expr><expr>$this.DMA_handle.getValue()</expr><text> handle */</text><br/>
               <expr>leftPadding(`DMA_CreateHandle(&amp;`, 1) + $this.DMA_handle.getValue() + `, `  
                  + $this.dma_base_define.getValue() + `, `
                  + $this.dma_channel_define.getValue()
                  + `);`</expr><br/>
            </if>
         </def>
      </fragment_defs>
      <code></code>
      <quick_selections>
      </quick_selections>
   </config_set>
  <!-- LPC DMA config set -->
  <config_set id="fsl_lpc_dma_peripheral" label="DMA" from_source="fsl_dma.h">
      <description>fsl LPC DMA channel request</description>
      <generated_types/>
      <user_types>
         <struct id="dma_channel_t" label="DMA channel type" public="true">
            <string id="channel_prefix_id" label="Channel ID" available="$parent.hasOption(`channel_prefix_id`)">
               <description>The identifier that is used as a part of the channels defines in header file.</description>
               <validation>
                  <constraint cond_expr="isCIdentifier($this.getValue())" level="error" description="The prefix name is not valid C identifier!"/>
                  <constraint cond_expr="$components.system.#global.duplicit_dma_prefixes.getValue().countOccurrences(x->(x.getSetting(`channel_prefix_id`).getValue() == $this.getValue())) == 0" level="warning" description_expr="`The ID ` + $this.getValue() + ` is a duplicate.`"/>
               </validation>
            </string>
            <!-- Available dma settings for all cores -->
            <variable id="dma_settings_list" value="(featureDefined(`SOC_DMA_COUNT`) &amp;&amp; getFeature(`SOC_DMA_COUNT`) &amp;&amp; !(featureDefined(`SOC_DMAMUX_COUNT`) &amp;&amp; getFeature(`SOC_DMAMUX_COUNT`)))
               ? 
               $components.system.#global.core_ids.getValue().flatMap(x->getResource(`dma`, x).filter(
               enumItem -> (enumItem.getSetting(`devices`).searchInArray(
               item -> (((!$parent.hasOption(`dma_function`)) || ($parent.optionValue(`dma_function`) ==``) || (item.getSetting(`function`).getValue() == $parent.optionValue(`dma_function`))) &amp;&amp; 
               ((!$parent.hasOption(`dma_channel`)) || (item.getSetting(`channel`).getValue() == $parent.optionValue(`dma_channel`)))  &amp;&amp;
               (($parent.hasOption(`all_devices`)) || (item.getSetting(`device`).getValue() == ($parent.hasOption(`device`) ? $parent.optionValue(`device`) : $instance.getPeripheral()))))
               ) >= 0 ) &amp;&amp;
               (((!$parent.hasOption(`dma_device`)) || (enumItem.getSetting(`dma_dev`).getValue() == $parent.optionValue(`dma_device`)))))) 
               : createArray()"></variable>
            <!-- Available dma settings for current core -->
            <variable id="core_dma_settings" value="$parent.dma_settings_list.getValue().filter(x -> x.getParent().getID() == $instance.getCoreId())"></variable>
            <variable id="isDmaSrcValid" value="(featureDefined(`SOC_DMA_COUNT`) &amp;&amp; getFeature(`SOC_DMA_COUNT`) &amp;&amp; !(featureDefined(`SOC_DMAMUX_COUNT`) &amp;&amp; getFeature(`SOC_DMAMUX_COUNT`))) &amp;&amp; $parent.DMA_source.getValue() != `` &amp;&amp; $parent.DMA_source.getValue() != `none` &amp;&amp; $parent.DMA_source.getValue() != `otherCoreDma`"></variable>
            <dynamic_enum id="DMA_source" label="DMA request" 
               items="$parent.dma_settings_list.getValue().size() != 0 
               ?  
               ($parent.dma_settings_list.getValue().anyMatch(x -> x.getParent().getID() == $instance.getCoreId()) 
               ?
               $parent.core_dma_settings.getValue().arrayToEnumItems(
               enumItem -> true, 
               enumItem -> enumItem.getSetting(`id`).getValue(),
               enumItem -> ((getPeripherals(`DMA`).size() &gt; 1) ? (enumItem.getSetting(`dma_dev`).getValue() + ` : `) : ``) + enumItem.getSetting(`label`).getValue(),
               enumItem -> enumItem.getSetting(`requestNumber`).getValue())
               : 
               createArray().addItemToList(`otherCoreDma`, `DMA not supported on ` + system::getCoreName($instance.getCoreID()) + ` core`, 0, true, `No DMA request supported on ` + system::getCoreName($instance.getCoreID()) + ` core`))
               :
               createArray().addItemToList(`none`, `DMA not supported`, ``, true, `No DMA request is supported`)">  <!-- Item ID, label and value (identifier) are last three parameters of the arrayToEnumItems function -->
               <description>
DMA source of request that is assigned to a DMA channel.  
               </description>
               <validation>
                  <constraint cond_expr="$this.getCValue() != ``" level="error" description="DMA request must be selected."/>
                  <constraint cond_expr="$this.getCValue() != `none`" level="error" description_expr="`DMA is not supported for ` + $instance.getPeripheral() + ` peripheral.`"/>
                  <constraint cond_expr="$this.getCValue() != `otherCoreDma`" level="error" description_expr="`DMA request for ` + $instance.getPeripheral() + ` peripheral is supported on different core.`"/>
                  <constraint when_expr="$parent.isDmaSrcValid.getValue()" cond_expr="$components.system.#global.duplicit_dma_requests.getValue().noneMatch(x -> (x.getSetting(`DMA_source`).getCValue() == $this.getCValue()))" 
                     level="warning" description_expr="`The DMA channel's ` + $this.getEnumItemValue() + ` request is used more than once.`"/>
               </validation>
            </dynamic_enum>
            <info id="DMAn" label="DMA channel" value="$parent.DMA_source.getCValue() != `` ? getResource(`dma`, $instance.getCoreId()).findFirst(item -> (item.getSetting(`id`).getValue() == $parent.DMA_source.getCValue())).getSetting(`requestNumber`).getValue() : `N/A`">
               <description>The DMA channel number of the DMA device that is selected according to the device (the DMA request settings)</description>
               <!-- Validation of channel in case of separate channels from requests (possible with future NPIs) -->
               <!--<validation>
                  <constraint when_expr="TBD" cond_expr="$components.system.#global.duplicit_dma_channels.getValue().noneMatch(x->(x.getSetting(`DMAn`).getValue() == $this.getValue()))" 
                     level="warning" description_expr="`The DMA channel ` + $this.getValue() + ` is used more than once.`"/>
               </validation>-->
            </info>
            <bool id="init_channel_priority" label="Channel priority initialization" available="!$parent.hasOption(`without_priority`)">
               <description>Enables the channel priority initialization.</description>
            </bool>
            <enum id="dma_priority" label="DMA channel priority"  enable="$parent.init_channel_priority.isAvailable() &amp;&amp; $parent.init_channel_priority.getValue()" available="!$parent.hasOption(`without_priority`)">
               <description>
Selection of DMA chnnel priority: 
  - the **highest** priority: **0**
  - the **lowest** priority : **7**
               </description>
               <item id="kDMA_ChannelPriority0" label="Priority 0">
                  <description>Channel priority 0 (Highest)</description>
               </item>
               <item id="kDMA_ChannelPriority1" label="Priority 1">
                  <description>Channel priority 1</description>
               </item>
               <item id="kDMA_ChannelPriority2" label="Priority 2">
                  <description>Channel priority 2</description>
               </item>
               <item id="kDMA_ChannelPriority3" label="Priority 3">
                  <description>Channel priority 3</description>
               </item>
               <item id="kDMA_ChannelPriority4" label="Priority 4">
                  <description>Channel priority 4</description>
               </item>
               <item id="kDMA_ChannelPriority5" label="Priority 5">
                  <description>Channel priority 5</description>
               </item>
               <item id="kDMA_ChannelPriority6" label="Priority 6">
                  <description>Channel priority 6</description>
               </item>
               <item id="kDMA_ChannelPriority7" label="Priority 7">
                  <description>Channel priority 7 (Lowest)</description>
               </item>
            </enum>
            <bool id="enable_custom_name" label="Enable custom handle name" available="!($parent.hasOption(`without_handle`) &amp;&amp; $parent.getOptionValue(`without_handle`)) &amp;&amp; !$parent.hasOption(`force_custom_name`)">
               <description>When this option is enabled a user custom name of the DMA handle is allowed to set in the settings below.
               </description>
            </bool>
            <string id="handle_custom_name" label="Handle name" available="!($parent.hasOption(`without_handle`) &amp;&amp; $parent.getOptionValue(`without_handle`)) &amp;&amp; ($parent.hasOption(`force_custom_name`) || ($parent.enable_custom_name.isAvailable() &amp;&amp; $parent.enable_custom_name.getValue()))">
               <description>The DMA handle is used for processing of DMA requests. </description>
               <validation>
                  <constraint cond_expr="isCIdentifier($this.getValue())" level="error" description_expr="`The handle name: `+ $this.getCValue() +` is not valid C identifier!`"/>
                  <constraint cond_expr="$components.system.#global.duplicit_ids.getValue().noneMatch(x -> x.getValue() == $this.getValue())" level="warning" description_expr="`The handle name ` + $this.getValue() + ` is a duplicate.`"/>  
               </validation>
            </string>
            <info id="handle_default_name" label="Handle name" value="($parent.hasOption(`force_custom_name`) || ($parent.enable_custom_name.isAvailable() &amp;&amp; $parent.enable_custom_name.getValue())) ? $parent.handle_custom_name.getValue() : 
               $instance.getFnGroupPrefix() + $instance.getID() + 
               (($parent.hasOption(`dma_function`) &amp;&amp; ($parent.optionValue(`dma_function`) !=``)) ? (`_` + $parent.optionValue(`dma_function`)) : ``) +  
               ($parent.hasOption(`dma_channel`) ? (`_` + ($parent.hasOption(`dma_channel_name`) ? $parent.optionValue(`dma_channel_name`) : $parent.optionValue(`dma_channel`))) : ``) + 
               ($parent.hasOption(`channel_prefix_id`) ? (`_` + $parent.channel_prefix_id.getValue()) : ``) +
               ($parent.hasOption(`suffix_id`) ? (`_` + $parent.optionValue(`suffix_id`)) : ``) + 
               `_Handle`" 
               available="!($parent.hasOption(`without_handle`) &amp;&amp; $parent.getOptionValue(`without_handle`)) &amp;&amp; (!$parent.hasOption(`force_custom_name`)) &amp;&amp; ($parent.enable_custom_name.isAvailable() &amp;&amp; !$parent.enable_custom_name.getValue())">
               <validation>
                  <constraint cond_expr="isCIdentifier($this.getValue())" level="error" description="The handle name is not valid C identifier!"/>
                  <constraint cond_expr="$components.system.#global.duplicit_ids.getValue().noneMatch(x -> x.getValue() == $this.getValue())" level="warning" description_expr="`The handle name ` + $this.getValue() + ` is a duplicate.`"/>  
               </validation>
            </info>
            <variable id="DMA_handle" value="!($parent.hasOption(`without_handle`) &amp;&amp; $parent.getOptionValue(`without_handle`)) ? ($parent.hasOption(`force_custom_name`) || ($parent.enable_custom_name.isAvailable() &amp;&amp; $parent.enable_custom_name.getValue())) ? $parent.handle_custom_name.getValue() : $parent.handle_default_name.getValue() : `N/A`" options="id_check"></variable>
            <variable id="dma_instance" value="
               (featureDefined(`SOC_DMA_COUNT`) &amp;&amp; getFeature(`SOC_DMA_COUNT`) &amp;&amp; (!(featureDefined(`SOC_DMAMUX_COUNT`) &amp;&amp; (getFeature(`SOC_DMAMUX_COUNT`))))) ?
                    ($parent.DMA_source.getCValue() != `` ? 
                        getResource(`dma`, $instance.getCoreId()).findFirst(item -> (item.getSetting(`id`).getValue() == $parent.DMA_source.getCValue())).getSetting(`dma_dev`).getValue() 
                        : `N/A`)
                    : `N/A`">
            </variable>
            <variable id="init_dma_reference" value="$components.system.#global.all_enabled_instances.getValue().filter(x -> 
               x.getPeripheral() == $parent.dma_instance.getValue()).filter(x -> x.isCalledFromDefaultInit() || x.getFnGroupName() == $instance.getFnGroupName())"></variable>
            <info id="dma_component_ref" label="DMA initialization reference" available="$instance.getPeripheral() != $parent.dma_instance.getValue() &amp;&amp; $parent.init_dma_reference.getValue().size() != 0"
               value="($parent.init_dma_reference.getValue().size() != 0 
                  ? (($parent.init_dma_reference.getValue().anyMatch(i -> i.getFnGroupName() == $instance.getFnGroupName()) 
                     ? ($parent.init_dma_reference.getValue().findFirst(i -> i.getFnGroupName() == $instance.getFnGroupName()).getLabel())
                     : ($parent.init_dma_reference.getValue().findFirst(i -> i.isCalledFromDefaultInit()).getLabel())) + ` setting`) 
                  : (`Missing ` + $parent.dma_instance.getValue() + ` peripheral initialization`))">
               <options_expr>
                  <option id="UI_SETTING_LINK" expr="$parent.init_dma_reference.getValue().size() != 0 ? ($parent.init_dma_reference.getValue().anyMatch(i -> i.getFnGroupName() == $instance.getFnGroupName()) ? $parent.init_dma_reference.getValue().findFirst(i -> i.getFnGroupName() == $instance.getFnGroupName()) : $parent.init_dma_reference.getValue().findFirst(i -> i.isCalledFromDefaultInit())) : $configSet" available="$parent.init_dma_reference.getValue().size() != 0"/>
                  <option id="UI_REFRESH"/>
               </options_expr>
               <description expr="`&#10;Setting reference of the DMA peripheral component instance configuration used in initialization, which calls *DMA_Init()* function and includes the required SDK driver.  &#10;
                  &#10;The **`+ $parent.dma_instance.getValue() +`** peripheral of the DMA component must be initialized in one of the following functional groups:  &#10;`+  
                  `- in the default initialization functional group: *` + ($root.anyMatch(x -> x.isCalledFromDefaultInit()) ? $root.findFirst(x -> x.isCalledFromDefaultInit()).getID() : `no functional group is called by default initialization function`) + `*  &#10;` +
                  `- in the same functional group as ` + $instance.getPeripheral() + ` peripheral: *` + $group.getID() +`*`
                  "/>
            </info>
            <info id="dma_dependency" label_expr="$parent.dma_component_ref.getLabel()"
               available="$instance.getPeripheral() != $parent.dma_instance.getValue() &amp;&amp; $parent.init_dma_reference.getValue().size() == 0"
               value="`Missing ` + $parent.dma_instance.getValue() + ` peripheral initialization`">
               <description expr="$parent.dma_component_ref.getDescription()"></description>
               <validation>
                  <dependency resource_type="Peripheral" level="error" 
                     description_expr="`Missing DMA component. Add ` + $parent.dma_instance.getValue() +` instance to the project into default or the same initialization functional group in which the `+ $instance.getID() +` peripheral component is located.`" resource_id_expr="$parent.dma_instance.getValue()">
                     <feature name="initialized" evaluation="equal">
                        <data expr="true" type="Boolean"/>
                     </feature>
                  </dependency>
                  <constraint cond_expr="$instance.getPeripheral() != $parent.dma_instance.getValue() &amp;&amp; 
                     $components.system.#global.all_enabled_instances.getValue().anyMatch(x -> 
                     (x.isCalledFromDefaultInit() || x.getFnGroupName() == $instance.getFnGroupName()) &amp;&amp;
                     x.getPeripheral() == $parent.dma_instance.getValue())" level="error" 
                     description_expr="$parent.dma_instance.getValue() + ` is not initialized in default or the same initialization functional group as ` + $instance.getID() + ` component.`"/>
               </validation>
            </info>
            <!-- Variables for representation of definitions-->
            <variable id="dma_request_define" value="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
               (($parent.hasOption(`dma_function`) &amp;&amp; ($parent.optionValue(`dma_function`) !=``)) ? (`_` + $parent.optionValue(`dma_function`)) : ``) +  
               ($parent.hasOption(`dma_channel`) ? (`_` + ($parent.hasOption(`dma_channel_name`) ? $parent.optionValue(`dma_channel_name`) : $parent.optionValue(`dma_channel`))) : ``) +
               ($parent.hasOption(`channel_prefix_id`) ? (`_` + $parent.channel_prefix_id.getValue()) : ``) +
               ($parent.hasOption(`suffix_id`) ? (`_` + $parent.optionValue(`suffix_id`)) : ``) +
               `_DMA_REQUEST`)" ></variable>
            <variable id="dma_channel_define" value="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
               (($parent.hasOption(`dma_function`) &amp;&amp; ($parent.optionValue(`dma_function`) !=``)) ? (`_` + $parent.optionValue(`dma_function`)) : ``) +  
               ($parent.hasOption(`dma_channel`) ? (`_` + ($parent.hasOption(`dma_channel_name`) ? $parent.optionValue(`dma_channel_name`) : $parent.optionValue(`dma_channel`))) : ``) +  
               ($parent.hasOption(`channel_prefix_id`) ? (`_` + $parent.channel_prefix_id.getValue()) : ``) +
               ($parent.hasOption(`suffix_id`) ? (`_` + $parent.optionValue(`suffix_id`)) : ``) +
               `_DMA_CHANNEL`)" ></variable>
            <variable id="dma_base_define" value="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
               (($parent.hasOption(`dma_function`) &amp;&amp; ($parent.optionValue(`dma_function`) !=``)) ? (`_` + $parent.optionValue(`dma_function`)) : ``) +  
               ($parent.hasOption(`dma_channel`) ? (`_` + ($parent.hasOption(`dma_channel_name`) ? $parent.optionValue(`dma_channel_name`) : $parent.optionValue(`dma_channel`))) : ``) +  
               ($parent.hasOption(`suffix_id`) ? (`_` + $parent.optionValue(`suffix_id`)) : ``) +
               `_DMA_BASEADDR`)" ></variable>
            <variable id="dma_prefix_define" value="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() +
               (($parent.hasOption(`dma_function`) &amp;&amp; ($parent.optionValue(`dma_function`) !=``)) ? (`_` + $parent.optionValue(`dma_function`)) : ``) +  
               ($parent.hasOption(`dma_channel`) ? (`_` + ($parent.hasOption(`dma_channel_name`) ? $parent.optionValue(`dma_channel_name`) : $parent.optionValue(`dma_channel`))) : ``) +
               ($parent.hasOption(`channel_prefix_id`) ? (`_` + $parent.channel_prefix_id.getValue()) : ``) +
               ($parent.hasOption(`suffix_id`) ? (`_` + $parent.optionValue(`suffix_id`)) : ``))" ></variable>
         </struct>
      </user_types>
      <settings>
      </settings>
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="common_code_templates"/>  
         </import>
         <!-- DMA macroprocessor definitions  
              The dma_channel_t structure must be handled as $this
         -->
         <def fragment="DMA_channel_definitions" public="true">
            <fragment id="define">
               <param id="name" expr="$this.dma_channel_define.getValue()"/>
               <param id="value" expr="$this.DMAn.getValue()"/> 
               <param id="description" expr="`Selected DMA channel number.`"/>
            </fragment>
         </def>  
         <def fragment="DMA_definitions" public="true">
            <fragment id="define">
               <param id="name" expr="$this.dma_channel_define.getValue()"/>
               <param id="value" expr="$this.DMAn.getValue()"/> 
               <param id="description" expr="`Selected DMA channel number.`"/>
            </fragment>
            <fragment id="define">
               <param id="name" expr="$this.dma_base_define.getValue()"/>
               <param id="value" expr="$this.dma_instance.getValue()"/> 
               <param id="description" expr="`Used DMA device.`"/>
            </fragment>
         </def>
         <def fragment="DMA_handle_declaration" public="true">
            <fragment id="extern_var" if_expr="($this.DMA_handle.getValue() != `N/A`)">
               <param id="name" expr="$this.DMA_handle.getValue()"/> 
               <param id="type" expr="`dma_handle_t`"/>
            </fragment>
         </def>   
         <def fragment="DMA_handle_definition" public="true">
            <fragment id="global_var" if_expr="($this.DMA_handle.getValue() != `N/A`)">
               <param id="name" expr="$this.DMA_handle.getValue()"/> 
               <param id="type" expr="`dma_handle_t`"/>
            </fragment>
         </def>   
         <def fragment="DMA_source_init" public="true">
            <fragment id="init_line">
               <param id="code" expr="`DMA_EnableChannel(` + $this.dma_base_define.getValue() + `, ` + $this.dma_channel_define.getValue() + `);`"></param>
               <param id="description" expr="`Enable the DMA ` + $this.DMAn.getValue() + `channel in the DMA`"></param>
               <param id="paddingLevel" expr="1"></param>               
            </fragment>
            <fragment id="init_line" if_expr="$this.init_channel_priority.isAvailable() &amp;&amp; $this.init_channel_priority.getValue()">
               <param id="code" expr="`DMA_SetChannelPriority(` + $this.dma_base_define.getValue() + `, ` + $this.dma_channel_define.getValue() + `, ` + $this.dma_priority.getValue() +`);`"></param>
               <param id="description" expr="`Set the DMA ` + $this.DMAn.getValue() + `channel priority`"></param>
               <param id="paddingLevel" expr="1"></param>  
            </fragment>
         </def>
         <def fragment="DMA_handle_init" public="true">
            <fragment id="init_line" if_expr="($this.DMA_handle.getValue() != `N/A`)">
               <param id="code" expr="`DMA_CreateHandle(&amp;` + $this.DMA_handle.getValue() + `, ` + $this.dma_base_define.getValue() + `, ` + $this.dma_channel_define.getValue() + `);`"></param>
               <param id="description" expr="`Create the DMA ` + $this.DMA_handle.getValue() + `handle`"></param>
               <param id="paddingLevel" expr="1"></param>               
            </fragment>
         </def>
      </fragment_defs>
      <code></code>
      <quick_selections>
      </quick_selections>
   </config_set>


   <config_set id="common_code_templates" label="Common code templates." from_source="all">
      <description>Common code templates.</description>
      <generated_types/>
      <user_types/>
      <settings>
         <bool id="code" label="code"/>
      </settings>
      <fragment_defs>
         <!-- REGISTER INITIALIZATION FRAGMENTS -->
         <!-- Fragment provide clock gate enable code for register initialization for the current instance of the peripheral component ($instance.getPeripheral())  
            Parameters:
               submodule - name of the submodule (optional parameter)
               paddingLevel - padding level of the code (optional parameter, default level is 1)
          --> 
         <def fragment="clock_gate_enable_init" public="true">
            <expr>leftPadding(`/* Enable clock gate of the ` + $instance.getPeripheral() + ` peripheral. */`, paramExists(`paddingLevel`) ? $param.paddingLevel : 1)</expr><br/>
            <expr>leftPadding(system::getClockGateEnable($instance.getPeripheral(),paramExists(`submodule`) ? $param.submodule : ``), paramExists(`paddingLevel`) ? $param.paddingLevel : 1)</expr><br/>
         </def>
         <!-- Fragment provide definition of the specified register for register initialization for current instance of the peripheral  
            Parameters:
               periphName - name of the peripheral
               regName - name of the register
               name - name of the definition
          --> 
         <def fragment="def_reg_init" public="true">
            <expr>system::getFullRegDefine($param.periphName, $param.regName, $param.name)</expr>
         </def>
         <!-- Fragment provide definition of all registers of current instance of peripheral  
            Parameters:
               name - prefix name of each definition
          -->         
         <def fragment="all_regs_init" public="true">
            <expr>getRegisters($instance.getPeripheral())
               .sort((a,b) -> getRegisterAddress($instance.getPeripheral(),a) - getRegisterAddress($instance.getPeripheral(),b))
               .map(reg -> system::getFullRegDefine($instance.getPeripheral(), reg, $param.name + `_` + reg + `_INIT`)).reduce(``,(last, i) -> last + i)</expr>
         </def>
         <!-- Fragment provide definition of all registers of current instance of peripheral and apply regular expression filter on the name of registers.  
            Parameters:
               name - prefix name of each definition
               filter - regular expression string that is applied on names of registers.
                        Example of regular expressions
                        `(?!MOD).*` - all registers except the MOD
                        `CTRL|CNTR` - only registers CTRL and CNTR
                -->
         <def fragment="filtered_regs_init" public="true">
            <expr>getRegisters($instance.getPeripheral()).filter(i -> i.regexMatch($param.filter))
               .sort((a,b) -> getRegisterAddress($instance.getPeripheral(),a) - getRegisterAddress($instance.getPeripheral(),b))
               .map(reg -> system::getFullRegDefine($instance.getPeripheral(), reg, $param.name + `_` + reg + `_INIT`)).reduce(``,(last, i) -> last + i)</expr>
         </def>
         <!-- REGISTER INITIALIZATION FRAGMENTS FOR ASSIGNED REGISTERS AND BITFIELDS -->
         <!-- Fragment provide definition of the specified register for register initialization for current instance of the peripheral. 
            Assigned (used) bitfields are included in the comment definition only.
            Parameters:
               node - node of component (for example: $instance, $configSet, a setting of a config set)
               periphName - name of the peripheral
               regName - name of the register
               name - name of the definition
          --> 
         <def fragment="def_assigned_reg_init" public="true">
            <expr>system::getAssignedRegDefine($param.node, $param.periphName, $param.regName, $param.name)</expr>
         </def>
         <!-- Fragment provides definition of the specified register for register initialization for specific setting of the peripheral. 
            The setting option "custom_value" is used for overwriting assigned register value
            Parameters:
               node - setting node of the asssigned register (e.g $configSet.register), whose option "custom_assign" overwrites assigned register value
               name - name of the definition 
            Example option:
            <options_expr>
                 <option id="custom_assign" expr="$this.getValue()" available="!$this.getValue().isInt()"></option>
             </options_expr>
         --> 
         <def fragment="custom_reg_init" public="true">
            <expr if_expr="$param.node.isAvailable() &amp;&amp; $param.node.isEnabled()">
               getAssignedPeripherals($param.node).map(peripheral -> 
               getAssignedRegisters($param.node, peripheral)
               .sort((a,b) -> getRegisterAddress(peripheral,a) - getRegisterAddress(peripheral,b))
               .map(reg -> system::getAssignedRegOrCustomDefine($param.node, peripheral, reg, $param.name + `_` + reg + `_INIT`)).reduce(``,(last, i) -> last + i)
               ).reduce(``,(last, i) -> last + i)</expr>
         </def>
         <!-- Fragment provide definition of assigned registers of current instance of the peripheral component and instance of peripheral.  
            Only assigned (used) bitfields are included in the comment definition.
            Parameters:
               name - prefix name of each definition
          -->         
         <def fragment="all_assigned_regs_init" public="true">
            <expr>getAssignedRegisters($instance, $instance.getPeripheral())
               .sort((a,b) -> getRegisterAddress($instance.getPeripheral(),a) - getRegisterAddress($instance.getPeripheral(),b))
               .map(reg -> system::getAssignedRegDefine($instance, $instance.getPeripheral(), reg, $param.name + `_` + reg + `_INIT`)).reduce(``,(last, i) -> last + i)</expr>
         </def>
         <!-- Fragment provide definition of all registers of current instance of peripheral and apply regular expression filter on the name of registers.  
            Only assigned (used) bitfields are included in the comment definition.
            Parameters:
               name - prefix name of each definition
               filter - regular expression string that is applied on names of registers.
                        Example of regular expressions
                        `(?!MOD).*` - all registers except the MOD
                        `CTRL|CNTR` - only registers CTRL and CNTR
                -->
         <def fragment="filtered_assigned_regs_init" public="true">
            <expr>getAssignedRegisters($instance, $instance.getPeripheral()).filter(i -> i.regexMatch($param.filter))
               .sort((a,b) -> getRegisterAddress($instance.getPeripheral(),a) - getRegisterAddress($instance.getPeripheral(),b))
               .map(reg -> system::getAssignedRegDefine($instance, $instance.getPeripheral(), reg, $param.name + `_` + reg + `_INIT`)).reduce(``,(last, i) -> last + i)</expr>
         </def>
         <!-- Fragment provide definition of assigned registers of the node and current instance of the peripheral.  
            Only assigned (used) bitfields are included in the comment definition.
            Parameters:
               node - the required node that is used for taking assigned registers
               aply_to attribute - the required node that is used for taking assigned registers
               name - prefix name of each definition
          -->         
         <def fragment="node_assigned_regs_init" public="true">
            <expr if_expr="$param.node.isAvailable() &amp;&amp; $param.node.isEnabled()">getAssignedRegisters($param.node, $instance.getPeripheral())
               .sort((a,b) -> getRegisterAddress($instance.getPeripheral(),a) - getRegisterAddress($instance.getPeripheral(),b))
               .map(reg -> system::getAssignedRegDefine($param.node, $instance.getPeripheral(), reg, $param.name + `_` + reg + `_INIT`)).reduce(``,(last, i) -> last + i)</expr>
         </def>
         <!-- Fragment provide definition of assigned registers of the node for all peripherals (all assigned registers of this node).  
            Only assigned (used) bitfields are included in the comment definition.
            Parameters:
               node - the required node that is used for taking assigned registers
               name - prefix name of each definition
               filter - regular expression string that is applied on names of registers.
                        Example of regular expressions
                        `(?!MOD).*` - all registers except the MOD
                        `CTRL|CNTR` - only registers CTRL and CNTR
          -->  
         <def fragment="node_assigned_regs_init_all_peripherals" public="true">
            <expr if_expr="$param.node.isAvailable() &amp;&amp; $param.node.isEnabled()">getAssignedPeripherals($param.node).map(peripheral -> 
                  getAssignedRegisters($param.node, peripheral).filter(i -> i.regexMatch($param.filter))
                  .sort((a,b) -> getRegisterAddress(peripheral,a) - getRegisterAddress(peripheral,b))
                  .map(reg -> system::getAssignedRegDefine($param.node, peripheral, reg, $param.name + `_` + reg + `_INIT`)).reduce(``,(last, i) -> last + i)
               ).reduce(``,(last, i) -> last + i)
            </expr>
         </def>
         <!-- END OF REGISTER INITIALIZATION FRAGMENTS -->
         <def fragment="include" public="true">
            <expr>`#include "` + $param.filename + `"`</expr>
            <br/>
         </def>
         <def fragment="fn_prefix" public="true">
            <expr>$instance.getFnGroupPrefix()</expr>
         </def>
         <def fragment="peripheral" public="true">
            <expr>$instance.getPeripheral()</expr>
         </def>
         <def fragment="define" public="true">
            <if expr="paramExists(`description`)">
               <expr>`/* ` + $param.description + ` */`</expr><br/>
            </if>
            <assert expr="paramExists(`description`)" message_expr="`Parameter description does not exists in the define fragment, component: ` + $instance.getID() + `config set:` + $this.getID()"/>
            <if expr="!paramExists(`description`)"> <!-- TO DO add condition for the verification mode of the Tools - for internal development purposes only -->
               <text>/* TO DO - add parameter description */</text><br/>
            </if>
             <text>#define </text>
            <expr>$param.name + ` ` + $param.value</expr>
            <br/>
         </def>
         <def fragment="defineNoComment" public="true">
            <text>#define </text>
            <expr>$param.name + ` ` + $param.value</expr>
            <br/>
         </def>
         <def fragment="comment" public="true">
            <expr>leftPadding(`/* ` + $param.content + ` */`, $param.paddingLevel)</expr>
            <br/>
         </def>
         <def fragment="init_line" public="true">
            <fragment id="comment" if_expr="paramExists(`description`)">
               <param id="content" expr="$param.description"></param>
               <param id="paddingLevel" expr="$param.paddingLevel"></param>
            </fragment>
            <expr>leftPadding($param.code, $param.paddingLevel)</expr>
            <br/>
         </def>
         <def fragment="field" public="true">
            <if expr="(!$this.hasOption(`remove_from_struct_init`) &amp;&amp; !$this.hasOption(`transform_by_regex`)) &amp;&amp; ((getType($this) != `info`) || $this.hasOption(`add_to_struct`) || $this.hasOption(`use_value_as_item_init`)) &amp;&amp; ((getType($this) != `variable`) || $this.hasOption(`add_to_struct`) || $this.hasOption(`use_value_as_item_init`))">
               <expr if_expr="getType($this) == `integer` &amp;&amp; (getSubType($this) == `uint8_t` || getSubType($this) == `uint16_t`)">
                  leftPadding(`.`, $param.paddingLevel) + $this.getID() + ` = ` + $this.getCValue() + `U`
               </expr>
               <expr if_expr="getType($this) == `integer` &amp;&amp; getSubType($this) == `uint32_t`">
                  leftPadding(`.`, $param.paddingLevel) + $this.getID() + ` = ` + $this.getCValue() + `UL`
               </expr>
               <expr if_expr="getType($this) == `integer` &amp;&amp; getSubType($this) == `uint64_t`">
                  leftPadding(`.`, $param.paddingLevel) + $this.getID() + ` = ` + $this.getCValue() + `ULL`
               </expr>
               <expr if_expr="getType($this) == `integer` &amp;&amp; (getSubType($this) == `int8_t` || getSubType($this) == `int16_t`)">
                  leftPadding(`.`, $param.paddingLevel) + $this.getID() + ` = ` + $this.getCValue()
               </expr>
               <expr if_expr="getType($this) == `integer` &amp;&amp; getSubType($this) == `int32_t`">
                  leftPadding(`.`, $param.paddingLevel) + $this.getID() + ` = ` + $this.getCValue() + `L`
               </expr>
               <expr if_expr="getType($this) == `integer` &amp;&amp; getSubType($this) == `int64_t`">
                  leftPadding(`.`, $param.paddingLevel) + $this.getID() + ` = ` + $this.getCValue() + `LL`
               </expr>
               <expr if_expr="getType($this) == `float` || getType($this) == `bool` || (getType($this) == `enum`  &amp;&amp; !($this.hasOption(`use_enum_value`)))">
                  leftPadding(`.`, $param.paddingLevel) + $this.getID() + ` = ` + $this.getCValue()
               </expr>
               <expr if_expr="getType($this) == `enum`  &amp;&amp; ($this.hasOption(`use_enum_value`))">
                  leftPadding(`.`, $param.paddingLevel) + $this.getID() + ` = ` + $this.getEnumItemValue()
               </expr>
               <expr if_expr="(getType($this) == `info`) &amp;&amp; ($this.hasOption(`add_to_struct`))">
                  leftPadding(`.`, $param.paddingLevel) + $this.getID() + ` = ` + $this.getValue()
               </expr>
               <expr if_expr="(getType($this) == `info`) &amp;&amp; ($this.hasOption(`use_value_as_item_init`))">
                  leftPadding($this.getValue(), ($this.hasOption(`paddingLevel`) ? $this.getOptionValue(`paddingLevel`).toInt() : $param.paddingLevel))
               </expr>
               <expr if_expr="(getType($this) == `variable`) &amp;&amp; ($this.hasOption(`add_to_struct`))">
                  leftPadding(`.`, $param.paddingLevel) + $this.getID() + ` = ` + $this.getValue()
               </expr>
               <expr if_expr="(getType($this) == `variable`) &amp;&amp; ($this.hasOption(`use_value_as_item_init`))">
                  leftPadding($this.getValue(), ($this.hasOption(`paddingLevel`) ? $this.getOptionValue(`paddingLevel`).toInt() : $param.paddingLevel))
               </expr>
               <expr if_expr="(getType($this) == `string`) &amp;&amp; ($this.hasOption(`add_as_identifier`))">
                  leftPadding(`.`, $param.paddingLevel) + $this.getID() + ` = ` + $this.getValue()
               </expr>
               <expr if_expr="getType($this) == `set` &amp;&amp; (!$this.hasOption(`use_set_values`))">
                  leftPadding(`.`, $param.paddingLevel) + $this.getID() + ` = ` + (($this.getCValue()==``) ? `0` : $this.getCValue())
               </expr>
               <expr if_expr="getType($this) == `set` &amp;&amp; ($this.hasOption(`use_set_values`))">
                  leftPadding(`.`, $param.paddingLevel) + $this.getID() + ` = ` + (($this.getCValue()==``) ? `0` : $this.filter(item_filter -> (item_filter.getValue() == `true`)).reduce(0, (lastResult, x) -> (lastResult + x.getSetItemValue().toInt())))   
               </expr>
               <expr if_expr="(((getType($this) == `array`) || (getType($this) == `struct`)) &amp;&amp; (getType($this.getParent()) != `array`))">
                  leftPadding(`.`, $param.paddingLevel) + $this.getID() + ` = {&#xA;` 
               </expr>
               <expr if_expr="(((getType($this) == `array`) || (getType($this) == `struct`)) &amp;&amp; (getType($this.getParent()) == `array`))">
                  leftPadding(`{&#xA;`, $param.paddingLevel) 
               </expr>
               <fragment if_expr="((getType($this) == `array`) || (getType($this) == `struct`))" id="field" for_elements_of="$this.filter(item -> ((!item.hasOption(`remove_from_struct_init`)) &amp;&amp; 
                                                                                                               ((getType(item) != `info`) || (item.hasOption(`transform_by_regex`)) || (item.hasOption(`add_to_struct`)) || (item.hasOption(`use_value_as_item_init`))) &amp;&amp; 
                                                                                                               ((getType(item) != `variable`)  || (item.hasOption(`add_to_struct`)) || (item.hasOption(`use_value_as_item_init`)))) )">
                   <param id="paddingLevel" expr="$param.paddingLevel + 1"/>
               </fragment>
               <expr if_expr="((getType($this) == `array`) || (getType($this) == `struct`))">
                  leftPadding(`}`, $param.paddingLevel)
               </expr>
               <expr if_expr="!$this.hasOption(`use_value_as_item_init`)"> ($param._last ? ``: `,`) </expr>
               <br/>
            </if> 
            <if expr="($this.hasOption(`transform_by_regex`) &amp;&amp; (getType($this) != `struct`) &amp;&amp; (getType($this) != `array`))">
               <expr>leftPadding(`.`, $param.paddingLevel) + $this.getID() + ` = ` + ($this.hasOption(`prefix`) ? $this.getOptionValue(`prefix`):``) + ($this.getCValue().regexMatch(`` + $this.getOptionValue(`transform_by_regex`)) ? $this.getCValue().regexSubstr(`` + $this.getOptionValue(`transform_by_regex`), 1): ``) + ($this.hasOption(`postfix`)? $this.getOptionValue(`postfix`):``)</expr>
               <expr> ($param._last ? ``: `,`) </expr>
               <br/>
            </if>
         </def>
         <def fragment="const_struct" public="true">
            <text>const </text>
            <expr>$param.type + ` ` + $param.name</expr>
            <text> = {</text>
            <br/>
            <fragment id="field" for_elements_of="$this.filter(item -> ((!item.hasOption(`remove_from_struct_init`)) &amp;&amp; 
                                                                       ((getType(item) != `info`) || (item.hasOption(`transform_by_regex`)) || (item.hasOption(`add_to_struct`)) || (item.hasOption(`use_value_as_item_init`))) &amp;&amp; 
                                                                       ((getType(item) != `variable`)  || (item.hasOption(`add_to_struct`)) || (item.hasOption(`use_value_as_item_init`)))) )">
               <param id="paddingLevel" expr="1"/>
            </fragment>
            <!-- apply in context of each item in the set/structure/array -->
            <text>};</text>
            <br/>
         </def>
         <def fragment="global_struct" public="true">
            <expr>$param.type + ` ` + $param.name</expr>
            <text> = {</text>
            <br/>
            <fragment id="field" for_elements_of="$this.filter(item -> ((!item.hasOption(`remove_from_struct_init`)) &amp;&amp; 
               ((getType(item) != `info`) || (item.hasOption(`transform_by_regex`)) || (item.hasOption(`add_to_struct`)) || (item.hasOption(`use_value_as_item_init`))) &amp;&amp; 
               ((getType(item) != `variable`)  || (item.hasOption(`add_to_struct`)) || (item.hasOption(`use_value_as_item_init`)))) )">
               <param id="paddingLevel" expr="1"/>
            </fragment>
            <!-- apply in context of each item in the set/structure/array -->
            <text>};</text>
            <br/>
         </def>
         <def fragment="global_array" public="true">
            <if expr="paramExists(`prefix`)">
               <expr>$param.prefix + ` `</expr>
            </if>
            <if expr="paramExists(`type`)">
               <expr>$param.type + ` `</expr>
            </if>
            <expr>$param.name + `[` + $param.size + `]`</expr>
            <if expr="paramExists(`suffix`)">
               <expr>$param.suffix</expr><br/>
            </if>
            <text> = {</text>
            <br/>
            <fragment id="field" for_elements_of="$this.filter(item -> ((!item.hasOption(`remove_from_struct_init`)) &amp;&amp; 
               ((getType(item) != `info`) || (item.hasOption(`transform_by_regex`)) || (item.hasOption(`add_to_struct`)) || (item.hasOption(`use_value_as_item_init`))) &amp;&amp; 
               ((getType(item) != `variable`)  || (item.hasOption(`add_to_struct`)) || (item.hasOption(`use_value_as_item_init`)))) )">
               <param id="paddingLevel" expr="1"/>
            </fragment>
            <!-- apply in context of each item in the set/structure/array -->
            <text>};</text>
            <br/>
         </def>
         <def fragment="const_var" public="true">
            <if expr="paramExists(`description`)">
               <expr>`/* ` + $param.description + ` */`</expr><br/>
            </if>
            <expr>`const `</expr>
            <if expr="paramExists(`type`)">
               <expr>$param.type + ` `</expr>
            </if>
            <expr>$param.name + ` = ` + $this.getCValue() + `;`</expr><br/>
         </def>
         <def fragment="extern_const" public="true">
            <if expr="paramExists(`description`)">
               <expr>`/* ` + $param.description + ` */`</expr><br/>
            </if>
            <text>extern const </text>
            <if expr="paramExists(`type`)">
               <expr>$param.type + ` `</expr>
            </if>
            <expr>$param.name</expr>
            <text>;</text>
            <br/>
         </def>
         <def fragment="extern_var" public="true">
            <if expr="paramExists(`description`)">
               <expr>`/* ` + $param.description + ` */`</expr><br/>
            </if>
            <expr>`extern `</expr>
            <if expr="paramExists(`type`)">
               <expr>$param.type + ` `</expr>
            </if>
            <expr>$param.name + `;`</expr><br/>
         </def>
         <def fragment="extern_const_var" public="true">
            <if expr="paramExists(`description`)">
               <expr>`/* ` + $param.description + ` */`</expr><br/>
            </if>
            <expr>`extern const ` + $param.type + ` ` + $param.name + `;`</expr><br/>
         </def>
         <def fragment="extern_fcn_def" public="true">
            <expr>`/* `+ $param.description + `*/`</expr><br/>
            <expr>`extern ` + $param.type + ` ` + $param.name + `(` + $param.params +`);`</expr><br/>
         </def>
         <def fragment="global_fcn_def" public="true">
            <if expr="paramExists(`description`)">
               <expr>`/* ` + $param.description + ` */`</expr><br/>
            </if>
            <expr>$param.type + ` ` + $param.name + `(` + $param.params +`);`</expr><br/>
         </def>
         <def fragment="extern_var_array" public="true">
            <if expr="paramExists(`description`)">
               <expr>`/* ` + $param.description + ` */`</expr><br/>
            </if>
            <expr>`extern ` + $param.type + ` ` + $param.name + `[` + $param.size + `]` + `;`</expr><br/>
         </def>
         <def fragment="extern_const_array" public="true">
            <if expr="paramExists(`description`)">
               <expr>`/* ` + $param.description + ` */`</expr><br/>
            </if>
            <expr>`extern const ` + $param.type + ` ` + $param.name + `[` + $param.size + `]` + `;`</expr><br/>
         </def>
         <def fragment="global_var" public="true">
            <if expr="paramExists(`description`)">
               <expr>`/* ` + $param.description + ` */`</expr><br/>
            </if>
            <if expr="paramExists(`type`)">
               <expr>$param.type + ` `</expr>
            </if>
            <expr>$param.name + `;`</expr><br/>
         </def>
         <def fragment="global_var_array" public="true">
            <if expr="paramExists(`description`)">
               <expr>`/* ` + $param.description + ` */`</expr><br/>
            </if>
            <if expr="paramExists(`type`)">
               <expr>$param.type + ` `</expr>
            </if>
            <expr>$param.name + `[` + $param.size + `]` + `;`</expr><br/>
         </def>
         <!-- Template fragment
         params:     
            file - name of the template file, located in specific component folder
            setting - setting node that contains variables which IDs correspond with template parameters
            description - initialization code description
            separators - creates commented line separators
         example:
            <fragment id="template">
               <param id="file">PIT.template</param>
               <param id="setting" expr="$configSet.pitTemplateVariables"></param>
               <param id="description" expr="$instance.getPeripheral() + ` register initialization`"></param>
               <param id="separators"></param>
            </fragment>         
         -->
         <def fragment="template" public="true">
            <if expr="paramExists(`separators`)">
               <expr>`/****************************************************************************/`</expr><br/>
            </if>
            <if expr="paramExists(`description`)">
               <expr>`/* ` + $param.description + ` */`</expr><br/>
            </if>
            <if expr="paramExists(`separators`)">
               <expr>`/****************************************************************************/`</expr><br/>
            </if>
            <expr>$components.system.#global.execScriptFunction(`template_engine.js`, `generateTemplateContent`, $instance, $param.file, $param.setting)</expr><br/>
         </def>
      </fragment_defs>
      <quick_selections/>
   </config_set>
   <config_set id="global_system_definitions" label="Global system definitions" from_source="fsl_common.h">
      <description>Global system definitions</description>
      <generated_types></generated_types>
      <user_types>
          <info id="signal_routing" label="signal" value="$this.hasOption(`unified_signal_name`) ? (queryFeature(`PeripheralUnifiedSignal`, $instance.getPeripheral() + `.` + $this.getOptionValue(`unified_signal_name`), `Routed`) ? getPeripheralSignals($instance.getPeripheral()).findFirst(x -> (x.getValue().regexMatch(`.*` + $this.getOptionValue(`unified_signal_name`) + `.*`))).getLabel() : `Not routed to external pin`) : `N/A`" public="true">
            <description>This setting provide only information about routing of the signal on external pin. The routing is provided by the Pins tool.</description>
         </info>
         <!-- 
         parameters:
            register - register name / expression
            bitfield - bitfield name / expression
            mask - bitfield mask value
         example:
             <reference id="sync1" label="Sync Bn" type="registerBit" config_set_id="global_system_definitions" component_id="system">
                 <options_expr>
                     <option id="register" expr="`EVTG0_CTRL`"></option>
                     <option id="bitfield" expr="`SYNC_CTRL`"></option>
                     <option id="mask" expr="1&lt;&lt;1"></option>
                     <option id="REGISTERS_REFRESH"/>
                 </options_expr>
                 <description>Register bit</description>
             </reference>
         -->
         <bool id="registerBit" public="true">
            <assign when="true">
               <register name_expr="$this.optionValue(`register`)" bitfield_expr="$this.optionValue(`bitfield`)" 
                  value="$this.getValue().system::maskBitfield($this.optionValue(`register`), $this.optionValue(`bitfield`), $this.optionValue(`mask`))" 
                  reverse_value="x -> ((x &amp; ($this.optionValue(`mask`).toInt())) != 0)"/>
            </assign>
         </bool>
      </user_types>
      <settings>
         <string id="user_definitions" label="User definitions" options="UI_MULTI_LINE=10">
            <description>Custom user code (definitions) that is included in the generated peripherals.h file as a plain text.</description>
         </string>
         <string id="user_includes" label="User includes" options="UI_MULTI_LINE=10">
            <description>Custom list of includes (code snippet) that is included in the generated peripherals.h file as a plain text.</description>
         </string>
         <bool id="init_delay_enable" label="Pre-init delay" options="UI_LABEL_BOLD" available="featureDefined(`SOC_INTC_COUNT`) &amp;&amp; getFeature(`SOC_INTC_COUNT`)">
            <description>When enabled, additonal dealy is inlcuded between common pre-initialzation and initialization of specific peripherals.</description>
         </bool>
         <struct id="init_delay" label="Pre-init delay" options="UI_LABEL_HIDDEN" available="(featureDefined(`SOC_INTC_COUNT`) &amp;&amp; getFeature(`SOC_INTC_COUNT`)) &amp;&amp; $parent.init_delay_enable.isAvailable() &amp;&amp; $parent.init_delay_enable.getValue()">
            <description>Configuration of optional delay loop added before common pre-initialzation and initialization of specific peripherals. The delay is realized using delay function from MCUXpresso SDK.</description>
            <variable id="core_clock_Hz" value="queryFeatureAdvanced(`ClockSetting`, `CPU_CLK.outFreq`, `value`, true)"></variable>
            <info id="core_clock" label="Core clock" value="system::calculateFreqPeriod(1,queryFeatureAdvanced(`ClockSetting`, `CPU_CLK.outFreq`, `value`, true))">
               <description>Core clock set in Functional group called by default initialization function (i.e. clock configuraiton enabled after boot). The core clock is configured in Clocks tool.</description>
            </info>
            <integer type="uint32_t" id="init_delay_cycles" label="Pre-init delay [core cycles]" min_expr="1">
               <description>Number of core cycles added before common pre-initialzation and initialization of specific peripherals.</description>
            </integer>
            <info id="init_delay" label="Pre-init delay" value="system::calculatePeriod($parent.init_delay_cycles.getValue(), $parent.core_clock_Hz.getValue())">
               <description>Calculated delay. Please note that the real delay value may slightly differ as it depends on additional factors like delay function placement (flash vs. RAM).</description>
            </info>
         </struct>
         <!--         <reference id="messages" type="global_messages_list" component_id="msg" config_set_id="global_messages"></reference> -->
         <!-- General global variables -->
         <variable id="all_ids" value="$components.system.#global.all_enabled_instances.getValue().filter(item -> (item.hasOption(`id_check`) &amp;&amp; item.isAvailable() &amp;&amp; item.isEnabled()), true)"></variable>
         <variable id="duplicit_ids" value="$components.system.#global.all_ids.getValue()
            .filter(id -> (id.getType()== `enum` ? ((id.getEnumItemValue() != ``) &amp;&amp; (id.getEnumItemValue() != `N/A`)) : ((id.getValue() != ``) &amp;&amp; (id.getValue() != `N/A`))))
            .findDuplicates(id -> (id.getType()== `enum` ? id.getEnumItemValue() : id.getValue()))"></variable>
            <!-- All component instances from all functional groups -->
         <variable id="all_instances" value="$root.flatMap(x -> x)"></variable>
            <!-- All enabled component instances called by default init group     ! uncomment after the first use case -->
         <!--variable id="all_enabled_def_fn_group_instances" value="$root.filter(function -> (function.isCalledFromDefaultInit())).size() != 0 ? $root.findFirst(function -> (function.isCalledFromDefaultInit())).filter(instance -> (instance.isEnabled())) : createArray()"></variable-->
            <!-- All enabled component instances from all functional groups -->
         <variable id="all_enabled_instances" value="$parent.all_instances.getValue().filter(x -> x.isEnabled())"></variable>
         <!-- eDMA global variables -->
         <variable id="all_edma_config" value="(featureDefined(`SOC_EDMA_COUNT`) &amp;&amp; getFeature(`SOC_EDMA_COUNT`)) ? $root.filter(item -> ((item.getType() == `struct`) &amp;&amp; item.isAvailable() &amp;&amp; item.isEnabled() &amp;&amp; (item.nodeExists(`eDMAn`))), true) : createArray()"></variable>  
         <variable id="duplicit_edma_prefixes" value="$components.system.#global.all_edma_config.getValue().findDuplicates(x->(x.getSetting(`dma_prefix_define`).getValue()))"></variable>
         <variable  id="duplicit_edma_channels" value="$components.system.#global.all_edma_config.getValue().findDuplicates(x->(x.getSetting(`eDMAn`).getValue() + x.getSetting(`dma_instance`).getValue()))"></variable>
         <variable  id="duplicit_edma_requests" value="$components.system.#global.all_edma_config.getValue().findDuplicates(x->(x.getSetting(`eDMA_source`).getEnumItemValue()))"></variable>
         <!-- DMA and LPC dma global variables -->
         <variable id="all_dma_config" value="(featureDefined(`SOC_DMA_COUNT`) &amp;&amp; getFeature(`SOC_DMA_COUNT`)) ? $root.filter(item -> ((item.getType() == `struct`) &amp;&amp; item.isAvailable() &amp;&amp; item.isEnabled() &amp;&amp; (item.nodeExists(`DMAn`))), true) : createArray()"></variable>  
         <variable id="duplicit_dma_prefixes" value="$components.system.#global.all_dma_config.getValue().findDuplicates(x->(x.getSetting(`dma_prefix_define`).getValue()))"></variable>
         <variable  id="duplicit_dma_channels" value="$components.system.#global.all_dma_config.getValue().findDuplicates(x->(x.getSetting(`DMAn`).getValue() + x.getSetting(`dma_instance`).getValue()))"></variable>   
         <variable  id="duplicit_dma_requests" value="$components.system.#global.all_dma_config.getValue().findDuplicates(x->(x.getSetting(`DMA_source`).getEnumItemValue() + x.getSetting(`dma_instance`).getValue()))"></variable>
         <!-- Interrupt global variables -->
         <variable id="all_irq_config" value="$root.filter(item -> ((item.getType() == `enum`) &amp;&amp; (item.getID() == `IRQn`) &amp;&amp; (item.hasOption(`system_irqn`) &amp;&amp; item.isAvailable() &amp;&amp; item.isEnabled())),true)"></variable>
         <variable id="duplicit_irqs" value="$components.system.#global.all_irq_config.getValue().findDuplicates(x->x.getValue())"></variable>
         <!-- All interrupts for processing common initialization -->
         <variable id="all_interrupt_config" value="$components.system.#global.all_irq_config.getValue().map(x->x.getParent())"></variable>
         <!-- Message global variables -->
         <variable value="`Only one instance of the {0} component should be enabled.`" id="err_component_instance"></variable>
         <variable value="`Signal {0} of the peripheral {1} is not routed.`" id="err_routed_signal"></variable>
         <variable value="`Signal {0} of the channel {1} of the peripheral {2} is not routed.`" id="err_routed_channel"></variable>
         <variable value="`Signal channel {0} of the peripheral {1} is not routed.`" id="err_routed_signal_channel"></variable>
         <variable value="`The {0} driver is missing in the project{1}.`" id="err_missing_driver"></variable>
         <variable value="`The compatible version of the {0} driver is not available in the project{1}.`" id="err_driver_version"></variable>
         <variable value="`The DMA component must be in the default initialization function or in the current initialization function to provide DMA and DMAMUX devices initialization. Otherwise the DMA device will not work.`" id="warn_dma_component"></variable>
         <variable value="`The DMA component must be in the default initialization function or in the current initialization function to provide the DMA device initialization. Otherwise the DMA device will not work.`" id="warn_lpc_dma_component"></variable>
         <variable value="`The eDMA component must be in the default initialization function or in the current initialization function to provide eDMA and DMAMUX devices initialization. Otherwise the eDMA device will not work.`" id="warn_edma_component"></variable>
         <!-- Core specific variables -->
         <variable id="core_count" value="queryFeatureAdvanced(`CPUCore`, $root,`count`, true)"></variable>
         <variable id="core_ids" value="createArray(0, 1 , $parent.core_count.getValue()-1).map(x -> queryFeatureAdvanced(`CPUCore`, x ,`id`, true))"></variable>
      </settings>
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="common_code_templates"/>
            <from component_id="system" config_set_id="fsl_interrupt_peripheral"/>
         </import>
      </fragment_defs>
      <code>
         <section target="user_defines">
            <expr>$configSet.user_definitions.getValue()</expr><br/>
         </section>
         <section target="user_includes">
            <expr>$configSet.user_includes.getValue()</expr><br/>
         </section>
         <section target="includes">
            <fragment id="include" if_expr="$configSet.init_delay_enable.isAvailable() &amp;&amp; $configSet.init_delay_enable.getValue()">
               <param id="name">common</param>
               <param id="filename">fsl_common.h</param>
            </fragment>
         </section>
         <!-- Global pre-initialization section that is used in the default initialization group only. -->
         <section target="global_pre_init_only" >
            <text if_expr="$configSet.init_delay_enable.isAvailable() &amp;&amp; $configSet.init_delay_enable.getValue()">  /* Optional delay before peripherals initialization */</text><br/>
            <expr if_expr="$configSet.init_delay_enable.isAvailable() &amp;&amp; $configSet.init_delay_enable.getValue()">`  SDK_DelayCoreCycles(` + $configSet.init_delay.init_delay_cycles.getValue() + `UL);`</expr>
            <!-- Example how to use it for all interrupts -->
            <!-- <fragment id="IRQn_enable_default" for_elements_of="$components.system.#global.all_interrupt_config.getValue()"/>-->
         </section>
         <!-- Global post-initialization section that is used in the default initialization group only. -->
         <section target="global_post_init_only" >
            <!-- Example how to use it for all interrupts -->
            <!-- <fragment id="IRQn_enable_default" for_elements_of="$components.system.#global.all_interrupt_config.getValue()"/>-->
         </section>
      </code>
      <validation>
         <constraint when_expr="getFamily() == `DSC`" cond_expr="!isVersionInRange(queryFeatureAdvanced(`Application`, `Product`, `Version`).get(0), `8.0.0`, `8.0.0`)" level="error" description="Selected processor requires Config Tools version 8.1.0 or newer for using the Peripherals tool."/>
      </validation>
      <quick_selections></quick_selections>
   </config_set>
   <global_config_set_ref>global_system_definitions</global_config_set_ref>
</component:config_component>