#include "usb_device_config.h"
#include "usb.h"
#include "usb_device.h"
#include "usb_device_composite.h"
#include "usb_device_class.h"
#include "usb_device_dfu.h"
#include "usb_device_ch9.h"
#include "timer_queue.h"
#include "usb_flash.h"
#include "usb_device_${idLowerSnakeCase}$_app.h"

/*******************************************************************************
 * Definitions
 ******************************************************************************/
 
/*! @brief DFU status definition */
#define USB_DFU_STATUS_OK (0x00U)         /*!< No error condition is present */
#define USB_DFU_STATUS_ERR_TARGET (0x01U) /*!< File is not targeted for use by this device */
#define USB_DFU_STATUS_ERR_FILE   (0x02U) /*!< File is for this device but fails some vendor-specific verification test */
#define USB_DFU_STATUS_ERR_WRITE (0x03U)        /*!< Device is unable to write memory */
#define USB_DFU_STATUS_ERR_ERASE (0x04U)        /*!< Memory erase function failed */
#define USB_DFU_STATUS_ERR_CHECK_ERASED (0x05U) /*!< Memory erase check failed */
#define USB_DFU_STATUS_ERR_PROG (0x06U)         /*!< Program memory function failed */
#define USB_DFU_STATUS_ERR_VERIFY (0x07U)       /*!< Programed memory failed verification */
#define USB_DFU_STATUS_ERR_ADDRESS (0x08U)      /*!< Received address is out of range */
#define USB_DFU_STATUS_ERR_NOT_DONE (0x09U) /*!< Received DFU DNLOAD request with length = 0 but device does not think it has all of the data yet */
#define USB_DFU_STATUS_ERR_FIRMWARE (0x0AU)   /*!< Firmware is corrupt */
#define USB_DFU_STATUS_ERR_VENDOR (0x0BU)     /*!< Vendor specific error */
#define USB_DFU_STATUS_ERR_USBR (0x0CU)       /*!< Detect unexpected USB reset signaling */
#define USB_DFU_STATUS_ERR_POR (0x0DU)        /*!< Detect unexpected power on reset */
#define USB_DFU_STATUS_ERR_UNKNOWN (0x0EU)    /*!< Unknown error */
#define USB_DFU_STATUS_ERR_STALLEDPKT (0x0FU) /*!< Device stalled an unexpected request */

/*! @brief DFU Block status */
#define USB_DFU_BLOCK_TRANSFER_COMPLETE (0x00U)    /*!< Block transfer complete */
#define USB_DFU_BLOCK_TRANSFER_IN_PROGRESS (0x01U) /*!< Block transfer is still in progress */
#define USB_DFU_BLOCK_TRANSFER_UNDEFINED (0xFFU)   /*!< Block transfer status undefined */

/*! @brief DFU manifestation phase status */
#define USB_DFU_MANIFEST_COMPLETE (0x00U)    /*!< Manifestation phase complete */
#define USB_DFU_MANIFEST_IN_PROGRESS (0x01U) /*!< Manifestation phase in progress */
#define USB_DFU_MANIFEST_UNDEFINED (0xFFU)   /*!< Manifestation phase undefined */

typedef usb_status_t (*dfu_state_func)(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event);

/*******************************************************************************
 * Prototypes
 ******************************************************************************/
static void USB_DeviceDfuPollTimeoutIsr(void);
static usb_status_t USB_DeviceStateAppIdle(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event);
static usb_status_t USB_DeviceStateAppDetach(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event);
static usb_status_t USB_DeviceStateDfuIdle(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event);
static usb_status_t USB_DeviceStateDfuDnLoadSync(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event);
static usb_status_t USB_DeviceStateDfuDnBusy(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event);
static usb_status_t USB_DeviceStateDfuDnLoadIdle(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event);
static usb_status_t USB_DeviceStateDfuManifestSync(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event);
static usb_status_t USB_DeviceStateDfuManifest(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event);
static usb_status_t USB_DeviceStateDfuManifestWaitReset(usb_dfu_struct_t *dfu_dev,
                                                        usb_device_dfu_event_struct_t *event);
static usb_status_t USB_DeviceStateDfuUpLoadIdle(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event);
static usb_status_t USB_DeviceStateDfuError(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event);
/*******************************************************************************
 * Variables
 ******************************************************************************/
/* DFU state function table. */
const static dfu_state_func s_dfuStateFunc[11] = {
    USB_DeviceStateAppIdle,         USB_DeviceStateAppDetach,   USB_DeviceStateDfuIdle,
    USB_DeviceStateDfuDnLoadSync,   USB_DeviceStateDfuDnBusy,   USB_DeviceStateDfuDnLoadIdle,
    USB_DeviceStateDfuManifestSync, USB_DeviceStateDfuManifest, USB_DeviceStateDfuManifestWaitReset,
    USB_DeviceStateDfuUpLoadIdle,   USB_DeviceStateDfuError};

usb_dfu_struct_t g_UsbDevice${idCamelCase}$;
static usb_dfu_struct_t *s_DfuDevice = &g_UsbDevice${idCamelCase}$;
USB_DMA_NONINIT_DATA_ALIGN(USB_DATA_ALIGN_SIZE) uint8_t ${idLowerCamelCase}$FirmwareBlock[USB_${idSnakeCase}$_MAX_TRANSFER_SIZE];

#if USB_${idSnakeCase}$_BIT_CAN_UPLOAD
#define USB_${idSnakeCase}$_DFU_UPLOAD_SIZE (2 * USB_${idSnakeCase}$_DFU_MAX_TRANSFER_SIZE + 2)
USB_DMA_NONINIT_DATA_ALIGN(USB_DATA_ALIGN_SIZE) uint8_t updateLoadData[USB_${idSnakeCase}$_DFU_UPLOAD_SIZE];
#endif
uint8_t g_${idCamelCase}$detachRequest;

/* DFU event queue. */
static dfu_queue_t s_DfuEventQueue;
/* Flag which indicates if it has sent a short frame in UPLOAD request. */
static bool s_isShortFrame = false;
/* DFU CRC table list */
static uint32_t s_dfuCRCTableList[256];

uint32_t crcValue;
uint32_t address;
void static (*switchToApplicationMode)(void);

extern usb_device_composite_struct_t g_UsbDeviceComposite;
/*******************************************************************************
 * Code
 ******************************************************************************/

/*!
 * @brief DFU CRC table creation function.
 *
 * This function creates the CRC table.
 *
 * @return None.
 */
static void USB_DeviceDfuCreateCRCTableList(void)
{
    /* CRC32 - polynomial reserved */
    uint32_t polynomial = 0xEDB88320U;
    for (uint16_t index = 0U; index < 256U; index++)
    {
        uint32_t crcElement = index;
        uint32_t topBit     = 0x00000001U;
        for (uint8_t i = 0U; i < 8U; i++)
        {
            if (crcElement & topBit)
            {
                crcElement = (crcElement >> 1U) ^ polynomial;
            }
            else
            {
                crcElement = (crcElement >> 1U);
            }
        }
        s_dfuCRCTableList[index] = crcElement;
    }
}

/*!
 * @brief DFU CRC calculation function.
 *
 * This function calculates the CRC over a buffer.
 *
 * @return CRC value.
 */
static uint32_t USB_DeviceDfuCalculateCRC(uint32_t crc, uint8_t *data, uint32_t length)
{
    uint8_t crcIndex   = 0U;
    uint32_t crcReturn = crc;
    for (uint32_t i = 0U; i < length; i++)
    {
        crcIndex  = (uint8_t)((crcReturn & 0x000000FFU) ^ data[i]);
        crcReturn = s_dfuCRCTableList[crcIndex] ^ (crcReturn >> 8U);
    }
    return (crcReturn);
}

/*!
 * @brief host cdc enter critical section.
 *
 * This function is used to enter critical, disable interrupts .
 *
 */
static void USB_DfuEnterCritical(uint8_t *sr)
{
    *sr = DisableGlobalIRQ();
    __ASM("CPSID i");
}

/*!
 * @brief host cdc exit critical section.
 *
 * This function is used to exit critical ,enable interrupt .
 *
 */
static void USB_DfuExitCritical(uint8_t sr)
{
    EnableGlobalIRQ(sr);
}

/*!
 * @brief Initialize the queue.
 *
 * @return Error code.
 */
static inline usb_status_t USB_DeviceDfuQueueInit(dfu_queue_t *q)
{
    usb_status_t error = kStatus_USB_Error;
    uint8_t usbOsaCurrentSr;
    USB_DfuEnterCritical(&usbOsaCurrentSr);
    (q)->head    = 0;
    (q)->tail    = 0;
    (q)->maxSize = DFU_EVENT_QUEUE_MAX;
    (q)->curSize = 0;
    if (KOSA_StatusSuccess != OSA_MutexCreate(&((q)->mutex)))
    {
        usb_echo("queue mutex create error!");
    }
    error = kStatus_USB_Success;
    USB_DfuExitCritical(usbOsaCurrentSr);
    return error;
}

static inline uint8_t USB_DeviceDfuQueueIsEmpty(dfu_queue_t *q)
{
    return ((q)->curSize == 0) ? 1 : 0;
}

/*!
 * @brief Check if the queue is full.
 *
 * @return 1: queue is full, 0: not full.
 */
static inline uint8_t USB_DeviceDfuQueueIsFull(dfu_queue_t *q)
{
    return ((q)->curSize >= (q)->maxSize) ? 1 : 0;
}

/*!
 * @brief Put element into the queue.
 *
 * @return Error code.
 */
static inline usb_status_t USB_DeviceDfuQueuePut(dfu_queue_t *q, usb_device_dfu_event_struct_t *e)
{
    usb_status_t error = kStatus_USB_Error;
    uint8_t usbOsaCurrentSr;
    USB_DfuEnterCritical(&usbOsaCurrentSr);
    if (0 == USB_DeviceDfuQueueIsFull(q))
    {
        (q)->qArray[(q)->head++] = *(e);
        if ((q)->head == (q)->maxSize)
        {
            (q)->head = 0;
        }
        (q)->curSize++;
        error = kStatus_USB_Success;
    }
    USB_DfuExitCritical(usbOsaCurrentSr);
    return error;
}

/*!
 * @brief Get element from the queue.
 *
 * @return Error code.
 */
static inline usb_status_t USB_DeviceDfuQueueGet(dfu_queue_t *q, usb_device_dfu_event_struct_t *e)
{
    usb_status_t error = kStatus_USB_Error;
    uint8_t usbOsaCurrentSr;
    USB_DfuEnterCritical(&usbOsaCurrentSr);
    if (0 == USB_DeviceDfuQueueIsEmpty(q))
    {
        *(e) = (q)->qArray[(q)->tail++];
        if ((q)->tail == (q)->maxSize)
        {
            (q)->tail = 0;
        }
        (q)->curSize--;
        error = kStatus_USB_Success;
    }
    USB_DfuExitCritical(usbOsaCurrentSr);
    return error;
}

/*!
 * @brief DFU set state function.
 *
 * This function sets the state for a device.
 *
 * @return kStatus_USB_Success.
 */
static usb_status_t USB_DeviceDfuSetState(usb_dfu_state_struct_t state)
{
    uint8_t usbOsaCurrentSr;
    USB_DfuEnterCritical(&usbOsaCurrentSr);
    s_DfuDevice->dfuStatus.bState = state;
    USB_DfuExitCritical(usbOsaCurrentSr);
    return kStatus_USB_Success;
}

/*!
 * @brief DFU get state function.
 *
 * This function gets the state for a device.
 *
 * @return The state of the device.
 */
usb_dfu_state_struct_t USB_Device${idCamelCase}$GetState(void)
{
    return (usb_dfu_state_struct_t)s_DfuDevice->dfuStatus.bState;
}

/*!
 * @brief DFU set status function.
 *
 * This function sets the status for a device.
 *
 * @return kStatus_USB_Success.
 */
static usb_status_t USB_DeviceDfuSetStatus(uint32_t status)
{
    uint8_t usbOsaCurrentSr;
    USB_DfuEnterCritical(&usbOsaCurrentSr);
    s_DfuDevice->dfuStatus.bStatus = status;
    USB_DfuExitCritical(usbOsaCurrentSr);
    return kStatus_USB_Success;
}

/*!
 * @brief DFU get status function.
 *
 * This function gets the status for a device.
 *
 * @return The status of the device.
 */
static uint32_t USB_DeviceDfuGetStatus(void)
{
    return s_DfuDevice->dfuStatus.bStatus;
}
#if (USB_${idSnakeCase}$_BIT_WILL_DETACH == 0U)
/*!
 * @brief DFU detach timeout routine.
 *
 * This function serves as the timeout routine for DETACH request.
 *
 * @return None.
 */
static void USB_DeviceDfuDetachTimeoutIsr(void)
{
    usb_status_t error = kStatus_USB_Success;
    usb_device_dfu_event_struct_t event;
    event.name    = kUSB_DeviceDfuEventDetachTimeout;
    event.wValue  = 0;
    event.wLength = 0;
    error         = USB_DeviceDfuQueuePut(&s_DfuEventQueue, &event);
    if (kStatus_USB_Success != error)
    {
        /* The queue is full, set the status to error unknown */
        USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_UNKNOWN);
    }
}
#endif

/*!
 * @brief DFU DETACH request function.
 *
 * This function validates the request against the current state And informs the
 * state function via the event queue.
 *
 * @return A USB error code or kStatus_USB_Success.
 */
usb_status_t USB_Device${idCamelCase}$DetachReqest(uint16_t wTimeout)
{
    usb_status_t error = kStatus_USB_Success;
    usb_dfu_state_struct_t state;
    usb_device_dfu_event_struct_t event;
    uint32_t status;
    state = USB_Device${idCamelCase}$GetState();
    if (kState_AppIdle != state)
    {
        USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_STALLEDPKT);
    }
    status        = USB_DeviceDfuGetStatus();
    event.name    = kUSB_DeviceDfuEventDetachReq;
    event.wValue  = wTimeout;
    event.wLength = 0;
    error         = USB_DeviceDfuQueuePut(&s_DfuEventQueue, &event);
    if (kStatus_USB_Success != error)
    {
        /* The queue is full, set the status to error unknown */
        USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_UNKNOWN);
    }
    if (USB_DFU_STATUS_ERR_STALLEDPKT == status)
    {
        /* Stall the control pipe. */
        error = kStatus_USB_InvalidRequest;
    }
    else
    {
        error = kStatus_USB_Success;
    }
    return error;
}

/*!
 * @brief DFU DNLOAD request function.
 *
 * This function validates the request against the current state And informs the
 * state function via the event queue.
 *
 * @return A USB error code or kStatus_USB_Success.
 */

usb_status_t USB_Device${idCamelCase}$DownLoadReqest(uint16_t wLength, uint8_t **data)
{
    usb_status_t error = kStatus_USB_Success;
    usb_dfu_state_struct_t state;
    usb_device_dfu_event_struct_t event;
    uint32_t status;
    state = USB_Device${idCamelCase}$GetState();
    if ((kState_DfuIdle == state) || (kState_DfuDnLoadIdle == state))
    {
        if (USB_${idSnakeCase}$_BIT_CAN_DNLOAD && (wLength > 0))
        {
        }
        else if (0 == wLength)
        {
            status = USB_DeviceDfuGetStatus();

            if (USB_DFU_STATUS_ERR_NOT_DONE == status)
            {
                USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_STALLEDPKT);
            }
        }
        else
        {
            USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_STALLEDPKT);
        }
    }
    else
    {
        USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_STALLEDPKT);
    }
    status        = USB_DeviceDfuGetStatus();
    event.name    = kUSB_DeviceDfuEventDnloadReq;
    event.wValue  = 0;
    event.wLength = wLength;
    error         = USB_DeviceDfuQueuePut(&s_DfuEventQueue, &event);
    if (kStatus_USB_Success != error)
    {
        /* The queue is full, set the status to error unknown */
        USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_UNKNOWN);
    }
    if (USB_DFU_STATUS_ERR_STALLEDPKT == status)
    {
        /* Stall the control pipe. */
        error = kStatus_USB_InvalidRequest;
    }
    else
    {
        error = kStatus_USB_Success;
    }
    return error;
}

/*!
 * @brief DFU UPLOAD request function.
 *
 * This function validates the request against the current state, assign the appropriate buffer
 * and length for the UPLOAD request.  And informs the state function via the event queue.
 *
 * @return A USB error code or kStatus_USB_Success.
 */
usb_status_t USB_Device${idCamelCase}$UpLoadReqest(uint32_t *length, uint8_t **data)
{
    usb_status_t error = kStatus_USB_Success;
    usb_dfu_state_struct_t state;
    usb_device_dfu_event_struct_t event;
    uint32_t status;
    uint32_t uploadLength;
    state = USB_Device${idCamelCase}$GetState();
    if (kState_DfuIdle == state)
    {
#if USB_${idSnakeCase}$_BIT_CAN_UPLOAD
        s_isShortFrame = false;

        /* get firmware start address from USB_DFU_APP_ADDRESS address */
        s_DfuDevice->dfuFirmwareAddress = (uint32_t)&updateLoadData[0];
        /* get firmware size from USB_DFU_APP_ADDRESS + 4 address */
        s_DfuDevice->dfuFirmwareSize = UPLOAD_SIZE;
        if ((0xFFFFFFFFU == s_DfuDevice->dfuFirmwareSize) ||
            (0xFFFFFFFFU == s_DfuDevice->dfuFirmwareAddress))
        {
            USB_DeviceDfuSetState(kState_DfuError);
            USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_STALLEDPKT);
            error = kStatus_USB_InvalidRequest;
        }
        else
        {
            usb_echo("\\r\\nUploading firmware ...\\r\\n");
            s_DfuDevice->dfuStatus.bState       = kState_DfuUpLoadIdle;
            s_DfuDevice->dfuCurrentUploadLenght = 0U;

            uploadLength = *((uint32_t *)length);
            for (uint32_t i = 0; i < uploadLength; i++)
            {
                s_DfuDevice->dfuFirmwareBlock[i] = (((uint8_t *)s_DfuDevice->dfuFirmwareAddress))[i];
            }
            s_DfuDevice->dfuCurrentUploadLenght += uploadLength;
            *data = s_DfuDevice->dfuFirmwareBlock;
        }
#else
        USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_STALLEDPKT);
#endif
    }
    else if (kState_DfuUpLoadIdle == state)
    {
        /* uploading indicator */
        usb_echo("&");
        if (s_DfuDevice->dfuFirmwareSize - s_DfuDevice->dfuCurrentUploadLenght >= *length)
        {
            uploadLength = *((uint32_t *)length);
            for (uint32_t i = 0; i < uploadLength; i++)
            {
                s_DfuDevice->dfuFirmwareBlock[i] =
                    (((uint8_t *)s_DfuDevice->dfuFirmwareAddress) + s_DfuDevice->dfuCurrentUploadLenght)[i];
            }
            s_DfuDevice->dfuCurrentUploadLenght += uploadLength;
            *data = s_DfuDevice->dfuFirmwareBlock;
        }
        else
        {
            usb_echo("\\r\\nUploading firmware completed.\\r\\n");
            uploadLength = *((uint32_t *)length);
            *length      = s_DfuDevice->dfuFirmwareSize - s_DfuDevice->dfuCurrentUploadLenght;
            for (uint32_t i = 0; i < *length; i++)
            {
                s_DfuDevice->dfuFirmwareBlock[i] =
                    (((uint8_t *)s_DfuDevice->dfuFirmwareAddress) + s_DfuDevice->dfuCurrentUploadLenght)[i];
            }
            s_DfuDevice->dfuCurrentUploadLenght += *length;
            *data          = s_DfuDevice->dfuFirmwareBlock;
            s_isShortFrame = true;
        }
    }
    else
    {
        USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_STALLEDPKT);
    }
    status        = USB_DeviceDfuGetStatus();
    event.name    = kUSB_DeviceDfuEventUploadReq;
    event.wValue  = 0;
    event.wLength = *length;
    error         = USB_DeviceDfuQueuePut(&s_DfuEventQueue, &event);
    if (kStatus_USB_Success != error)
    {
        /* The queue is full, set the status to error unknown */
        USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_UNKNOWN);
    }
    if (USB_DFU_STATUS_ERR_STALLEDPKT == status)
    {
        /* Stall the control pipe. */
        error = kStatus_USB_InvalidRequest;
    }
    else
    {
        error = kStatus_USB_Success;
    }
    return error;
}

/*!
 * @brief DFU GET_STATUS request function.
 *
 * This function validates the request against the current state, sends the current status. And informs the
 * state function via the event queue.
 *
 * @return A USB error code or kStatus_USB_Success.
 */
usb_status_t USB_Device${idCamelCase}$GetStatusReqest(uint8_t *length, uint8_t **data)
{
    usb_status_t error = kStatus_USB_Success;
    usb_dfu_state_struct_t state;
    usb_device_dfu_event_struct_t event;
    uint32_t status;
    state = USB_Device${idCamelCase}$GetState();
    if ((kState_DfuDnBusy == state) || (kState_DfuManifest == state))
    {
        USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_STALLEDPKT);
    }
    else
    {
        /* Device returns the status response */
        *data   = (uint8_t *)&s_DfuDevice->dfuStatus;
        *length = 6U;
    }
    status        = USB_DeviceDfuGetStatus();
    event.name    = kUSB_DeviceDfuEventGetStatusReq;
    event.wValue  = 0;
    event.wLength = *length;
    error         = USB_DeviceDfuQueuePut(&s_DfuEventQueue, &event);
    if (kStatus_USB_Success != error)
    {
        /* The queue is full, set the status to error unknown */
        USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_UNKNOWN);
    }
    if (USB_DFU_STATUS_ERR_STALLEDPKT == status)
    {
        /* Stall the control pipe. */
        error = kStatus_USB_InvalidRequest;
    }
    else
    {
        error = kStatus_USB_Success;
    }
    return error;
}

/*!
 * @brief DFU CLEAR_STATUS request function.
 *
 * This function validates the request against the current state. And informs the
 * state function via the event queue.
 *
 * @return A USB error code or kStatus_USB_Success.
 */
usb_status_t USB_Device${idCamelCase}$ClearStatusReqest(void)
{
    usb_status_t error = kStatus_USB_Success;
    usb_dfu_state_struct_t state;
    usb_device_dfu_event_struct_t event;
    uint32_t status;
    state = USB_Device${idCamelCase}$GetState();
    if (kState_DfuError == state)
    {
        USB_DeviceDfuSetStatus(USB_DFU_STATUS_OK);
    }
    else
    {
        USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_STALLEDPKT);
    }
    status        = USB_DeviceDfuGetStatus();
    event.name    = kUSB_DeviceDfuEventClearStatusReq;
    event.wValue  = 0;
    event.wLength = 0;
    error         = USB_DeviceDfuQueuePut(&s_DfuEventQueue, &event);
    if (kStatus_USB_Success != error)
    {
        /* The queue is full, set the status to error unknown */
        USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_UNKNOWN);
    }
    if (USB_DFU_STATUS_ERR_STALLEDPKT == status)
    {
        /* Stall the control pipe. */
        error = kStatus_USB_InvalidRequest;
    }
    else
    {
        error = kStatus_USB_Success;
    }
    return error;
}

/*!
 * @brief DFU GET_STATE request function.
 *
 * This function validates the request against the current state, sends the current
 * state. And informs the state function via the event queue.
 *
 * @return A USB error code or kStatus_USB_Success.
 */
usb_status_t USB_Device${idCamelCase}$GetStateReqest(uint8_t *length, uint8_t **data)
{
    usb_status_t error = kStatus_USB_Success;
    usb_dfu_state_struct_t state;
    usb_device_dfu_event_struct_t event;
    uint32_t status;
    state = USB_Device${idCamelCase}$GetState();
    if ((kState_DfuDnBusy == state) || (kState_DfuManifest == state))
    {
        USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_STALLEDPKT);
    }
    else
    {
        /* Device returns the state response */
        *data   = (uint8_t *)&s_DfuDevice->dfuStatus.bState;
        *length = 1U;
    }
    status        = USB_DeviceDfuGetStatus();
    event.name    = kUSB_DeviceDfuEventGetStateReq;
    event.wValue  = 0;
    event.wLength = *length;
    error         = USB_DeviceDfuQueuePut(&s_DfuEventQueue, &event);
    if (kStatus_USB_Success != error)
    {
        /* The queue is full, set the status to error unknown */
        USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_UNKNOWN);
    }
    if (USB_DFU_STATUS_ERR_STALLEDPKT == status)
    {
        /* Stall the control pipe. */
        error = kStatus_USB_InvalidRequest;
    }
    else
    {
        error = kStatus_USB_Success;
    }
    return error;
}

/*!
 * @brief DFU ABORT request function.
 *
 * This function validates the request against the current state. And informs the
 * state function via the event queue.
 *
 * @return A USB error code or kStatus_USB_Success.
 */
usb_status_t USB_Device${idCamelCase}$AbortReqest(void)
{
    usb_status_t error = kStatus_USB_Success;
    usb_dfu_state_struct_t state;
    usb_device_dfu_event_struct_t event;
    uint32_t status;
    state = USB_Device${idCamelCase}$GetState();
    if ((kState_DfuIdle == state) || (kState_DfuDnLoadIdle == state) || (kState_DfuUpLoadIdle == state))
    {
    }
    else
    {
        USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_STALLEDPKT);
    }
    status        = USB_DeviceDfuGetStatus();
    event.name    = kUSB_DeviceDfuEventAbortReq;
    event.wValue  = 0;
    event.wLength = 0;
    error         = USB_DeviceDfuQueuePut(&s_DfuEventQueue, &event);
    if (kStatus_USB_Success != error)
    {
        /* The queue is full, set the status to error unknown */
        USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_UNKNOWN);
    }
    if (USB_DFU_STATUS_ERR_STALLEDPKT == status)
    {
        /* Stall the control pipe. */
        error = kStatus_USB_InvalidRequest;
    }
    else
    {
        error = kStatus_USB_Success;
    }
    return error;
}




/*!
 * @brief DFU switch mode function.
 *
 * This function switches the device from DFU mode to APP mode.
 *
 * @return None.
 */
void USB_Device${idCamelCase}$SwitchMode(void)
{
    address = (uint32_t)(USB_DFU_APP_ADDRESS);

    static uint32_t newSP, newPC;
    USB_DeviceClassDeinit(USB_DEVICE_CONTROLLER_ID);
    SCB->VTOR = address;
    newSP     = ((uint32_t *)address)[0U];
    newPC     = ((uint32_t *)address)[1U];
    __set_CONTROL(0x00000000U);
    /* load new value to stack pointer and program counter */
    __set_MSP(newSP);
    switchToApplicationMode = (void (*)(void))newPC;
#if (0U != __CORTEX_M)
    /* reset FAULTMASK register */
    __set_FAULTMASK(0x00000000U);
#endif
    /* switch to application mode */
    switchToApplicationMode();
}

/*!
 * @brief DFU USB bus reset function.
 *
 * This function resets the USB bus by resetting the system.
 *
 * @return None.
 */
void USB_Device${idCamelCase}$BusReset(void)
{
    switch (s_DfuDevice->dfuStatus.bState)
    {
        case kState_AppIdle:
            /* Do nothing */
            break;
        case kState_AppDetach:
            /* Enter DFU mode */
            USB_DeviceDfuSetState(kState_DfuIdle);

            /*g_${idCamelCase}$detachRequest = 1U;*/
            /* Switch to DFU mode */
            /*NVIC_SystemReset();*/
            break;
        case kState_DfuIdle:
        case kState_DfuDnLoadSync:
        case kState_DfuDnBusy:
        case kState_DfuDnLoadIdle:
        case kState_DfuManifestSync:
        case kState_DfuManifest:
        case kState_DfuManifestWaitReset:
        case kState_DfuUpLoadIdle:
        case kState_DfuError:
            if (s_DfuDevice->dfuIsDownloadingFinished)
            {
                s_DfuDevice->dfuStatus.bState         = kState_AppIdle;
                s_DfuDevice->dfuIsDownloadingFinished = 0U;
                /* switch to APP mode */
                /*NVIC_SystemReset();*/
            }
            else
            {
                if (USB_DFU_BLOCK_TRANSFER_UNDEFINED != s_DfuDevice->dfuFirmwareBlockStatus)
                {
                    /* The firmware is downloading to the device but the bus reset occurs, change
                       the state to Error */
                    s_DfuDevice->dfuStatus.bState       = kState_DfuError;
                    s_DfuDevice->dfuFirmwareBlockStatus = USB_DFU_BLOCK_TRANSFER_UNDEFINED;
                }
                else
                {
                    /* the downloading is not started yet, there is no firmware is downloaded */
                    /* do nothing */
                }
            }
            break;
        default:
            break;
    }
}

/*!
 * @brief DFU initialization function.
 *
 * This function initializes the state of the device..
 *
 * @return None.
 */
void USB_Device${idCamelCase}$AppInit(void)
{
    /* memory status */
    usb_memory_status_t memoryStatus = kStatus_USB_MemoryErrorUnknown;
    /* Default DFU status */
    s_DfuDevice->dfuStatus.bStatus           = USB_DFU_STATUS_OK;
    s_DfuDevice->dfuStatus.bwPollTimeout[0U] = 0x4U;
    s_DfuDevice->dfuStatus.bwPollTimeout[1U] = 0U;
    s_DfuDevice->dfuStatus.bwPollTimeout[2U] = 0U;
    
#if (USB_${idSnakeCase}$_PROTOCOL == USB_PROTOCOL_DFU_APP_MODE)
    USB_DeviceDfuSetState(kState_AppIdle);
#elif (USB_${idSnakeCase}$_PROTOCOL == USB_PROTOCOL_DFU_PROGRAM_MODE)
    USB_DeviceDfuSetState(kState_DfuIdle);
#endif

    s_DfuDevice->dfuStatus.iString           = 0U;
    s_DfuDevice->dfuFirmwareBlockStatus      = USB_DFU_BLOCK_TRANSFER_UNDEFINED;
    s_DfuDevice->dfuManifestationPhaseStatus = USB_DFU_MANIFEST_UNDEFINED;
    s_DfuDevice->dfuFirmwareAddress          = USB_DFU_APP_ADDRESS;
    s_DfuDevice->dfuFirmwareSize             = 0U;
    s_DfuDevice->dfuIsTheFirstBlock          = 0U;
    s_DfuDevice->dfuCRC                      = 0XFFFFFFFF;
    s_DfuDevice->dfuFirmwareBlock            = &${idLowerCamelCase}$FirmwareBlock[0];

    g_${idCamelCase}$detachRequest = 0U;
    USB_DeviceDfuQueueInit(&s_DfuEventQueue);

    USB_DeviceDfuCreateCRCTableList();

    memoryStatus = USB_MemoryInit();
    if (kStatus_USB_MemoryErrorSecure == memoryStatus)
    {
        s_DfuDevice->dfuStatus.bStatus = USB_DFU_STATUS_ERR_WRITE;
    }
    else if (kStatus_USB_MemoryErrorUnknown == memoryStatus)
    {
        s_DfuDevice->dfuStatus.bStatus = USB_DFU_STATUS_ERR_UNKNOWN;
    }
    else
    {
    }
#if USB_${idSnakeCase}$_BIT_CAN_UPLOAD
    uint32_t *temp;
    temp = (uint32_t *)&updateLoadData[0];
    for (uint32_t i = 0; i < (UPLOAD_SIZE / 4 - 2); i++)
    {
        temp[i] = i;
    }
#endif
    TimerQueue_TimerInit();
}

/*!
 * @brief DFU manifest function.
 *
 * This function does manifestation operation in MANIFEST state.
 *
 * @return None.
 */
void USB_Device${idCamelCase}$Manifest(void)
{
    /*do some thing to manifest*/
    /* store the fimware block data */
    if (USB_DFU_MANIFEST_IN_PROGRESS == s_DfuDevice->dfuManifestationPhaseStatus)
    {
        crcValue              = 0;
        uint32_t remainingLen = s_DfuDevice->dfuFirmwareSize - 4;
        uint8_t *startAddress = (uint8_t *)USB_DFU_APP_ADDRESS;

        s_DfuDevice->dfuCRC = 0xffffffff;
        uint32_t wLength          = USB_${idSnakeCase}$_MAX_TRANSFER_SIZE;
        uint32_t readLen          = 0;
        if (remainingLen < USB_${idSnakeCase}$_MAX_TRANSFER_SIZE)
        {
            wLength = remainingLen;
        }
        while (remainingLen)
        {
            memcpy((void *)s_DfuDevice->dfuFirmwareBlock, (uint8_t *)(startAddress + readLen), wLength);
            readLen += wLength;
            /* calculate DFU CRC */
            s_DfuDevice->dfuCRC = USB_DeviceDfuCalculateCRC(
                s_DfuDevice->dfuCRC, (uint8_t *)&s_DfuDevice->dfuFirmwareBlock[0], wLength);
            remainingLen -= wLength;
            if (remainingLen < USB_${idSnakeCase}$_MAX_TRANSFER_SIZE)
            {
                wLength = remainingLen;
            }
        }
        memcpy((void *)&crcValue, (uint8_t *)(startAddress + s_DfuDevice->dfuFirmwareSize - 4), 4);

        s_DfuDevice->crcCheck = 0;
        if (s_DfuDevice->dfuCRC != crcValue)
        {
            usb_echo("crc check error\\r\\n");
        }
        else
        {
            usb_echo("crc check ok\\r\\n");
            s_DfuDevice->crcCheck = 1;
        }

        s_DfuDevice->dfuManifestationPhaseStatus = USB_DFU_MANIFEST_COMPLETE;
    }
}

/*!
 * @brief DFU download function.
 *
 * This function does download operation in DNLOAD state.
 *
 * @return None.
 */
void USB_Device${idCamelCase}$Dnload(void)
{
    if (USB_DFU_BLOCK_TRANSFER_IN_PROGRESS == s_DfuDevice->dfuFirmwareBlockStatus)
    {
        usb_memory_status_t memoryStatus = kStatus_USB_MemoryErrorUnknown;
        uint32_t firmwareAddress           = USB_DFU_APP_ADDRESS + s_DfuDevice->dfuFirmwareSize;
        if (s_DfuDevice->dfuIsTheFirstBlock)
        {
            /* Erase application region */

            uint8_t usbOsaCurrentSr;

            USB_DfuEnterCritical(&usbOsaCurrentSr);
            memoryStatus = USB_MemoryErase((uint32_t)USB_DFU_APP_ADDRESS, USB_DFU_APP_SIZE);

            USB_DfuExitCritical(usbOsaCurrentSr);
            if (kStatus_USB_MemoryErrorErase == memoryStatus)
            {
                s_DfuDevice->dfuStatus.bStatus = USB_DFU_STATUS_ERR_ERASE;
            }
            else if (kStatus_USB_MemoryErrorEraseVerify == memoryStatus)
            {
                s_DfuDevice->dfuStatus.bStatus = USB_DFU_STATUS_ERR_CHECK_ERASED;
            }
            else if (kStatus_USB_MemoryErrorUnknown == memoryStatus)
            {
                s_DfuDevice->dfuStatus.bStatus = USB_DFU_STATUS_ERR_UNKNOWN;
            }
            else
            {
            }
            s_DfuDevice->dfuIsTheFirstBlock = 0U;
        }
        if (s_DfuDevice->dfuFirmwareBlockLength > 0U)
        {
            s_DfuDevice->dfuFirmwareBlockStatus = USB_DFU_BLOCK_TRANSFER_UNDEFINED;
            /* Update the firmware size */
            s_DfuDevice->dfuFirmwareSize += s_DfuDevice->dfuFirmwareBlockLength;
            /* write firmware into the memory */

            uint8_t usbOsaCurrentSr;

            USB_DfuEnterCritical(&usbOsaCurrentSr);

            memoryStatus = USB_MemoryProgram(firmwareAddress, (uint8_t *)&s_DfuDevice->dfuFirmwareBlock[0],
                                               s_DfuDevice->dfuFirmwareBlockLength);
            USB_DfuExitCritical(usbOsaCurrentSr);

            if (kStatus_USB_MemorySuccess == memoryStatus)
            {
                s_DfuDevice->dfuFirmwareBlockStatus = USB_DFU_BLOCK_TRANSFER_COMPLETE;
            }
            else if (memoryStatus == kStatus_USB_MemoryErrorProgram)
            {
                USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_PROG);
            }
            else if (memoryStatus == kStatus_USB_MemoryErrorProgramAddress)
            {
                USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_ADDRESS);
            }
            else if (memoryStatus == kStatus_USB_MemoryErrorProgramVerify)
            {
                USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_VERIFY);
            }
            else if (memoryStatus == kStatus_USB_MemoryErrorUnknown)
            {
                USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_UNKNOWN);
            }
            else
            {
            }
        }
    }
}

/*!
 * @brief DFU poll timeout routine.
 *
 * This function serves as the timeout routine for GET_STATUS request.
 *
 * @return None.
 */
static void USB_DeviceDfuPollTimeoutIsr(void)
{
    usb_status_t error = kStatus_USB_Success;
    usb_device_dfu_event_struct_t event;
    event.name    = kUSB_DeviceDfuEventPollTimeout;
    event.wValue  = 0;
    event.wLength = 0;
    error         = USB_DeviceDfuQueuePut(&s_DfuEventQueue, &event);
    if (kStatus_USB_Success != error)
    {
        /* The queue is full, set the status to error unknown */
        USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_UNKNOWN);
    }
}

/*!
 * @brief DFU APP_IDLE state function.
 *
 * This function validates the event against the current state. And sets
 * the next state of the device.
 *
 * @return A USB error code or kStatus_USB_Success.
 */
static usb_status_t USB_DeviceStateAppIdle(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event)
{
    usb_status_t error = kStatus_USB_Success;

    if (NULL != event)
    {
        switch (event->name)
        {
            case kUSB_DeviceDfuEventDetachReq:
#if USB_${idSnakeCase}$_BIT_WILL_DETACH
                g_${idCamelCase}$detachRequest = 1U;
                for (int i = 0; i < 5000; i++)
                {
                    __ASM("nop");
                }
                /* Device generates a detach-attach sequence on the bus */
                USB_DeviceStop(g_UsbDeviceComposite.deviceHandle);
                for (int i = 0; i < 5000; i++)
                {
                    __ASM("nop");
                }
                USB_DeviceRun(g_UsbDeviceComposite.deviceHandle);
                USB_DeviceDfuSetState(kState_DfuIdle);
#else
                g_${idCamelCase}$detachRequest = 1U;
                if (event->wValue > USB_${idSnakeCase}$_DETACH_TIMEOUT)
                {
                    USB_DeviceDfuSetStatus(USB_DFU_STATUS_ERR_UNKNOWN);
                    error = kStatus_USB_InvalidParameter;
                }
                else
                {
                    timerQueue_timer_object_t timerQueueTimerObject;
                    timerQueueTimerObject.timerCount     = event->wValue;
                    timerQueueTimerObject.timerCallback  = (timerQueue_timer_callback)USB_DeviceDfuDetachTimeoutIsr;
                    s_DfuDevice->dfuTimerId = TimerQueue_AddTimerQueue(&timerQueueTimerObject);
                }
                USB_DeviceDfuSetState(kState_AppDetach);
#endif
                break;
            case kUSB_DeviceDfuEventGetStatusReq:
                USB_DeviceDfuSetState(kState_AppIdle);
                break;
            case kUSB_DeviceDfuEventGetStateReq:
                USB_DeviceDfuSetState(kState_AppIdle);
                break;
            default:
                USB_DeviceDfuSetState(kState_AppIdle);
                break;
        }
    }
    return error;
}

/*!
 * @brief DFU APP_DETACH state function.
 *
 * This function validates the event against the current state. And sets
 * the next state of the device.
 *
 * @return A USB error code or kStatus_USB_Success.
 */
static usb_status_t USB_DeviceStateAppDetach(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event)
{
    usb_status_t error = kStatus_USB_Success;

    if (NULL != event)
    {
        switch (event->name)
        {
            case kUSB_DeviceDfuEventGetStatusReq:
                USB_DeviceDfuSetState(kState_AppDetach);
                break;
            case kUSB_DeviceDfuEventGetStateReq:
                USB_DeviceDfuSetState(kState_AppDetach);
                break;
            case kUSB_DeviceDfuEventDetachReq:
            case kUSB_DeviceDfuEventDnloadReq:
            case kUSB_DeviceDfuEventAbortReq:
            case kUSB_DeviceDfuEventUploadReq:

                USB_DeviceDfuSetState(kState_AppIdle);
                break;
            case kUSB_DeviceDfuEventDetachTimeout:
            default:
                USB_DeviceDfuSetState(kState_AppIdle);
                break;
        }
    }
    return error;
}

/*!
 * @brief DFU IDLE state function.
 *
 * This function validates the event against the current state. And sets
 * the next state of the device.
 *
 * @return A USB error code or kStatus_USB_Success.
 */
static usb_status_t USB_DeviceStateDfuIdle(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event)
{
    usb_status_t error = kStatus_USB_Success;

    if (NULL != event)
    {
        switch (event->name)
        {
            case kUSB_DeviceDfuEventDnloadReq:
                if ((event->wLength > 0) && USB_${idSnakeCase}$_BIT_CAN_DNLOAD)
                {
                    /* update firmware block length */
                    s_DfuDevice->dfuFirmwareBlockLength = event->wLength;
                    /* update firmware block status */
                    s_DfuDevice->dfuFirmwareBlockStatus = USB_DFU_BLOCK_TRANSFER_IN_PROGRESS;
                    /* update firmware size */
                    s_DfuDevice->dfuFirmwareSize = 0U;
                    /* update current download length */
                    s_DfuDevice->dfuIsTheFirstBlock = 1U;
                    /* reset the downloading flag */
                    s_DfuDevice->dfuIsDownloadingFinished = 0U;
                    /* reset manifestation phase flag */
                    s_DfuDevice->dfuManifestationPhaseStatus = USB_DFU_MANIFEST_UNDEFINED;
                    /* this time (5000 ms) is used to erase all the APP code region */
                    /* and memory the first firmware block data */
                    s_DfuDevice->dfuStatus.bwPollTimeout[0] = 2 & 0xFF;
                    s_DfuDevice->dfuStatus.bwPollTimeout[1] = (2 >> 8) & 0xFF;
                    s_DfuDevice->dfuStatus.bwPollTimeout[2] = (2 >> 16) & 0xFF;

                    USB_DeviceDfuSetState(kState_DfuDnLoadSync);
                }
                else
                {
                    USB_DeviceDfuSetState(kState_DfuError);
                }

                break;
            case kUSB_DeviceDfuEventUploadReq:
                if (USB_${idSnakeCase}$_BIT_CAN_UPLOAD)
                {
                    USB_DeviceDfuSetState(kState_DfuUpLoadIdle);
                }
                else
                {
                    USB_DeviceDfuSetState(kState_DfuError);
                }

                break;
            case kUSB_DeviceDfuEventAbortReq:
            case kUSB_DeviceDfuEventGetStatusReq:
            case kUSB_DeviceDfuEventGetStateReq:
                USB_DeviceDfuSetState(kState_DfuIdle);
                break;
            case kUSB_DeviceDfuEventDetachReq:
                USB_DeviceDfuSetState(kState_DfuIdle);
                break;
            default:
                USB_DeviceDfuSetState(kState_DfuError);
                break;
        }
    }
    return error;
}

/*!
 * @brief DFU DNLOAD_SYNC state function.
 *
 * This function validates the event against the current state. And sets
 * the next state of the device.
 *
 * @return A USB error code or kStatus_USB_Success.
 */
static usb_status_t USB_DeviceStateDfuDnLoadSync(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event)
{
    usb_status_t error = kStatus_USB_Success;
    timerQueue_timer_object_t timerQueueTimerObject;

    if (NULL != event)
    {
        switch (event->name)
        {
            case kUSB_DeviceDfuEventGetStatusReq:
                if (USB_DFU_BLOCK_TRANSFER_IN_PROGRESS == s_DfuDevice->dfuFirmwareBlockStatus)
                {
                    timerQueueTimerObject.timerCount = (uint32_t)(
                        (uint32_t)(0xFFFFFF & ((uint32_t)s_DfuDevice->dfuStatus.bwPollTimeout[2] << 16U)) +
                        (uint32_t)(0xFFFF & ((uint32_t)s_DfuDevice->dfuStatus.bwPollTimeout[1] << 8U)) +
                        (uint32_t)(0xFF & (uint32_t)s_DfuDevice->dfuStatus.bwPollTimeout[0]));
                    timerQueueTimerObject.timerCount = (timerQueueTimerObject.timerCount >> 1);

                    timerQueueTimerObject.timerCallback = (timerQueue_timer_callback)USB_DeviceDfuPollTimeoutIsr;

                    s_DfuDevice->dfuTimerId = TimerQueue_AddTimerQueue(&timerQueueTimerObject);
                    USB_DeviceDfuSetState(kState_DfuDnBusy);
                }
                else if (USB_DFU_BLOCK_TRANSFER_COMPLETE == s_DfuDevice->dfuFirmwareBlockStatus)
                {
                    USB_DeviceDfuSetState(kState_DfuDnLoadIdle);
                }
                break;

            case kUSB_DeviceDfuEventGetStateReq:
                USB_DeviceDfuSetState(kState_DfuDnLoadSync);
                break;
            case kUSB_DeviceDfuEventDnloadReq:
            case kUSB_DeviceDfuEventUploadReq:
            case kUSB_DeviceDfuEventAbortReq:
            case kUSB_DeviceDfuEventDetachReq:
                USB_DeviceDfuSetState(kState_DfuError);
                break;
            default:
                USB_DeviceDfuSetState(kState_DfuError);
                break;
        }
    }
    return error;
}

/*!
 * @brief DFU DNLOAD_BUSY state function.
 *
 * This function validates the event against the current state. And sets
 * the next state of the device.
 *
 * @return A USB error code or kStatus_USB_Success.
 */
static usb_status_t USB_DeviceStateDfuDnBusy(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event)
{
    usb_status_t error = kStatus_USB_Success;

    if (NULL != event)
    {
        switch (event->name)
        {
            case kUSB_DeviceDfuEventGetStatusReq:
            case kUSB_DeviceDfuEventGetStateReq:
            case kUSB_DeviceDfuEventDnloadReq:
            case kUSB_DeviceDfuEventUploadReq:
            case kUSB_DeviceDfuEventAbortReq:
            case kUSB_DeviceDfuEventDetachReq:
                USB_DeviceDfuSetState(kState_DfuError);
                break;
            case kUSB_DeviceDfuEventPollTimeout:
                USB_DeviceDfuSetState(kState_DfuDnLoadSync);
                break;
            default:
                USB_DeviceDfuSetState(kState_DfuError);
                break;
        }
    }
    return error;
}

/*!
 * @brief DFU DNLOAD_IDLE state function.
 *
 * This function validates the event against the current state. And sets
 * the next state of the device.
 *
 * @return A USB error code or kStatus_USB_Success.
 */
static usb_status_t USB_DeviceStateDfuDnLoadIdle(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event)
{
    usb_status_t error = kStatus_USB_Success;
    uint32_t status;

    if (NULL != event)
    {
        switch (event->name)
        {
            case kUSB_DeviceDfuEventGetStatusReq:
            case kUSB_DeviceDfuEventGetStateReq:
                USB_DeviceDfuSetState(kState_DfuDnLoadIdle);
                break;
            case kUSB_DeviceDfuEventDnloadReq:
                if (event->wLength > 0)
                {
                    /* update firmware block length */
                    s_DfuDevice->dfuFirmwareBlockLength = event->wLength;
                    /* update firmware block status */
                    s_DfuDevice->dfuFirmwareBlockStatus = USB_DFU_BLOCK_TRANSFER_IN_PROGRESS;
                    /* update timeout value */
                    s_DfuDevice->dfuStatus.bwPollTimeout[0] = 0x2;
                    s_DfuDevice->dfuStatus.bwPollTimeout[1] = 0;
                    s_DfuDevice->dfuStatus.bwPollTimeout[2] = 0;
                    USB_DeviceDfuSetState(kState_DfuDnLoadSync);
                }
                else
                {
                    status = USB_DeviceDfuGetStatus();
                    if (USB_DFU_STATUS_ERR_NOT_DONE != status)
                    {
                        s_DfuDevice->dfuFirmwareBlockStatus      = USB_DFU_BLOCK_TRANSFER_UNDEFINED;
                        s_DfuDevice->dfuManifestationPhaseStatus = USB_DFU_MANIFEST_IN_PROGRESS;
                        USB_DeviceDfuSetState(kState_DfuManifestSync);
                        s_DfuDevice->dfuIsDownloadingFinished = 1;
                    }
                    else
                    {
                        USB_DeviceDfuSetState(kState_DfuError);
                    }
                }
                break;
            case kUSB_DeviceDfuEventAbortReq:
                USB_DeviceDfuSetState(kState_DfuIdle);
                break;
            case kUSB_DeviceDfuEventUploadReq:
            case kUSB_DeviceDfuEventDetachReq:
                USB_DeviceDfuSetState(kState_DfuError);
                break;
            default:
                USB_DeviceDfuSetState(kState_DfuError);
                break;
        }
    }
    return error;
}

/*!
 * @brief DFU MANIFEST_SYNC state function.
 *
 * This function validates the event against the current state. And sets
 * the next state of the device.
 *
 * @return A USB error code or kStatus_USB_Success.
 */
static usb_status_t USB_DeviceStateDfuManifestSync(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event)
{
    usb_status_t error = kStatus_USB_Success;
    timerQueue_timer_object_t timerQueueTimerObject;

    if (NULL != event)
    {
        switch (event->name)
        {
            case kUSB_DeviceDfuEventGetStatusReq:
                if (USB_DFU_MANIFEST_IN_PROGRESS == s_DfuDevice->dfuManifestationPhaseStatus)
                {
                    USB_DeviceDfuSetState(kState_DfuManifest);
                    timerQueueTimerObject.timerCount = (uint32_t)(
                        (uint32_t)(0xFFFFFF & ((uint32_t)s_DfuDevice->dfuStatus.bwPollTimeout[2] << 16U)) +
                        (uint32_t)(0xFFFF & ((uint32_t)s_DfuDevice->dfuStatus.bwPollTimeout[1] << 8U)) +
                        (uint32_t)(0xFF & (uint32_t)s_DfuDevice->dfuStatus.bwPollTimeout[0]));
                    timerQueueTimerObject.timerCount     = (timerQueueTimerObject.timerCount >> 1);
                    timerQueueTimerObject.timerCallback  = (timerQueue_timer_callback)USB_DeviceDfuPollTimeoutIsr;
                    s_DfuDevice->dfuTimerId = TimerQueue_AddTimerQueue(&timerQueueTimerObject);
                }
                else if (USB_DFU_MANIFEST_COMPLETE == s_DfuDevice->dfuManifestationPhaseStatus)
                {
#if USB_DFU_BIT_MANIFESTATION_TOLERANT
                    USB_DeviceDfuSetState(kState_DfuIdle);

#endif
                }
                else
                {
                }
                break;
            case kUSB_DeviceDfuEventGetStateReq:
                USB_DeviceDfuSetState(kState_DfuManifestSync);
                break;
            case kUSB_DeviceDfuEventDnloadReq:
            case kUSB_DeviceDfuEventAbortReq:
            case kUSB_DeviceDfuEventUploadReq:
            case kUSB_DeviceDfuEventDetachReq:
                USB_DeviceDfuSetState(kState_DfuError);
                break;
            default:
                USB_DeviceDfuSetState(kState_DfuError);
                break;
        }
    }
    return error;
}

/*!
 * @brief DFU MANIFEST state function.
 *
 * This function validates the event against the current state. And sets
 * the next state of the device.
 *
 * @return A USB error code or kStatus_USB_Success.
 */
static usb_status_t USB_DeviceStateDfuManifest(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event)
{
    usb_status_t error = kStatus_USB_Success;

    if (NULL != event)
    {
        switch (event->name)
        {
            case kUSB_DeviceDfuEventGetStatusReq:
            case kUSB_DeviceDfuEventGetStateReq:
            case kUSB_DeviceDfuEventDnloadReq:
            case kUSB_DeviceDfuEventAbortReq:
            case kUSB_DeviceDfuEventUploadReq:
            case kUSB_DeviceDfuEventDetachReq:
                USB_DeviceDfuSetState(kState_DfuError);
                break;
            case kUSB_DeviceDfuEventPollTimeout:
#if USB_DFU_BIT_MANIFESTATION_TOLERANT
                USB_DeviceDfuSetState(kState_DfuManifestSync);
#else
                USB_DeviceDfuSetState(kState_DfuManifestWaitReset);
                s_DfuDevice->dfuReboot = 1;
#endif
                break;
            default:
                USB_DeviceDfuSetState(kState_DfuError);
                break;
        }
    }
    return error;
}

/*!
 * @brief DFU MANIFEST_WAIT_RESET state function.
 *
 * This function validates the event against the current state. And sets
 * the next state of the device.
 *
 * @return A USB error code or kStatus_USB_Success.
 */
static usb_status_t USB_DeviceStateDfuManifestWaitReset(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event)
{
    usb_status_t error = kStatus_USB_Success;

    if (NULL != event)
    {
        switch (event->name)
        {
            case kUSB_DeviceDfuEventGetStatusReq:
                s_DfuDevice->dfuReboot = 1;
                USB_DeviceDfuSetState(kState_DfuManifestWaitReset);
                break;
            case kUSB_DeviceDfuEventGetStateReq:
            case kUSB_DeviceDfuEventDnloadReq:
            case kUSB_DeviceDfuEventAbortReq:
            case kUSB_DeviceDfuEventUploadReq:
            case kUSB_DeviceDfuEventDetachReq:
            case kUSB_DeviceDfuEventPollTimeout:
                USB_DeviceDfuSetState(kState_DfuManifestWaitReset);
                break;
            default:
                USB_DeviceDfuSetState(kState_DfuManifestWaitReset);
                break;
        }
    }
    return error;
}

/*!
 * @brief DFU UPLOAD_IDLE state function.
 *
 * This function validates the event against the current state. And sets
 * the next state of the device.
 *
 * @return A USB error code or kStatus_USB_Success.
 */
static usb_status_t USB_DeviceStateDfuUpLoadIdle(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event)
{
    usb_status_t error = kStatus_USB_Success;

    if (NULL != event)
    {
        switch (event->name)
        {
            case kUSB_DeviceDfuEventGetStatusReq:
            case kUSB_DeviceDfuEventGetStateReq:
                USB_DeviceDfuSetState(kState_DfuUpLoadIdle);
                break;
            case kUSB_DeviceDfuEventAbortReq:
                USB_DeviceDfuSetState(kState_DfuIdle);
                break;
            case kUSB_DeviceDfuEventUploadReq:

                if (s_isShortFrame)
                {
                    USB_DeviceDfuSetState(kState_DfuIdle);
                }
                else if (event->wLength > 0)
                {
                    USB_DeviceDfuSetState(kState_DfuUpLoadIdle);
                }
                break;
            case kUSB_DeviceDfuEventDnloadReq:
            case kUSB_DeviceDfuEventDetachReq:
            case kUSB_DeviceDfuEventPollTimeout:
                USB_DeviceDfuSetState(kState_DfuError);
                break;
            default:
                USB_DeviceDfuSetState(kState_DfuError);
                break;
        }
    }
    return error;
}

/*!
 * @brief DFU ERROR state function.
 *
 * This function validates the event against the current state. And sets
 * the next state of the device.
 *
 * @return A USB error code or kStatus_USB_Success.
 */
static usb_status_t USB_DeviceStateDfuError(usb_dfu_struct_t *dfu_dev, usb_device_dfu_event_struct_t *event)
{
    usb_status_t error = kStatus_USB_Success;

    if (NULL != event)
    {
        switch (event->name)
        {
            case kUSB_DeviceDfuEventGetStatusReq:
            case kUSB_DeviceDfuEventGetStateReq:
                USB_DeviceDfuSetState(kState_DfuError);
                break;
            case kUSB_DeviceDfuEventClearStatusReq:
                USB_DeviceDfuSetState(kState_DfuIdle);
                break;
            case kUSB_DeviceDfuEventAbortReq:
            case kUSB_DeviceDfuEventUploadReq:
            case kUSB_DeviceDfuEventDnloadReq:
            case kUSB_DeviceDfuEventDetachReq:
            case kUSB_DeviceDfuEventPollTimeout:
                break;
            default:
                USB_DeviceDfuSetState(kState_DfuError);
                break;
        }
    }
    return error;
}

/*!
 * @brief DFU state update function.
 *
 * This function updates the DFU state according to the event.
 *
 * @return A USB error code or kStatus_USB_Success.
 */
usb_status_t USB_DeviceStateUpdate(void)
{
    usb_status_t error = kStatus_USB_Success;
    usb_device_dfu_event_struct_t event;
    usb_dfu_state_struct_t state;
    usb_dfu_struct_t *dfu_dev = s_DfuDevice;

    state = USB_Device${idCamelCase}$GetState();
    error = USB_DeviceDfuQueueGet(&s_DfuEventQueue, &event);
    if (kStatus_USB_Success == error)
    {
        if (kState_DfuError >= state)
        {
            s_dfuStateFunc[state](dfu_dev, &event);
        }
    }
    return error;
}
