<?xml version="1.0" encoding= "UTF-8" ?>
<component:config_component xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://swtools.freescale.net/XSD/component/1.0 http://swtools.freescale.net/XSD/component/1.0/component-9.0.xsd"
   xmlns:component="http://swtools.freescale.net/XSD/component/1.0" id="ftm" label="FTM" category="Peripheral driver">
   <sw_comp_ref name="platform.drivers.ftm" version="2.2.3"/>
   <description>FlexTimer Module (FTM)</description>
   <mode id="EdgeAligned" label="Edge-Aligned">
      <description>Edge aligned mode initialization. It supports Input Capture, Dual-edge Capture, Output Compare, PWM, Combined PWM and Timer Period Interrupt modes.</description>
      <config_set_refs>
         <config_set_ref>ftm_main_config</config_set_ref>
         <config_set_ref>ftm_edge_aligned_mode</config_set_ref>
      </config_set_refs>
      <master_peripheral>
         <peripheral_type>FTM</peripheral_type>
      </master_peripheral>
   </mode>
   <mode id="CenterAligned" label="Center-aligned">
      <description>Center aligned PWM mode initialization</description>
      <config_set_refs>
         <config_set_ref>ftm_main_config</config_set_ref>
         <config_set_ref>ftm_center_aligned_mode</config_set_ref>
      </config_set_refs>
      <master_peripheral>
         <peripheral_type>FTM</peripheral_type>
      </master_peripheral>
   </mode>
   <mode id="QuadratureDecoder" label="Quadrature Decoder">
      <description>Quadrature decoder mode initialization</description>
      <config_set_refs>
         <config_set_ref>ftm_main_config</config_set_ref>
         <config_set_ref>ftm_quadrature_decoder_mode</config_set_ref>
      </config_set_refs>
      <master_peripheral>
         <peripheral_type>FTM</peripheral_type>
      </master_peripheral>
   </mode>
   <user_functions>
      <function_def id="diff">(x,y) -> (x &gt; y) ? (x - y) : (y - x)</function_def>
      <function_def id="findBestDivider">(val, dividers) -> dividers.findFirst(x -> dividers.noneMatch(i -> (x != i) &amp;&amp; (diff(val, x) &gt; diff(val, i))))</function_def>     
   </user_functions>
   <!-- ******************** -->
   <!-- GENERATED CONFIG SET -->
   <!-- ******************** -->
   <config_set id="fsl_ftm" label="FlexTimer configuration" from_source="fsl_ftm.h">
      <description>For generated types only</description>
      <generated_types>
            <enum id="ftm_chnl_t" label="List of FTM channels" from="_ftm_chnl">
                <description>Actual number of available channels is SoC dependent</description>
                <item id="kFTM_Chnl_0" label="FTM channel number 0">
                    <description>FTM channel number 0</description>
                </item>
                <item id="kFTM_Chnl_1" label="FTM channel number 1">
                    <description>FTM channel number 1</description>
                </item>
                <item id="kFTM_Chnl_2" label="FTM channel number 2">
                    <description>FTM channel number 2</description>
                </item>
                <item id="kFTM_Chnl_3" label="FTM channel number 3">
                    <description>FTM channel number 3</description>
                </item>
                <item id="kFTM_Chnl_4" label="FTM channel number 4">
                    <description>FTM channel number 4</description>
                </item>
                <item id="kFTM_Chnl_5" label="FTM channel number 5">
                    <description>FTM channel number 5</description>
                </item>
                <item id="kFTM_Chnl_6" label="FTM channel number 6">
                    <description>FTM channel number 6</description>
                </item>
                <item id="kFTM_Chnl_7" label="FTM channel number 7">
                    <description>FTM channel number 7</description>
                </item>
            </enum>
            <enum id="ftm_fault_input_t" label="List of FTM faults" from="_ftm_fault_input">
                <description></description>
                <item id="kFTM_Fault_0" label="FTM fault 0 input pin">
                    <description>FTM fault 0 input pin</description>
                </item>
                <item id="kFTM_Fault_1" label="FTM fault 1 input pin">
                    <description>FTM fault 1 input pin</description>
                </item>
                <item id="kFTM_Fault_2" label="FTM fault 2 input pin">
                    <description>FTM fault 2 input pin</description>
                </item>
                <item id="kFTM_Fault_3" label="FTM fault 3 input pin">
                    <description>FTM fault 3 input pin</description>
                </item>
            </enum>
            <enum id="ftm_pwm_mode_t" label="FTM PWM operation modes" from="_ftm_pwm_mode">
                <description></description>
                <item id="kFTM_EdgeAlignedPwm" label="Edge-aligned PWM">
                    <description>Edge-aligned PWM</description>
                </item>
                <item id="kFTM_CenterAlignedPwm" label="Center-aligned PWM">
                    <description>Center-aligned PWM</description>
                </item>
                <item id="kFTM_CombinedPwm" label="Combined PWM">
                    <description>Combined PWM</description>
                </item>
                <item id="kFTM_ComplementaryPwm" label="Complementary PWM">
                    <description>Ccomplementary PWM</description>
                </item>
            </enum>
            <enum id="ftm_pwm_level_select_t" label="FTM PWM output pulse mode: high-true, low-true or no output" from="_ftm_pwm_level_select">
                <description></description>
                <item id="kFTM_NoPwmSignal" label="No PWM output on pin">
                    <description>No PWM output on pin</description>
                </item>
                <item id="kFTM_LowTrue" label="Low true pulses">
                    <description>Low true pulses</description>
                </item>
                <item id="kFTM_HighTrue" label="High true pulses">
                    <description>High true pulses</description>
                </item>
            </enum>
            <struct id="ftm_chnl_pwm_signal_param_t" label="Options to configure a FTM channel&apos;s PWM signal" from="_ftm_chnl_pwm_signal_param">
                <description></description>
                <reference id="chnlNumber" label="The channel/channel pair number" type="ftm_chnl_t">
                    <description>The channel/channel pair number. In combined mode, this represents the channel pair number.</description>
                </reference>
                <reference id="level" label="PWM output active level select" type="ftm_pwm_level_select_t">
                    <description>PWM output active level select.</description>
                </reference>
                <integer id="dutyCyclePercent" label="PWM pulse width, value should be between 0 to 100 0 = inactive signal(0% duty cycle)... 100 = always active signal (100% duty cycle)" type="uint8_t">
                    <description>PWM pulse width, value should be between 0 to 100 0 = inactive signal(0% duty cycle)... 100 = always active signal (100% duty cycle).</description>
                </integer>
                <integer id="firstEdgeDelayPercent" label="Used only in kFTM_AsymmetricalCombinedPwm mode to generate an asymmetrical PWM" type="uint8_t">
                    <description>Used only in kFTM_AsymmetricalCombinedPwm mode to generate an asymmetrical PWM. Specifies the delay to the first edge in a PWM period. If unsure leave as 0; Should be specified as a percentage of the PWM period</description>
                </integer>
                <bool id="enableDeadtime" label="Used only in combined PWM mode with enable complementary">
                    <description>Used only in combined PWM mode with enable complementary. true: The deadtime insertion in this pair of channels is enabled; false: The deadtime insertion in this pair of channels is disabled.</description>
                </bool>
            </struct>
            <struct id="ftm_chnl_pwm_config_param_t" label="Options to configure a FTM channel using precise setting" from="_ftm_chnl_pwm_config_param">
                <description></description>
                <reference id="chnlNumber" label="The channel/channel pair number" type="ftm_chnl_t">
                    <description>The channel/channel pair number. In combined mode, this represents the channel pair number.</description>
                </reference>
                <reference id="level" label="PWM output active level select" type="ftm_pwm_level_select_t">
                    <description>PWM output active level select.</description>
                </reference>
                <integer id="dutyValue" label="PWM pulse width, the uint of this value is timer ticks" type="uint16_t">
                    <description>PWM pulse width, the uint of this value is timer ticks.</description>
                </integer>
                <integer id="firstEdgeValue" label="Used only in kFTM_AsymmetricalCombinedPwm mode to generate an asymmetrical PWM" type="uint16_t">
                    <description>Used only in kFTM_AsymmetricalCombinedPwm mode to generate an asymmetrical PWM. Specifies the delay to the first edge in a PWM period. If unsure leave as 0, uint of this value is timer ticks.</description>
                </integer>
            </struct>
            <enum id="ftm_output_compare_mode_t" label="FlexTimer output compare mode" from="_ftm_output_compare_mode">
                <description></description>
                <item id="kFTM_NoOutputSignal" label="No channel output when counter reaches CnV">
                    <description>No channel output when counter reaches CnV</description>
                </item>
                <item id="kFTM_ToggleOnMatch" label="Toggle output">
                    <description>Toggle output</description>
                </item>
                <item id="kFTM_ClearOnMatch" label="Clear output">
                    <description>Clear output</description>
                </item>
                <item id="kFTM_SetOnMatch" label="Set output">
                    <description>Set output</description>
                </item>
            </enum>
            <enum id="ftm_input_capture_edge_t" label="FlexTimer input capture edge" from="_ftm_input_capture_edge">
                <description></description>
                <item id="kFTM_RisingEdge" label="Capture on rising edge only">
                    <description>Capture on rising edge only</description>
                </item>
                <item id="kFTM_FallingEdge" label="Capture on falling edge only">
                    <description>Capture on falling edge only</description>
                </item>
                <item id="kFTM_RiseAndFallEdge" label="Capture on rising or falling edge">
                    <description>Capture on rising or falling edge</description>
                </item>
            </enum>
            <enum id="ftm_dual_edge_capture_mode_t" label="FlexTimer dual edge capture modes" from="_ftm_dual_edge_capture_mode">
                <description></description>
                <item id="kFTM_OneShot" label="One-shot capture mode">
                    <description>One-shot capture mode</description>
                </item>
                <item id="kFTM_Continuous" label="Continuous capture mode">
                    <description>Continuous capture mode</description>
                </item>
            </enum>
            <struct id="ftm_dual_edge_capture_param_t" label="FlexTimer dual edge capture parameters" from="_ftm_dual_edge_capture_param">
                <description></description>
                <reference id="mode" label="Dual Edge Capture mode" type="ftm_dual_edge_capture_mode_t">
                    <description>Dual Edge Capture mode</description>
                </reference>
                <reference id="currChanEdgeMode" label="Input capture edge select for channel n" type="ftm_input_capture_edge_t">
                    <description>Input capture edge select for channel n</description>
                </reference>
                <reference id="nextChanEdgeMode" label="Input capture edge select for channel n+1" type="ftm_input_capture_edge_t">
                    <description>Input capture edge select for channel n+1</description>
                </reference>
            </struct>
            <enum id="ftm_quad_decode_mode_t" label="FlexTimer quadrature decode modes" from="_ftm_quad_decode_mode">
                <description></description>
                <item id="kFTM_QuadPhaseEncode" label="Phase A and Phase B encoding mode">
                    <description>Phase A and Phase B encoding mode</description>
                </item>
                <item id="kFTM_QuadCountAndDir" label="Count and direction encoding mode">
                    <description>Count and direction encoding mode</description>
                </item>
            </enum>
            <enum id="ftm_phase_polarity_t" label="FlexTimer quadrature phase polarities" from="_ftm_phase_polarity">
                <description></description>
                <item id="kFTM_QuadPhaseNormal" label="Phase input signal is not inverted">
                    <description>Phase input signal is not inverted</description>
                </item>
                <item id="kFTM_QuadPhaseInvert" label="Phase input signal is inverted">
                    <description>Phase input signal is inverted</description>
                </item>
            </enum>
            <struct id="ftm_phase_params_t" label="FlexTimer quadrature decode phase parameters" from="_ftm_phase_param">
                <description></description>
                <bool id="enablePhaseFilter" label="True: enable phase filter; false: disable filter">
                    <description>True: enable phase filter; false: disable filter</description>
                </bool>
                <integer id="phaseFilterVal" label="Filter value, used only if phase filter is enabled" type="uint32_t">
                    <description>Filter value, used only if phase filter is enabled</description>
                </integer>
                <reference id="phasePolarity" label="Phase polarity" type="ftm_phase_polarity_t">
                    <description>Phase polarity</description>
                </reference>
            </struct>
            <struct id="ftm_fault_param_t" label="Structure is used to hold the parameters to configure a FTM fault" from="_ftm_fault_param">
                <description></description>
                <bool id="enableFaultInput" label="True: Fault input is enabled; false: Fault input is disabled">
                    <description>True: Fault input is enabled; false: Fault input is disabled</description>
                </bool>
                <bool id="faultLevel" label="True: Fault polarity is active low; in other words, &apos;0&apos; indicates a fault; False: Fault polarity is active high">
                    <description>True: Fault polarity is active low; in other words, &apos;0&apos; indicates a fault; False: Fault polarity is active high</description>
                </bool>
                <bool id="useFaultFilter" label="True: Use the filtered fault signal; False: Use the direct path from fault input">
                    <description>True: Use the filtered fault signal; False: Use the direct path from fault input</description>
                </bool>
            </struct>
            <enum id="ftm_deadtime_prescale_t" label="FlexTimer pre-scaler factor for the dead time insertion" from="_ftm_deadtime_prescale">
                <description></description>
                <item id="kFTM_Deadtime_Prescale_1" label="Divide by 1">
                    <description>Divide by 1</description>
                </item>
                <item id="kFTM_Deadtime_Prescale_4" label="Divide by 4">
                    <description>Divide by 4</description>
                </item>
                <item id="kFTM_Deadtime_Prescale_16" label="Divide by 16">
                    <description>Divide by 16</description>
                </item>
            </enum>
            <enum id="ftm_clock_source_t" label="FlexTimer clock source selection" from="_ftm_clock_source">
                <description></description>
                <item id="kFTM_SystemClock" label="System clock selected">
                    <description>System clock selected</description>
                </item>
                <item id="kFTM_FixedClock" label="Fixed frequency clock">
                    <description>Fixed frequency clock</description>
                </item>
                <item id="kFTM_ExternalClock" label="External clock">
                    <description>External clock</description>
                </item>
            </enum>
            <enum id="ftm_clock_prescale_t" label="FlexTimer pre-scaler factor selection for the clock source" from="_ftm_clock_prescale">
                <description></description>
                <item id="kFTM_Prescale_Divide_1" label="Divide by 1">
                    <description>Divide by 1</description>
                </item>
                <item id="kFTM_Prescale_Divide_2" label="Divide by 2">
                    <description>Divide by 2</description>
                </item>
                <item id="kFTM_Prescale_Divide_4" label="Divide by 4">
                    <description>Divide by 4</description>
                </item>
                <item id="kFTM_Prescale_Divide_8" label="Divide by 8">
                    <description>Divide by 8</description>
                </item>
                <item id="kFTM_Prescale_Divide_16" label="Divide by 16">
                    <description>Divide by 16</description>
                </item>
                <item id="kFTM_Prescale_Divide_32" label="Divide by 32">
                    <description>Divide by 32</description>
                </item>
                <item id="kFTM_Prescale_Divide_64" label="Divide by 64">
                    <description>Divide by 64</description>
                </item>
                <item id="kFTM_Prescale_Divide_128" label="Divide by 128">
                    <description>Divide by 128</description>
                </item>
            </enum>
            <enum id="ftm_bdm_mode_t" label="Options for the FlexTimer behaviour in BDM Mode" from="_ftm_bdm_mode">
                <description></description>
                <item id="kFTM_BdmMode_0" label="FTM counter stopped, CH(n)F bit can be set, FTM channels in functional mode, writes to MOD,CNTIN and C(n)V registers bypass the register buffers">
                    <description>FTM counter stopped, CH(n)F bit can be set, FTM channels in functional mode, writes to MOD,CNTIN and C(n)V registers bypass the register buffers</description>
                </item>
                <item id="kFTM_BdmMode_1" label="FTM counter stopped, CH(n)F bit is not set, FTM channels outputs are forced to their safe value , writes to MOD,CNTIN and C(n)V registers bypass the register buffers">
                    <description>FTM counter stopped, CH(n)F bit is not set, FTM channels outputs are forced to their safe value , writes to MOD,CNTIN and C(n)V registers bypass the register buffers</description>
                </item>
                <item id="kFTM_BdmMode_2" label="FTM counter stopped, CH(n)F bit is not set, FTM channels outputs are frozen when chip enters in BDM mode, writes to MOD,CNTIN and C(n)V registers bypass the register buffers">
                    <description>FTM counter stopped, CH(n)F bit is not set, FTM channels outputs are frozen when chip enters in BDM mode, writes to MOD,CNTIN and C(n)V registers bypass the register buffers</description>
                </item>
                <item id="kFTM_BdmMode_3" label="FTM counter in functional mode, CH(n)F bit can be set, FTM channels in functional mode, writes to MOD,CNTIN and C(n)V registers is in fully functional mode">
                    <description>FTM counter in functional mode, CH(n)F bit can be set, FTM channels in functional mode, writes to MOD,CNTIN and C(n)V registers is in fully functional mode</description>
                </item>
            </enum>
            <enum id="ftm_fault_mode_t" label="Options for the FTM fault control mode" from="_ftm_fault_mode">
                <description></description>
                <item id="kFTM_Fault_Disable" label="Fault control is disabled for all channels">
                    <description>Fault control is disabled for all channels</description>
                </item>
                <item id="kFTM_Fault_EvenChnls" label="Enabled for even channels only(0,2,4,6) with manual fault clearing">
                    <description>Enabled for even channels only(0,2,4,6) with manual fault clearing</description>
                </item>
                <item id="kFTM_Fault_AllChnlsMan" label="Enabled for all channels with manual fault clearing">
                    <description>Enabled for all channels with manual fault clearing</description>
                </item>
                <item id="kFTM_Fault_AllChnlsAuto" label="Enabled for all channels with automatic fault clearing">
                    <description>Enabled for all channels with automatic fault clearing</description>
                </item>
            </enum>
            <enum id="ftm_external_trigger_t" label="FTM external trigger options" from="_ftm_external_trigger">
                <description>Actual available external trigger sources are SoC-specific</description>
                <item id="kFTM_Chnl0Trigger" label="Generate trigger when counter equals chnl 0 CnV reg">
                    <description>Generate trigger when counter equals chnl 0 CnV reg</description>
                </item>
                <item id="kFTM_Chnl1Trigger" label="Generate trigger when counter equals chnl 1 CnV reg">
                    <description>Generate trigger when counter equals chnl 1 CnV reg</description>
                </item>
                <item id="kFTM_Chnl2Trigger" label="Generate trigger when counter equals chnl 2 CnV reg">
                    <description>Generate trigger when counter equals chnl 2 CnV reg</description>
                </item>
                <item id="kFTM_Chnl3Trigger" label="Generate trigger when counter equals chnl 3 CnV reg">
                    <description>Generate trigger when counter equals chnl 3 CnV reg</description>
                </item>
                <item id="kFTM_Chnl4Trigger" label="Generate trigger when counter equals chnl 4 CnV reg">
                    <description>Generate trigger when counter equals chnl 4 CnV reg</description>
                </item>
                <item id="kFTM_Chnl5Trigger" label="Generate trigger when counter equals chnl 5 CnV reg">
                    <description>Generate trigger when counter equals chnl 5 CnV reg</description>
                </item>
                <item id="kFTM_Chnl6Trigger" label="Available on certain SoC&apos;s, generate trigger when counter equals chnl 6 CnV reg" available="(featureDefined(`FSL_FEATURE_FTM_HAS_CHANNEL6_TRIGGER`) &amp;&amp; getFeature(`FSL_FEATURE_FTM_HAS_CHANNEL6_TRIGGER`))">
                    <description>Available on certain SoC&apos;s, generate trigger when counter equals chnl 6 CnV reg</description>
                </item>
                <item id="kFTM_Chnl7Trigger" label="Available on certain SoC&apos;s, generate trigger when counter equals chnl 7 CnV reg" available="(featureDefined(`FSL_FEATURE_FTM_HAS_CHANNEL6_TRIGGER`) &amp;&amp; getFeature(`FSL_FEATURE_FTM_HAS_CHANNEL6_TRIGGER`))">
                    <description>Available on certain SoC&apos;s, generate trigger when counter equals chnl 7 CnV reg</description>
                </item>
                <item id="kFTM_InitTrigger" label="Generate Trigger when counter is updated with CNTIN">
                    <description>Generate Trigger when counter is updated with CNTIN</description>
                </item>
                <item id="kFTM_ReloadInitTrigger" label="Available on certain SoC&apos;s, trigger on reload point">
                    <description>Available on certain SoC&apos;s, trigger on reload point</description>
                </item>
            </enum>
            <enum id="ftm_pwm_sync_method_t" label="FlexTimer PWM sync options to update registers with buffer" from="_ftm_pwm_sync_method">
                <description></description>
                <item id="kFTM_SoftwareTrigger" label="Software triggers PWM sync">
                    <description>Software triggers PWM sync</description>
                </item>
                <item id="kFTM_HardwareTrigger_0" label="Hardware trigger 0 causes PWM sync">
                    <description>Hardware trigger 0 causes PWM sync</description>
                </item>
                <item id="kFTM_HardwareTrigger_1" label="Hardware trigger 1 causes PWM sync">
                    <description>Hardware trigger 1 causes PWM sync</description>
                </item>
                <item id="kFTM_HardwareTrigger_2" label="Hardware trigger 2 causes PWM sync">
                    <description>Hardware trigger 2 causes PWM sync</description>
                </item>
            </enum>
            <enum id="ftm_reload_point_t" label="FTM options available as loading point for register reload" from="_ftm_reload_point">
                <description>Actual available reload points are SoC-specific</description>
                <item id="kFTM_Chnl0Match" label="Channel 0 match included as a reload point">
                    <description>Channel 0 match included as a reload point</description>
                </item>
                <item id="kFTM_Chnl1Match" label="Channel 1 match included as a reload point">
                    <description>Channel 1 match included as a reload point</description>
                </item>
                <item id="kFTM_Chnl2Match" label="Channel 2 match included as a reload point">
                    <description>Channel 2 match included as a reload point</description>
                </item>
                <item id="kFTM_Chnl3Match" label="Channel 3 match included as a reload point">
                    <description>Channel 3 match included as a reload point</description>
                </item>
                <item id="kFTM_Chnl4Match" label="Channel 4 match included as a reload point">
                    <description>Channel 4 match included as a reload point</description>
                </item>
                <item id="kFTM_Chnl5Match" label="Channel 5 match included as a reload point">
                    <description>Channel 5 match included as a reload point</description>
                </item>
                <item id="kFTM_Chnl6Match" label="Channel 6 match included as a reload point">
                    <description>Channel 6 match included as a reload point</description>
                </item>
                <item id="kFTM_Chnl7Match" label="Channel 7 match included as a reload point">
                    <description>Channel 7 match included as a reload point</description>
                </item>
                <item id="kFTM_CntMax" label="Use in up-down count mode only, reload when counter reaches the maximum value">
                    <description>Use in up-down count mode only, reload when counter reaches the maximum value</description>
                </item>
                <item id="kFTM_CntMin" label="Use in up-down count mode only, reload when counter reaches the minimum value">
                    <description>Use in up-down count mode only, reload when counter reaches the minimum value</description>
                </item>
                <item id="kFTM_HalfCycMatch" label="Available on certain SoC&apos;s, half cycle match reload point">
                    <description>Available on certain SoC&apos;s, half cycle match reload point</description>
                </item>
            </enum>
            <enum id="ftm_interrupt_enable_t" label="List of FTM interrupts" from="_ftm_interrupt_enable">
                <description>Actual available interrupts are SoC-specific</description>
                <item id="kFTM_Chnl0InterruptEnable" label="Channel 0 interrupt">
                    <description>Channel 0 interrupt</description>
                </item>
                <item id="kFTM_Chnl1InterruptEnable" label="Channel 1 interrupt">
                    <description>Channel 1 interrupt</description>
                </item>
                <item id="kFTM_Chnl2InterruptEnable" label="Channel 2 interrupt">
                    <description>Channel 2 interrupt</description>
                </item>
                <item id="kFTM_Chnl3InterruptEnable" label="Channel 3 interrupt">
                    <description>Channel 3 interrupt</description>
                </item>
                <item id="kFTM_Chnl4InterruptEnable" label="Channel 4 interrupt">
                    <description>Channel 4 interrupt</description>
                </item>
                <item id="kFTM_Chnl5InterruptEnable" label="Channel 5 interrupt">
                    <description>Channel 5 interrupt</description>
                </item>
                <item id="kFTM_Chnl6InterruptEnable" label="Channel 6 interrupt">
                    <description>Channel 6 interrupt</description>
                </item>
                <item id="kFTM_Chnl7InterruptEnable" label="Channel 7 interrupt">
                    <description>Channel 7 interrupt</description>
                </item>
                <item id="kFTM_FaultInterruptEnable" label="Fault interrupt">
                    <description>Fault interrupt</description>
                </item>
                <item id="kFTM_TimeOverflowInterruptEnable" label="Time overflow interrupt">
                    <description>Time overflow interrupt</description>
                </item>
                <item id="kFTM_ReloadInterruptEnable" label="Reload interrupt; Available only on certain SoC&apos;s">
                    <description>Reload interrupt; Available only on certain SoC&apos;s</description>
                </item>
            </enum>
            <enum id="ftm_status_flags_t" label="List of FTM flags" from="_ftm_status_flags">
                <description>Actual available flags are SoC-specific</description>
                <item id="kFTM_Chnl0Flag" label="Channel 0 Flag">
                    <description>Channel 0 Flag</description>
                </item>
                <item id="kFTM_Chnl1Flag" label="Channel 1 Flag">
                    <description>Channel 1 Flag</description>
                </item>
                <item id="kFTM_Chnl2Flag" label="Channel 2 Flag">
                    <description>Channel 2 Flag</description>
                </item>
                <item id="kFTM_Chnl3Flag" label="Channel 3 Flag">
                    <description>Channel 3 Flag</description>
                </item>
                <item id="kFTM_Chnl4Flag" label="Channel 4 Flag">
                    <description>Channel 4 Flag</description>
                </item>
                <item id="kFTM_Chnl5Flag" label="Channel 5 Flag">
                    <description>Channel 5 Flag</description>
                </item>
                <item id="kFTM_Chnl6Flag" label="Channel 6 Flag">
                    <description>Channel 6 Flag</description>
                </item>
                <item id="kFTM_Chnl7Flag" label="Channel 7 Flag">
                    <description>Channel 7 Flag</description>
                </item>
                <item id="kFTM_FaultFlag" label="Fault Flag">
                    <description>Fault Flag</description>
                </item>
                <item id="kFTM_TimeOverflowFlag" label="Time overflow Flag">
                    <description>Time overflow Flag</description>
                </item>
                <item id="kFTM_ChnlTriggerFlag" label="Channel trigger Flag">
                    <description>Channel trigger Flag</description>
                </item>
                <item id="kFTM_ReloadFlag" label="Reload Flag; Available only on certain SoC&apos;s">
                    <description>Reload Flag; Available only on certain SoC&apos;s</description>
                </item>
            </enum>
            <struct id="ftm_config_t" label="FTM configuration structure" from="_ftm_config">
                <description>This structure holds the configuration settings for the FTM peripheral. To initialize this structure to reasonable defaults, call the FTM_GetDefaultConfig() function and pass a pointer to the configuration structure instance.The configuration structure can be made constant so as to reside in flash.</description>
                <reference id="prescale" label="FTM clock prescale value" type="ftm_clock_prescale_t">
                    <description>FTM clock prescale value</description>
                </reference>
                <reference id="bdmMode" label="FTM behavior in BDM mode" type="ftm_bdm_mode_t">
                    <description>FTM behavior in BDM mode</description>
                </reference>
                <integer id="pwmSyncMode" label="Synchronization methods to use to update buffered registers; Multiple update modes can be used by providing an OR&apos;ed list of options available in enumeration ftm_pwm_sync_method_t" type="uint32_t">
                    <description>Synchronization methods to use to update buffered registers; Multiple update modes can be used by providing an OR&apos;ed list of options available in enumeration ftm_pwm_sync_method_t.</description>
                </integer>
                <integer id="reloadPoints" label="FTM reload points; When using this, the PWM synchronization is not required" type="uint32_t">
                    <description>FTM reload points; When using this, the PWM synchronization is not required. Multiple reload points can be used by providing an OR&apos;ed list of options available in enumeration ftm_reload_point_t.</description>
                </integer>
                <reference id="faultMode" label="FTM fault control mode" type="ftm_fault_mode_t">
                    <description>FTM fault control mode</description>
                </reference>
                <integer id="faultFilterValue" label="Fault input filter value" type="uint8_t">
                    <description>Fault input filter value</description>
                </integer>
                <reference id="deadTimePrescale" label="The dead time prescalar value" type="ftm_deadtime_prescale_t">
                    <description>The dead time prescalar value</description>
                </reference>
                <integer id="deadTimeValue" label="The dead time value deadTimeValue&apos;s available range is 0-1023 when register has DTVALEX, otherwise its available range is 0-63" type="uint32_t">
                    <description>The dead time value deadTimeValue&apos;s available range is 0-1023 when register has DTVALEX, otherwise its available range is 0-63.</description>
                </integer>
                <integer id="extTriggers" label="External triggers to enable" type="uint32_t">
                    <description>External triggers to enable. Multiple trigger sources can be enabled by providing an OR&apos;ed list of options available in enumeration ftm_external_trigger_t.</description>
                </integer>
                <integer id="chnlInitState" label="Defines the initialization value of the channels in OUTINT register" type="uint8_t">
                    <description>Defines the initialization value of the channels in OUTINT register</description>
                </integer>
                <integer id="chnlPolarity" label="Defines the output polarity of the channels in POL register" type="uint8_t">
                    <description>Defines the output polarity of the channels in POL register</description>
                </integer>
                <bool id="useGlobalTimeBase" label="True: Use of an external global time base is enabled; False: disabled">
                    <description>True: Use of an external global time base is enabled; False: disabled</description>
                </bool>
            </struct>
        </generated_types>
      <user_types>
         <enum id="ftm_chnl_t" label="List of FTM channels" from="_ftm_chnl">
            <description>Actual number of available channels is SoC dependent</description>
            <item id="kFTM_Chnl_0" label="FTM channel 0">
               <description>FTM channel number 0</description>
            </item>
            <item id="kFTM_Chnl_1" label="FTM channel 1">
               <description>FTM channel number 1</description>
            </item>
            <item id="kFTM_Chnl_2" label="FTM channel 2">
               <description>FTM channel number 2</description>
            </item>
            <item id="kFTM_Chnl_3" label="FTM channel 3">
               <description>FTM channel number 3</description>
            </item>
            <item id="kFTM_Chnl_4" label="FTM channel 4">
               <description>FTM channel number 4</description>
            </item>
            <item id="kFTM_Chnl_5" label="FTM channel 5">
               <description>FTM channel number 5</description>
            </item>
            <item id="kFTM_Chnl_6" label="FTM channel 6">
               <description>FTM channel number 6</description>
            </item>
            <item id="kFTM_Chnl_7" label="FTM channel 7">
               <description>FTM channel number 7</description>
            </item>
         </enum>
         <enum id="ftm_input_capture_edge_t" label="FlexTimer input capture edge" from="_ftm_input_capture_edge">
            <description></description>
            <item id="kFTM_RisingEdge" label="Rising edge">
               <description>Capture on rising edge only</description>
            </item>
            <item id="kFTM_FallingEdge" label="Falling edge">
               <description>Capture on falling edge only</description>
            </item>
            <item id="kFTM_RiseAndFallEdge" label="Rising and falling edges">
               <description>Capture on rising and falling edges (both edges).</description>
            </item>
         </enum>
         <enum id="ftm_dual_edge_capture_mode_t" label="FlexTimer dual edge capture modes" from="_ftm_dual_edge_capture_mode">
            <description></description>
            <item id="kFTM_OneShot" label="One-shot">
               <description>One-shot capture mode</description>
            </item>
            <item id="kFTM_Continuous" label="Continuous">
               <description>Continuous capture mode</description>
            </item>
         </enum>
         <struct id="ftm_dual_edge_capture_param_t" label="FlexTimer dual edge capture parameters" from="_ftm_dual_edge_capture_param">
            <description>Configuration of the dual edge capture mode parameters.</description>
            <reference id="mode" label="Dual Edge Capture mode" type="ftm_dual_edge_capture_mode_t">
               <description>Selection of the the dual edge capture mode.</description>
            </reference>
            <reference id="currChanEdgeMode" label="Input capture edge for first channel" type="ftm_input_capture_edge_t">
               <description>Selection of the input capture edge for first channel of the pair.</description>
            </reference>
            <reference id="nextChanEdgeMode" label="Input capture edge for second channel" type="ftm_input_capture_edge_t">
               <description>Selection of the input capture edge for second channel of the pair.</description>
            </reference>
         </struct>
         <enum id="ftm_bdm_mode_t" label="FTM behaviour in BDM Mode" from="_ftm_bdm_mode">
            <description></description>
            <item id="kFTM_BdmMode_0" label="Counter stopped, channels and flags in functional mode">
               <description>FTM counter stopped, CH(n)F bit can be set, FTM channels in functional mode, writes to MOD,CNTIN and C(n)V registers bypass the register buffers.</description>
            </item>
            <item id="kFTM_BdmMode_1" label="Counter stopped, channels outputs are forced to safe values">
               <description>FTM counter stopped, CH(n)F bit is not set, FTM channels outputs are forced to their safe value according to POLn bit, writes to MOD,CNTIN and C(n)V registers bypass the register buffers.</description>
            </item>
            <item id="kFTM_BdmMode_2" label="Counter stopped, channels outputs are frozen">
               <description>FTM counter stopped, CH(n)F bit is not set, FTM channels outputs are frozen when chip enters in BDM mode, writes to MOD,CNTIN and C(n)V registers bypass the register buffers.</description>
            </item>
            <item id="kFTM_BdmMode_3" label="Counter and channels in functional mode">
               <description>FTM counter in functional mode, CH(n)F bit can be set, FTM channels in functional mode, writes to MOD,CNTIN and C(n)V registers is in fully functional mode.</description>
            </item>
         </enum>
      </user_types>
      <settings>
      </settings>
      <quick_selections>
      </quick_selections>
   </config_set>
   <!-- *************************** -->
   <!-- END OF GENERATED CONFIG SET -->
   <!-- *************************** -->
   <config_set id="ftm_main_config" label="FTM general configuration" from_source="fsl_ftm.h">
      <description>FlexTimer general configuration (without channels)</description>
      <generated_types>
      </generated_types>
      <user_types>
         <enum id="ftm_clock_prescale_t" label="FlexTimer pre-scaler factor selection for the clock source" from="_ftm_clock_prescale">
            <description></description>
            <item id="kFTM_Prescale_Divide_1" label="Divide by 1">
               <description>Divide by 1</description>
            </item>
            <item id="kFTM_Prescale_Divide_2" label="Divide by 2">
               <description>Divide by 2</description>
            </item>
            <item id="kFTM_Prescale_Divide_4" label="Divide by 4">
               <description>Divide by 4</description>
            </item>
            <item id="kFTM_Prescale_Divide_8" label="Divide by 8">
               <description>Divide by 8</description>
            </item>
            <item id="kFTM_Prescale_Divide_16" label="Divide by 16">
               <description>Divide by 16</description>
            </item>
            <item id="kFTM_Prescale_Divide_32" label="Divide by 32">
               <description>Divide by 32</description>
            </item>
            <item id="kFTM_Prescale_Divide_64" label="Divide by 64">
               <description>Divide by 64</description>
            </item>
            <item id="kFTM_Prescale_Divide_128" label="Divide by 128">
               <description>Divide by 128</description>
            </item>
         </enum>
         <set id="ftm_pwm_sync_method_t" label="FlexTimer PWM sync options to update registers with buffer.">
            <item id="kFTM_SoftwareTrigger" label="Software triggers PWM sync"/>
            <item id="kFTM_HardwareTrigger_0" label="Hardware trigger 0 causes PWM sync"/>
            <item id="kFTM_HardwareTrigger_1" label="Hardware trigger 1 causes PWM sync"/>
            <item id="kFTM_HardwareTrigger_2" label="Hardware trigger 2 causes PWM sync"/>
         </set>
         <set id="ftm_external_trigger_t" label="FTM external trigger options.">
            <description>Actual available external trigger sources are SoC-specific</description>
            <item id="kFTM_Chnl0Trigger" label="Counter equals chnl 0 CnV reg"/>
            <item id="kFTM_Chnl1Trigger" label="Counter equals chnl 1 CnV reg"/>
            <item id="kFTM_Chnl2Trigger" label="Counter equals chnl 2 CnV reg"/>
            <item id="kFTM_Chnl3Trigger" label="Counter equals chnl 3 CnV reg"/>
            <item id="kFTM_Chnl4Trigger" label="Counter equals chnl 4 CnV reg"/>
            <item id="kFTM_Chnl5Trigger" label="Counter equals chnl 5 CnV reg"/>
            <item id="kFTM_Chnl6Trigger" label="Counter equals chnl 6 CnV reg" available="(featureDefined(`FSL_FEATURE_FTM_HAS_CHANNEL6_TRIGGER`) &amp;&amp; getFeature(`FSL_FEATURE_FTM_HAS_CHANNEL6_TRIGGER`))"/>
            <item id="kFTM_Chnl7Trigger" label="Counter equals chnl 7 CnV reg" available="(featureDefined(`FSL_FEATURE_FTM_HAS_CHANNEL7_TRIGGER`) &amp;&amp; getFeature(`FSL_FEATURE_FTM_HAS_CHANNEL7_TRIGGER`))"/>
            <item id="kFTM_InitTrigger" label="Trigger when counter is updated with CNTIN"/>
            <item id="kFTM_ReloadInitTrigger" label="Trigger on reload point" available="featureDefined(`FSL_FEATURE_FTM_HAS_RELOAD_INITIALIZATION_TRIGGER`) &amp;&amp; getFeature(`FSL_FEATURE_FTM_HAS_RELOAD_INITIALIZATION_TRIGGER`)"/>
         </set>
         <set id="ftm_interrupt_enable_t" label="List of FTM interrupts.">
            <description>Actual available interrupts are SoC-specific</description>
<!--        The channel interrupts settings is a part of the channels' configuration    
            <item id="kFTM_Chnl0InterruptEnable" label="Channel 0 interrupt"/>
            <item id="kFTM_Chnl1InterruptEnable" label="Channel 1 interrupt"/>
            <item id="kFTM_Chnl2InterruptEnable" label="Channel 2 interrupt"/>
            <item id="kFTM_Chnl3InterruptEnable" label="Channel 3 interrupt"/>
            <item id="kFTM_Chnl4InterruptEnable" label="Channel 4 interrupt"/>
            <item id="kFTM_Chnl5InterruptEnable" label="Channel 5 interrupt"/>
            <item id="kFTM_Chnl6InterruptEnable" label="Channel 6 interrupt"/>
            <item id="kFTM_Chnl7InterruptEnable" label="Channel 7 interrupt"/>-->
            <item id="kFTM_FaultInterruptEnable" label="Fault interrupt"/>
            <item id="kFTM_TimeOverflowInterruptEnable" label="Time overflow interrupt"/>
            <item id="kFTM_ReloadInterruptEnable" label="Reload interrupt" available="featureDefined(`FSL_FEATURE_FTM_HAS_RELOAD_INTERRUPT`) &amp;&amp; getFeature(`FSL_FEATURE_FTM_HAS_RELOAD_INTERRUPT`)"/>
         </set>
         <set id="ftm_reload_point_t" label="FTM options available as loading point for register reload.">
            <description>Actual available reload points are SoC-specific</description>
            <item id="kFTM_Chnl0Match" label="Channel 0 match"/>
            <item id="kFTM_Chnl1Match" label="Channel 1 match" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 1"/>
            <item id="kFTM_Chnl2Match" label="Channel 2 match" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 2"/>
            <item id="kFTM_Chnl3Match" label="Channel 3 match" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 3"/>
            <item id="kFTM_Chnl4Match" label="Channel 4 match" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 4"/>
            <item id="kFTM_Chnl5Match" label="Channel 5 match" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 5"/>
            <item id="kFTM_Chnl6Match" label="Channel 6 match" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 6"/>
            <item id="kFTM_Chnl7Match" label="Channel 7 match" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 7"/>
            <item id="kFTM_CntMax" label="Counter reaches the maximum value (in up-down count mode)"/>
            <item id="kFTM_CntMin" label="Counter reaches the minimum value (in up-down count mode)"/>
            <item id="kFTM_HalfCycMatch" label="Half cycle match" available="featureDefined(`FSL_FEATURE_FTM_HAS_HALFCYCLE_RELOAD`) &amp;&amp; getFeature(`FSL_FEATURE_FTM_HAS_HALFCYCLE_RELOAD`)"/>
         </set>
         <set id="ftm_init_output_value_t" label="FTM output initialization value set.">
            <description>Output initiliazation values for FTM channels</description>
            <item id="kFTM_Chnl0OutInitHighLevel" label="Channel 0 set to 1" value="1"/>
            <item id="kFTM_Chnl1OutInitHighLevel" label="Channel 1 set to 1" value="2" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 1"/>
            <item id="kFTM_Chnl2OutInitHighLevel" label="Channel 2 set to 1" value="4" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 2"/>
            <item id="kFTM_Chnl3OutInitHighLevel" label="Channel 3 set to 1" value="8" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 3"/>
            <item id="kFTM_Chnl4OutInitHighLevel" label="Channel 4 set to 1" value="16" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 4"/>
            <item id="kFTM_Chnl5OutInitHighLevel" label="Channel 5 set to 1" value="32" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 5"/>
            <item id="kFTM_Chnl6OutInitHighLevel" label="Channel 6 set to 1" value="64" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 6"/>
            <item id="kFTM_Chnl7OutInitHighLevel" label="Channel 7 set to 1" value="128" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 7"/>
         </set>
         <set id="ftm_output_polarity_t" label="FTM output polarity set.">
            <description>Output polarity of FTM channels. When selected the negative polarity (active low) is set.</description>
            <item id="kFTM_Chnl0OutActiveLow" label="Channel 0 active low" value="1"/>
            <item id="kFTM_Chnl1OutActiveLow" label="Channel 1 active low" value="2" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 1"/>
            <item id="kFTM_Chnl2OutActiveLow" label="Channel 2 active low" value="4" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 2"/>
            <item id="kFTM_Chnl3OutActiveLow" label="Channel 3 active low" value="8" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 3"/>
            <item id="kFTM_Chnl4OutActiveLow" label="Channel 4 active low" value="16" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 4"/>
            <item id="kFTM_Chnl5OutActiveLow" label="Channel 5 active low" value="32" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 5"/>
            <item id="kFTM_Chnl6OutActiveLow" label="Channel 6 active low" value="64" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 6"/>
            <item id="kFTM_Chnl7OutActiveLow" label="Channel 7 active low" value="128" available="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; getFeature(`FTM_CHANNEL_COUNT`).toInt() > 7"/>
         </set>
         <enum id="ftm_clock_source_t" label="FlexTimer clock source selection." from="_ftm_clock_source">
            <item id="kFTM_SystemClock" label="System clock selected" value="BusInterfaceClock"/> <!-- value = clock_unify_ID -->
            <item id="kFTM_FixedClock" label="Fixed frequency clock" value="FixedClock"/>
            <item id="kFTM_ExternalClock" label="External clock" value="ExternalClock"/>
         </enum>
         <enum id="ftm_deadtime_prescale_t" label="FlexTimer pre-scaler factor for the dead time insertion" from="_ftm_deadtime_prescale">
            <description></description>
            <item id="kFTM_Deadtime_Prescale_1" label="Divide by 1" value="1">
               <description>Divide by 1</description>
            </item>
            <item id="kFTM_Deadtime_Prescale_4" label="Divide by 4" value="4">
               <description>Divide by 4</description>
            </item>
            <item id="kFTM_Deadtime_Prescale_16" label="Divide by 16" value="16">
               <description>Divide by 16</description>
            </item>
         </enum>
         <enum id="fault_level_t">
            <item id="low" label="Low" >
               <description>Active level of the fault input is the low level (the low level at the fault input indicates a fault).</description>
            </item>
            <item id="high" label="High" >
               <description>Active level of the fault input is the high level (the high level at the fault input indicates a fault).</description>
            </item>
         </enum>
         <enum id="ftm_fault_input_t" label="FTM fault inputs" from="_ftm_fault_input">
            <item id="kFTM_Fault_0" label="Fault 0" value="0">
               <description>FTM fault 0 input pin (FTL, 0)</description>
            </item>
            <item id="kFTM_Fault_1" label="Fault 1" value="1">
               <description>FTM fault 1 input pin (FTL, 1)</description>
            </item>
            <item id="kFTM_Fault_2" label="Fault 2" value="2">
               <description>FTM fault 2 input pin (FTL, 2)</description>
            </item>
            <item id="kFTM_Fault_3" label="Fault 3" value="3">
               <description>FTM fault 3 input pin (FTL, 3)</description>
            </item>
         </enum>
         <struct id="ftm_fault_param_t" label="FTM fault parameters" from="_ftm_fault_param">
            <description>Fault inputs configuration.</description>
            <validation>
               <dependency when_expr="$this.enableFaultInput.getValue()" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_fault.` +  ($this.getId())" description_expr="`Signal FLT` + ($this.getId()) + ` of peripheral ` + $instance.getPeripheral() + ` is not supported for this instance of the FTM`" level="Error">
                  <feature name="exists" evaluation="equal">
                     <data expr="true"/>
                  </feature>
               </dependency>
               <dependency when_expr="$this.enableFaultInput.getValue()" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_fault.` +  ($this.getId())" description_expr="`Signal FLT` + ($this.getId()) + ` of peripheral ` + $instance.getPeripheral() + ` is not routed`" level="Warning">
                  <feature name="routed" evaluation="equal">
                     <data expr="true"/>
                  </feature>
               </dependency>
            </validation>
            <info id="inputNumber" label="Input" value="$configSet.enumItemsOfType(`ftm_fault_input_t`).findFirst(i -> i.getValue() ==  $parent.getId()).getLabel()" ></info>
            <bool id="enableFaultInput" label="Enable">
               <description>Enable fault input of the timer and its initialization. When disable the initialization of the input is not provided at all.</description>
            </bool>
            <reference id="faultLevelVal" label="Fault level" type="fault_level_t" options="remove_from_struct_init" enable="$parent.enableFaultInput.getValue()"></reference>
            <variable id="faultLevel" value="($parent.faultLevelVal.getValue() == `low`) ? `true` : `false`" options="add_to_struct"></variable>
            <!-- replaced by the variable 
               <bool id="faultLevel" label="True: Fault polarity is active low; in other words, &apos;0&apos; indicates a fault; False: Fault polarity is active high">
               <description>True: Fault polarity is active low; in other words, &apos;0&apos; indicates a fault; False: Fault polarity is active high</description>
            </bool>-->
            <bool id="useFaultFilter" label="Enable filter" enable="$parent.enableFaultInput.getValue()">
               <description>Enable filter of fault signal. The configuration of the fault filter period is available in the Fault input filter period.</description>
            </bool>
         </struct>
         <!-- The FTM timer main configuration structure -->
         <struct id="ftm_config_t" label="FTM configuration structure." from="_ftm_config">
            <description>This structure holds the configuration settings for the FTM peripheral. To initialize this structure to reasonable defaults, call the FTM_GetDefaultConfig() function and pass a pointer to the configuration structure instance. The configuration structure can be made constant so as to reside in flash.</description>
            <!-- System/filter clock source -->
            <info id="functionalClockSourceLine" value="`Functional clock of timer`"  options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init">
               <description>Functional clock source selection that is used for the timer.</description>
            </info>
            <reference id="_clockSource" label="Clock source" type="ftm_clock_source_t" options="remove_from_struct_init" available="false"/> <!-- item used for clockSource dynamic enum implementation only -->
            <variable id="clockSourceUId" value="$parent.clockSource.getEnumItemValue()"/>
            <dynamic_enum id="clockSource" label="Clock source" options="remove_from_struct_init" items="enumItemsOf($parent._clockSource).arrayToEnumItems(
               enumItem -> true,
               enumItem -> enumItem.getID(),
               enumItem -> getPeripheralClock($instance.getPeripheral(), enumItem.getValue()),
               enumItem -> enumItem.getValue())">
               <description>FTM timer clock source selection.</description>
               <validation>
                  <dependency when_expr="$this.getEnumItemValue() == `ExternalClock`" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.` + getPeripheralClockSignal($instance.getPeripheral(), $this.getEnumItemValue())" description_expr="`External clock source signal ` +  getPeripheralClock($instance.getPeripheral(), $this.getEnumItemValue()) + ` of peripheral ` + $instance.getPeripheral() + ` is not routed`" level="Warning">
                     <feature name="routed" evaluation="equal">
                        <data expr="true"/>
                     </feature>
                  </dependency>
                  <dependency when_expr="(getPeripheralClockType($instance.getPeripheral(),$parent.clockSourceUId.getValue()) == `INPUT_SIGNAL`) &amp;&amp; ($parent.clockSourceFreq.getEnumItemId() == `GetFreq`)" resource_type="ClockOutput" resource_id_expr="getPeripheralClockSignal($instance.getPeripheral(),$parent.clockSourceUId.getValue())"
                     description_expr="(getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()).regexMatch(`.*-.*`)?(getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()).regexSubstr(`(.*)-`,1) + `is inactive.`): (getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()) + `is inactive.`))"
                     level="Warning">
                     <feature name="frequency" evaluation="greaterThan">
                        <data expr="0" unit="Hz" type="Frequency"/>
                     </feature>
                  </dependency>
                  <dependency when_expr="(getPeripheralClockType($instance.getPeripheral(),$parent.clockSourceUId.getValue()) == `INPUT_SIGNAL`) &amp;&amp; ($parent.clockSourceFreq.getEnumItemId() != `GetFreq`) &amp;&amp; ($parent.clockSourceFreq.getEnumItemId() != `custom`)" resource_type="ClockOutput" resource_id_expr="getPeripheralClockSignal($instance.getPeripheral(),$parent.clockSourceUId.getValue())"
                     description_expr="(getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()).regexMatch(`.*-.*`)?(getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()).regexSubstr(`(.*)-`,1) + `is inactive.`): (getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()) + `is inactive.`))"
                     level="Error">
                     <feature name="frequency" evaluation="greaterThan">
                        <data expr="0" unit="Hz" type="Frequency"/>
                     </feature>
                  </dependency>
               </validation>
            </dynamic_enum>
            <dynamic_enum id="clockSourceFreq" label="Clock source frequency" options="remove_from_struct_init" available="(!($parent.clockSource.getEnumItemValue() == `ExternalClock`))" 
               items="createArray().addItemToList(`GetFreq`,`Runtime calculation by CLOCK_GetFreq()`,`GetFreq`,($parent.clockSource.getValue() == `kFTM_SystemClock`) || (getPeripheralClockSignal($instance.getPeripheral(), `FixedClock`) == `MCGFFCLK`) || (getPeripheralClockSignal($instance.getPeripheral(), `FixedClock`) == `FTMFFCLK`) || (getPeripheralClockSignal($instance.getPeripheral(), `FixedClock`) == `SOSCER_CLK`) || (getPeripheralClockSignal($instance.getPeripheral(), `FixedClock`) == `ICSFF_clock`) || (getPeripheralClockSignal($instance.getPeripheral(), `FixedClock`).regexMatch(`PCC.PCC_FTM(\d?)_CLK`))).merge(getClockFunctionalGroups().arrayToEnumItems(
                  enumItem -> true,
                  enumItem -> enumItem,
                  enumItem -> frequencyToString(getPeripheralClockFrequency($instance.getPeripheral(), $parent.clockSource.getEnumItemValue(), enumItem)) + ` (` + enumItem + `)`,
                  enumItem -> getPeripheralClockFrequency($instance.getPeripheral(), $parent.clockSource.getEnumItemValue(), enumItem)))" >
               <description>Selection of the clock source frequency</description>
               <validation>
                  <constraint cond_expr="($this.getEnumItemValue() == `GetFreq`) || (($this.getEnumItemValue().isFreq()) &amp;&amp; ($this.getEnumItemValue().toHertz() != 0))" level="error" description="Clock source frequency cannot be 0 when it is used."/>
                  <constraint when_expr="$this.getEnumItemValue() == `GetFreq`" cond_expr="$parent.frequencyValue.getValue() != `N/A`" level="error" description="The runtime calculation by CLOCK_GetFreq() is not supported for the selected value of the Clock source on this MCU."/>
               </validation>
               <custom_value_support default="0" validation_expr="x -> x.toHertz() >= 0" />
            </dynamic_enum> 
            <variable id="frequencyValue" value="($parent.clockSourceFreq.getEnumItemId() == `GetFreq`) ? 
               (($parent.clockSource.getEnumItemId() == `kFTM_SystemClock`) ?
                  ((getPeripheralClockSignal($instance.getPeripheral(), `BusInterfaceClock`) == `System_clock`) 
                  ? `CLOCK_GetFreq(kCLOCK_CoreSysClk)` 
                  : (getPeripheralClockSignal($instance.getPeripheral(), `BusInterfaceClock`) == `Timer_clock`)
                  ? `CLOCK_GetFreq(kCLOCK_TimerClk)` 
                  : (getPeripheralClockSignal($instance.getPeripheral(), `BusInterfaceClock`) == `Bus_clock`) 
                  ? `CLOCK_GetFreq(kCLOCK_BusClk)`
                  : `N/A`)
               : ((getPeripheralClockSignal($instance.getPeripheral(), `FixedClock`) == `MCGFFCLK`) || (getPeripheralClockSignal($instance.getPeripheral(), `FixedClock`) == `FTMFFCLK`) 
                  ? `CLOCK_GetFreq(kCLOCK_McgFixedFreqClk)`
                  : (getPeripheralClockSignal($instance.getPeripheral(), `FixedClock`) == `SOSCER_CLK`) 
                  ? `CLOCK_GetFreq(kCLOCK_ErClk)`
                  : (getPeripheralClockSignal($instance.getPeripheral(), `FixedClock`) == `ICSFF_clock`)
                  ? `CLOCK_GetFreq(kCLOCK_ICSFixedFreqClk)`
                  : (getPeripheralClockSignal($instance.getPeripheral(), `FixedClock`).regexMatch(`PCC.PCC_FTM(\d?)_CLK`))
                  ? `CLOCK_GetIpFreq(kCLOCK_Ftm` + getPeripheralClockSignal($instance.getPeripheral(), `FixedClock`).regexSubstr(`PCC.PCC_FTM(\d?)_CLK`,1) + `)`
                  : `N/A`)
               ) : ($parent.clockSourceFreq.getEnumItemValue().toHertz() + `UL`)"/>
            <string id="extClockFrequencyStr" label="External clock frequency" options="remove_from_struct_init" available="($parent.clockSource.getEnumItemValue() == `ExternalClock`)" 
               validation_expr="x -> system::validateValueFreq(x, 1, 0xFFFFFFFF)">
               <description>
Frequency of the external clock source of the FTM device (when the external clock source is selected in the FTM clock source settings).

An integer number (in range 1 - 0xFFFFFFFF) is processed as a value in hertz and a frequency value must be in format &quot;float_number [Hz, kHz, MHz or GHz]&quot;.
               </description>
               <validation>
                  <constraint cond_expr="$this.getValue().isFreq()" level="error" description="The external clock frequency must be a valid frequency value (integer number or frequency float_number [Hz, kHz, MHz or GHz])."/>
                  <constraint when_expr="$this.getValue().isFreq()" cond_expr="($this.getValue().toHertz() &gt;= 1) &amp;&amp; ($this.getValue().toHertz() &lt;= 0xFFFFFFFF)" level="error"
                     description="The external clock frequency is out of range 1 - 4294967295 (0xFFFFFFFF)."/>
               </validation>
            </string>
            <variable id="extClockFrequency" value="$parent.extClockFrequencyStr.getValue().isFreq() ? $parent.extClockFrequencyStr.getValue().toHertz() : 0" 
               available="($parent.clockSource.getEnumItemValue() == `ExternalClock`)"/>
            <!-- Timer input frequency -->
            <string id="timerPrescaler" label="Timer input frequency/prescaler" options="remove_from_struct_init" 
               validation_expr="x -> system::validateValueFreqPeriod(x,1,128)">
               <description>
Selection of the timer/counter input frequency in frequency units, time units or prescaler value that is used by the timer (it represents a timer tick). Supported formats of values:
* An integer number is processed as a prescaler value; range 1 - 128 (the only supported values are 1,2,4,8,16,32,64,128).
* A frequency value must be in format &quot;float_number [Hz, kHz, MHz or GHz]&quot;.
* A period value must be in format &quot;float_number [ns, us, ms, s, m, h or d]&quot;.

Frequency units and time units can only be used when clock source frequency is selected (clock must not be disabled or runtime calculated by the CLOCK_GetFreq()).
               </description>
               <validation>
                  <constraint when_expr="$parent.prescalerValue.getValue() != `N/A`" cond_expr="($parent.prescalerValue.getValue().toInt() &lt;= 0x100000000) &amp;&amp; ($parent.prescalerValue.getValue().toInt() &gt; 0)"  
                     level="error" description="The timer prescaler value must be in the range 1 - 4294967296 (0x100000000) because of the 32 bits width of the prescaler. Adjust the timer frequency/period and/or the timer input frequency."/>
               </validation>
            </string>
            <variable id="dividers" value="toArray(1, 2, 2**2, 2**3, 2**4, 2**5, 2**6, 2**7)"/>
            <variable id="prescalerValue" value="system::getRealDividerValue($parent.timerPrescaler.getValue(), $parent.clockSourceFreq.getEnumItemValue())" ></variable>
            <info id="calculatedPrescalerValue" label="Calculated prescaler" value="($parent.prescalerValue.getValue() != `N/A`) ? findBestDivider($parent.prescalerValue.getValue().toInt(), $parent.dividers.getValue()) : `N/A`">
               <description>Calculated value of the best prescaler for the selected value in the Timer input frequency/prescaler settings.</description>
            </info>
            <!-- The prescale register value = prescaler value - 1 -->
            <variable id="prescale" value="(($parent.prescalerValue.getValue() != `N/A`) &amp;&amp; ($parent.dividers.getValue().anyMatch(i -> i == $parent.calculatedPrescalerValue.getValue()))) ? ($configSet.enumItemsOfType(`ftm_clock_prescale_t`).get($parent.dividers.getValue().searchInArray(i -> i == $parent.calculatedPrescalerValue.getValue())).getValue()) : `N/A`" options="add_to_struct"></variable>
            <info id="calculatedInputFreqPeriod" label="Calculated timer input frequency" 
               value="system::calculateFreqPeriod($parent.calculatedPrescalerValue.getValue(), $parent.clockSourceFreq.getEnumItemValue())">
               <description>Calculated real timer input frequency and one tick period (in time units) based on the prescaler value setting.</description>
            </info>
            <!-- Value of the timer input frquency - one tick of timer frequency -->
            <variable id="timerInputFreq" value="system::calculateFreq($parent.calculatedPrescalerValue.getValue(), $parent.clockSourceFreq.getEnumItemValue())" ></variable>
            <!-- Timer output frequency  - it is not used in the quadrature decoder mode (external signals are used to count pulses) -->
            <!-- edge aligned mode range 1 - 65536 (0x10000); center aligned mode range 1*2 - 65534 (0x7FFF*2) -->
            <variable id="minTimerModuleValue" value="($instance.getMode() == `CenterAligned`) ? 2 : 1" ></variable>
            <variable id="maxTimerModuleValue" value="($instance.getMode() == `CenterAligned`) ? 65534 : 65536" ></variable>
            <!-- Timer output frequency  - it is not used in the quadrature decoder mode (external signals are used); the modulo value setting is available in the quadrature decoder config set. -->
            <string id="timerOutputFrequency" label="Timer output frequency" options="remove_from_struct_init" 
               validation_expr="x -> system::validateValueFreqPeriod(x,$parent.minTimerModuleValue.getValue(),$parent.maxTimerModuleValue.getValue())"
               available="$instance.getMode() != `QuadratureDecoder`">
               <description>
                  Selection of the timer/counter output frequency (overflow) in frequency units, time units or modulo value that is used by the timer (it represents a timer tick). This settings impact the modulo value of the FTM timer. The possible value depends on the selected input clock frequency, i.e. the modulo register value depend on the ration of the input clock frequency and the timer output frequency. 
Supported formats of values:
* An integer number is processed as a modulo value; range 1 - 65536 (0x10000) or 2 - 65534 (in the Center-aligned mode).
* A frequency value must be in format &quot;float_number [Hz, kHz, MHz or GHz]&quot;.
* A period value must be in format &quot;float_number [ns, us, ms, s, m, h or d]&quot;.

Frequency units and time units can only be used when clock source frequency is selected (clock must not be disabled or runtime calculated by the CLOCK_GetFreq()).

Note: If 1 tick modulo value is used (zero value of the MOD register) the timer is stopped in zero and it does not work.   
               </description>
               <validation>
                  <constraint when_expr="$parent.timerModuloValue.getValue() != `N/A`" cond_expr="($parent.timerModuloValue.getValue().toInt() &lt;= 0x10000) &amp;&amp; ($parent.timerModuloValue.getValue().toInt() &gt; 0)"  
                     level="error" description="The timer modulo value must be in the range 1 - 65536 (0x10000) because of the 16 bits width of the modulo. Adjust the timer frequency/period and/or the timer input frequency."/>
               </validation>
            </string>
            <!-- In the centered mode the even values from 1*2 to 0x7FFF*2 are allowed -->
            <variable id="timerModuloDividerValue" value="(system::getIntDividerValue($parent.timerOutputFrequency.getValue(), $parent.timerInputFreq.getValue()).isInt() &amp;&amp; ($instance.getMode() == `CenterAligned`)) 
               ? (system::getIntDividerValue($parent.timerOutputFrequency.getValue(), $parent.timerInputFreq.getValue()) &amp; 0xFFFE)
               : system::getIntDividerValue($parent.timerOutputFrequency.getValue(), $parent.timerInputFreq.getValue())" 
               available="$instance.getMode() != `QuadratureDecoder`" unavailable_value="`N/A`"/>
<!--            <info id="moduloCalculated" label="Calculated modulo value" value="($parent.timerModuloValue.getValue() != `N/A`) ? $parent.prescalerValue.getValue().toInt() : `N/A`" ></info>-->
            <variable id="timerModuloValue" value="($parent.timerModuloDividerValue.getValue().isInt() &amp;&amp; ($instance.getMode() == `CenterAligned`)) ? ($parent.timerModuloDividerValue.getValue() / 2) : $parent.timerModuloDividerValue.getValue()"
               available="$instance.getMode() != `QuadratureDecoder`" unavailable_value="`N/A`"/>
            <variable id="timerModuloRegisterValue" value="($parent.timerModuloValue.getValue() != `N/A`) ? ($parent.timerModuloValue.getValue().toInt()-1) : `N/A`"
               available="$instance.getMode() != `QuadratureDecoder`" unavailable_value="`N/A`"/>
            <!-- timer output frequency value that is valid even if the runtime calculatuion by GetFreq() is selected and the output frequency is specified by time or frequency units -->
            <variable id="timerFreqValue" value="system::calculateIntFreq($parent.timerModuloDividerValue.getValue(), $parent.timerInputFreq.getValue()).isInt() ? 
               system::calculateIntFreq($parent.timerModuloDividerValue.getValue(), $parent.timerInputFreq.getValue()) 
               : (($parent.timerOutputFrequency.getValue().isFreq() || $parent.timerOutputFrequency.getValue().isTime()) ? $parent.timerOutputFrequency.getValue().getFreq(`Hz`, `Hz`) : 0)"
               available="$instance.getMode() != `QuadratureDecoder`" unavailable_value="`N/A`"/>
            <info id="calculatedFreqPeriod" label="Calculated timer output frequency" 
               value="system::calculateFreqPeriod($parent.timerModuloDividerValue.getValue(), $parent.timerInputFreq.getValue())"
               available="$instance.getMode() != `QuadratureDecoder`" unavailable_value="`N/A`">
               <description>Calculated real timer output frequency for the selected modulo value/frequency/time. Calculation is based on the supported modulo values (1 - 65536).</description>
            </info>
            <info id="calculatedModulo" label="Timer modulo value/resolution" 
               value="$parent.timerModuloValue.getValue() + ` ticks`"
               available="$instance.getMode() != `QuadratureDecoder`" unavailable_value="`N/A`">
               <description>Calculated maximum value of the timer (the modulo value) in ticks that specify the resolution of the timer that is used as maximum value of the channels' Capture/Match register value.</description>
            </info>
            <!-- Value of the timer output frquency - timer overflow frequency that is defined by the modulo value -->
            <variable id="timerOutputFreq" value="system::calculateFreq($parent.timerModuloValue.getValue(), $parent.timerInputFreq.getValue())"
               available="$instance.getMode() != `QuadratureDecoder`" unavailable_value="`N/A`"/>
            <!-- System/filter clock source -->
            <info id="systemClockSourceLine" value="`System and filter clock`"  options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init">
               <description>System clock that is used for input filters and deadtime insertion.</description>
            </info>
            <variable id="systemClockSourceUId" value="`BusInterfaceClock`"/> <!-- The Bus Interface clock is internally called as System clock of the FTM IP block -->
            <dynamic_enum id="systemClockSource" label="System clock source" options="remove_from_struct_init" items="createArray().addItemToList($parent.systemClockSourceUId.getValue(), getPeripheralClock($instance.getPeripheral(), $parent.systemClockSourceUId.getValue()), ($instance.getPeripheral() + `_CLK_SRC`),true)" >
               <description>FTM system clock source that is used for fault input filters, channel input filter and deadtime insertion.</description>
               <validation>
                  <dependency when_expr="($parent.clockSourceFreq.getEnumItemId() == `GetFreq`)" resource_type="ClockOutput" resource_id_expr="getPeripheralClockSignal($instance.getPeripheral(),$parent.clockSourceUId.getValue())"
                     description_expr="(getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()).regexMatch(`.*-.*`)?(getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()).regexSubstr(`(.*)-`,1) + `is inactive.`): (getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()) + `is inactive.`))"
                     level="Warning">
                     <feature name="frequency" evaluation="greaterThan">
                        <data expr="0" unit="Hz" type="Frequency"/>
                     </feature>
                  </dependency>
                  <dependency when_expr="($parent.clockSourceFreq.getEnumItemId() != `GetFreq`) &amp;&amp; ($parent.clockSourceFreq.getEnumItemId() != `custom`)" resource_type="ClockOutput" resource_id_expr="getPeripheralClockSignal($instance.getPeripheral(),$parent.clockSourceUId.getValue())"
                     description_expr="(getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()).regexMatch(`.*-.*`)?(getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()).regexSubstr(`(.*)-`,1) + `is inactive.`): (getPeripheralClock($instance.getPeripheral(), $parent.clockSourceUId.getValue()) + `is inactive.`))"
                     level="Error">
                     <feature name="frequency" evaluation="greaterThan">
                        <data expr="0" unit="Hz" type="Frequency"/>
                     </feature>
                  </dependency>
               </validation>
            </dynamic_enum>
            <dynamic_enum id="systemClockSourceFreq" label="System clock source frequency" options="remove_from_struct_init" 
               items="($parent.clockSource.getEnumItemId() == `kFTM_SystemClock`)?
               createArray().addItemToList(`mirrored_value`, $parent.clockSourceFreq.getEnumItemLabel(), $parent.clockSourceFreq.getEnumItemValue(), true, `The filter clock frequency is selected in the Clock source frequency setting because the same clock source is used for the timer and filter clock`)
               : createArray().merge(
               getClockFunctionalGroups()
               .arrayToEnumItems(
                  enumItem -> true,
                  enumItem -> enumItem,
                  enumItem -> frequencyToString(getPeripheralClockFrequency($instance.getPeripheral(), $parent.systemClockSource.getEnumItemId(), enumItem)) + ` (` + enumItem + `)`,
                  enumItem -> getPeripheralClockFrequency($instance.getPeripheral(), $parent.systemClockSource.getEnumItemId(), enumItem)))
                  .addItemToList(`GetFreq`,`Runtime calculation by CLOCK_GetFreq()`,`GetFreq`, true)" >
               <description>Selection of the clock source frequency that is used for filter inputs. If the frequency is not specified the filter values can be specified by a register value only.</description>
               <validation>
                  <constraint when_expr="$this.getEnumItemValue().isFreq()" cond_expr="$this.getEnumItemValue().toHertz() != 0" level="error" description="Clock source frequency cannot be 0 when it is used."/>
                  <constraint when_expr="$parent.clockSource.getEnumItemId() == `kFTM_SystemClock`" cond_expr="$this.getEnumItemId() != `custom`" level="error" 
                     description="When the bus clock is selected in the Clock source setting the same value of the bus clock must be used for the filter clock (a custom value cannot be used)."/>
               </validation>
               <custom_value_support default="0" validation_expr="x -> x.toHertz() >= 0"/>
            </dynamic_enum>
            <!-- System clock value -->
            <variable id="systemClockFreqValue" value="system::calculateFreq(1, $parent.systemClockSourceFreq.getEnumItemValue().isFreq() ? $parent.systemClockSourceFreq.getEnumItemValue() : `N/A`)" ></variable>
            <!-- Filter clock is pre-divided by a fixed divider (divided by four) -->
            <info id="filterClockFreq" label="Filter clock frequency/period" value="system::calculateFreqPeriod(4, $parent.systemClockSourceFreq.getEnumItemValue().isFreq() ? $parent.systemClockSourceFreq.getEnumItemValue() : `N/A`)" >
               <description>Filter clock source frequency that is pre-divide by 4. It is used internally by all input filters.</description>
            </info>
            <variable id="filterClockFreqValue" value="system::calculateFreq(4, $parent.systemClockSourceFreq.getEnumItemValue().isFreq() ? $parent.systemClockSourceFreq.getEnumItemValue() : `N/A`)" ></variable>
            <!-- Other common setting of the FTM -->
            <!-- Fault filter and inputs -->
            <info id="faultConfigurationLine" value="`Fault inputs`"  options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init">
               <description>Configuration of the fault filter and inputs.</description>
            </info>
            <reference id="faultMode" label="Fault control mode" type="ftm_fault_mode_t" config_set_id="fsl_ftm">
               <description>FTM fault control mode</description>
            </reference>
            <string id="inputFilterPeriod" label="Fault input filter period" options="remove_from_struct_init" 
               validation_expr="x -> system::validateValueFreqPeriod(x, 1, 16)">
               <description>
The fault input filter sampling period value in number of filter clock cycles (range 1-16), frequency units or time units. This period is used for sampling of the timer input signal. When the value 1 is selected the filter is bypassed.

An integer number in range 1 - 16 (0x10) is processed as a value in ticks of filter clock period, a frequency value must be in format &quot;float_number [Hz, kHz, MHz or GHz]&quot;, a period value must be in format &quot;float_number [ns, us, ms, s, m, h or d]&quot;.
Frequency units and time units can only be used when clock source frequency is selected (clock must not be disabled/calculated in runtime).

When the the minimum value 1 is selected (zero value of the register bitfield) the filter is disabled and the minimum pulse width (filter sampling period) is one filter clock period.
               </description>
               <validation>
                  <constraint when_expr="$parent.faultFilter.getValue() != `N/A`" cond_expr="($parent.faultFilter.getValue().toInt() &lt;= 16) &amp;&amp; ($parent.faultFilter.getValue().toInt() &gt; 0)"  level="error" description="The filter sampling period in ticks must be in the range 1 - 16 (0x10)."/>
                  <constraint cond_expr="$parent.faultFilter.getValue() != `N/A`"   level="error" description="A valid value of filter sampling period must be specified. When the filter frequency is not specified the filter sampling period must be specified as an integer number 1 - 16."/>
               </validation>
            </string>
            <variable id="faultFilter" value="system::getIntDividerValue($parent.inputFilterPeriod.getValue(), $parent.filterClockFreqValue.getValue())"/>
            <!-- Fault filter value that is used as paramter (value of the register bitfield) -->
            <variable id="faultFilterValue" value="$parent.faultFilter.getValue().isInt() ? ($parent.faultFilter.getValue().toInt() - 1) : 0 " options="add_to_struct"/>
            <info id="inputFilterPeriod_info" label="Calculated fault filter period" 
               value=" system::calculateTicksFreqPeriod($parent.faultFilter.getValue(), $parent.filterClockFreqValue.getValue())">
               <description>The calculated fault input filter sampling period in number of ticks of the filter clock cycles, sampling frequency and time period.</description>
            </info>
            <array id="faultInputs" label="Fault inputs" type="ftm_fault_param_t" size="4" options="ShowContentAs=Table;UI_ARRAY_INDICES_HIDDEN;UI_TABLE_COLUMN_WIDTHS=6,5,8,8;UI_BORDER_HIDDEN;remove_from_struct_init">
               <description>Configuration of FTM fault inputs.</description>
            </array>
            <!-- Deadtime configuration  -->
            <info id="deadtimeConfigurationLine" value="`Deadtime`"  options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init">
               <description>Configuration of the fault filter and inputs.</description>
            </info>
            <reference id="deadTimePrescale" label="Deadtime prescaler value" type="ftm_deadtime_prescale_t">
               <description>The dead time prescalar value</description>
            </reference>
            <info id="deadtimeFreq_info" label="Deadtime clock frequency/period" 
               value=" system::calculateFreqPeriod($parent.deadTimePrescale.getEnumItemValue().toInt(), $parent.systemClockFreqValue.getValue())">
               <description>The calculated deadtime frequency/period (the system clock that is divided by the deadtime prescaler).</description>
            </info>
            <variable id="deadtimeFreq" value="system::calculateFreq($parent.deadTimePrescale.getEnumItemValue().toInt(), $parent.systemClockFreqValue.getValue())"/>
            <variable id="deadTimeMaxValue" value="(featureDefined(`FSL_FEATURE_FTM_HAS_EXTENDED_DEADTIME_VALUE`) &amp;&amp; getFeature(`FSL_FEATURE_FTM_HAS_EXTENDED_DEADTIME_VALUE`)) ? 1023 : 63" ></variable>
            <string id="deadTimePeriod" label="Deadtime value/period" options="remove_from_struct_init" 
               validation_expr="x -> system::validateValueFreqPeriod(x, 0, $parent.deadTimeMaxValue.getValue())">
               <description expr="`The deadtime value/period in number of deadtime clock cycles (range 0 - ` + $parent.deadTimeMaxValue.getValue() + `; MCU specific value), frequency units or time units. This period is used for specification of the deadtime. When the value 0 is selected the deadtime insertion is disabled.&#xA;
An integer number in range 1 - 1023 (0x3FF) (or 1 - 63 - MCU specific feature) is processed as a value in ticks of the deadtime clock period, a frequency value must be in format &quot;float_number [Hz, kHz, MHz or GHz]&quot;, a period value must be in format &quot;float_number [ns, us, ms, s, m, h or d]&quot;.
Frequency units and time units can only be used when clock source frequency is selected (clock must not be disabled/calculated in runtime).&#xA;
When the the zero value is selected the deadtime insertion is disabled.`"/>
               <validation>
                  <constraint when_expr="$parent.deadTimeValue.getValue() != `N/A`" cond_expr="($parent.deadTimeValue.getValue().toInt() &lt;= $parent.deadTimeMaxValue.getValue()) &amp;&amp; ($parent.deadTimeValue.getValue().toInt() &gt;= 0)"  level="error" description_expr="`The deadtime period in ticks must be in the range 0 - ` + $parent.deadTimeMaxValue.getValue() + `.`"/>
                  <constraint cond_expr="$parent.deadTimeValue.getValue() != `N/A`"   level="error" description="A valid value of deadtime period must be specified. When the system clock frequency is not specified the deadtime period must be specified as an integer number."/>
               </validation>
            </string>
            <variable id="deadTimeValue" value="system::getIntDividerValue($parent.deadTimePeriod.getValue(), $parent.deadtimeFreq.getValue())" options="add_to_struct"/>
            <info id="deadTimeValue_info" label="Calculated deadtime period" 
               value=" system::calculateTicksFreqPeriod($parent.deadTimeValue.getValue(), $parent.deadtimeFreq.getValue())">
               <description>The calculated deadtime period in number of ticks of the prescaled deadtime clock, frequency and time period.</description>
            </info>
            <info id="otherCommonSettingsLine" value="``"  options="UI_LINE_BREAK;UI_LABEL_HIDDEN;remove_from_struct_init"></info>
            <reference id="pwmSyncMode" label="Synchronization of buffered registers" type="ftm_pwm_sync_method_t" options="UI_REFRESH">
               <description>Synchronization methods to use to update buffered registers; Multiple update modes can be used by providing an OR&apos;ed list of options available in enumeration ftm_pwm_sync_method_t.</description>
               <validation>
                  <!-- $this.anyMatch(x -> x.getValue()) - check whether any setting is enabled; the function call $this.getCValue() cannot be used in constraint expressions and variables. -->
                  <constraint cond_expr="$this.anyMatch(x -> x.getValue())" description="At least one synchronization method to update buffered registers must be selected." level="error"/>
                  <dependency when_expr="$parent.pwmSyncMode.kFTM_HardwareTrigger_0.getValue()" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_trigger.0`" description_expr="`FTM Hardware Trigger 0 signal is not routed`" level="Warning">
                     <feature name="routed" evaluation="equal">
                        <data expr="true"/>
                     </feature>
                  </dependency>
                  <dependency when_expr="$parent.pwmSyncMode.kFTM_HardwareTrigger_1.getValue()" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_trigger.1`" description_expr="`FTM Hardware Trigger 1 signal is not routed`" level="Warning">
                     <feature name="routed" evaluation="equal">
                        <data expr="true"/>
                     </feature>
                  </dependency>
                  <dependency when_expr="$parent.pwmSyncMode.kFTM_HardwareTrigger_2.getValue()" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_trigger.2`" description_expr="`FTM Hardware Trigger 2 signal is not routed`" level="Warning">
                     <feature name="routed" evaluation="equal">
                        <data expr="true"/>
                     </feature>
                  </dependency>
               </validation>
            </reference>
            <reference id="reloadPoints" label="Reload points" type="ftm_reload_point_t">
               <description>FTM reload points; When using this, the PWM synchronization is not required. Multiple reload points can be used.</description>
               <validation>
                  <constraint when_expr="$instance.getMode() == `EdgeAligned`" 
                     cond_expr="$this.countOccurrences(rp -> (rp.isAvailable()) &amp;&amp; (rp.getValue()) &amp;&amp; (rp.getID().regexMatch(`.*_Chnl(\d+).*`)) &amp;&amp; ($instance.ftm_edge_aligned_mode.ChanOddMatchInit.getValue().countOccurrences(item -> (item ==  rp.getID().regexSubstr(`.*_Chnl(\d+)`,1))) == 0) &amp;&amp; ($instance.ftm_edge_aligned_mode.ChanEvenMatchInit.getValue().countOccurrences(item -> (item == rp.getID().regexSubstr(`.*_Chnl(\d+)`,1))) == 0)) == 0" 
                     level="info" 
                     description_expr="`Reload points for channel(s) ` + 
                     $this.filter(rp -> (rp.isAvailable()) &amp;&amp; ((rp.getValue()) &amp;&amp; (rp.getID().regexMatch(`.*_Chnl(\d+).*`)) &amp;&amp; ($instance.ftm_edge_aligned_mode.ChanOddMatchInit.getValue().countOccurrences(item -> (item ==  rp.getID().regexSubstr(`.*_Chnl(\d+)`,1))) == 0) &amp;&amp; ($instance.ftm_edge_aligned_mode.ChanEvenMatchInit.getValue().countOccurrences(item -> (item == rp.getID().regexSubstr(`.*_Chnl(\d+)`,1))) == 0))).map(setItem -> setItem.getID().regexSubstr(`.*_Chnl(\d+)`,1)).join(`, `)
                     + ` are enabled but these channels are not initialized (in output compare or a PWM mode).`"/>
                  <constraint when_expr="$instance.getMode() == `CenterAligned`" 
                     cond_expr="$this.countOccurrences(rp -> (rp.isAvailable()) &amp;&amp; (rp.getValue()) &amp;&amp; (rp.getID().regexMatch(`.*_Chnl(\d+).*`)) &amp;&amp; ($instance.ftm_center_aligned_mode.ChanMatchInit.getValue().countOccurrences(item -> (item ==  rp.getID().regexSubstr(`.*_Chnl(\d+)`,1))) == 0)) == 0" 
                     level="info" 
                     description_expr="`Reload points for channel(s) ` + 
                     $this.filter(rp -> (rp.isAvailable()) &amp;&amp; ((rp.getValue()) &amp;&amp; (rp.getID().regexMatch(`.*_Chnl(\d+).*`)) &amp;&amp; ($instance.ftm_center_aligned_mode.ChanMatchInit.getValue().countOccurrences(item -> (item ==  rp.getID().regexSubstr(`.*_Chnl(\d+)`,1))) == 0))).map(setItem -> setItem.getID().regexSubstr(`.*_Chnl(\d+)`,1)).join(`, `)
                     + ` are enabled but these channels are not initialized (in output compare or a PWM mode).`"/>
               </validation>
            </reference>
            <reference type="ftm_external_trigger_t" id="extTriggers" label="Generation of external triggers">
               <description>Configuration of external triggers generation. Multiple trigger sources can be enabled by selection in this settings.</description>
               <validation>
                  <constraint when_expr="$instance.getMode() == `EdgeAligned`" 
                     cond_expr="$this.countOccurrences(rp -> (rp.isAvailable()) &amp;&amp; (rp.getValue()) &amp;&amp; (rp.getID().regexMatch(`.*_Chnl(\d+).*`)) &amp;&amp; ($instance.ftm_edge_aligned_mode.ChanOddMatchInit.getValue().countOccurrences(item -> (item ==  rp.getID().regexSubstr(`.*_Chnl(\d+)`,1))) == 0) &amp;&amp; ($instance.ftm_edge_aligned_mode.ChanEvenMatchInit.getValue().countOccurrences(item -> (item == rp.getID().regexSubstr(`.*_Chnl(\d+)`,1))) == 0)) == 0" 
                     level="info" 
                     description_expr="`External triggers for channel(s) ` + 
                     $this.filter(rp -> (rp.isAvailable()) &amp;&amp; (rp.getValue()) &amp;&amp; (rp.getID().regexMatch(`.*_Chnl(\d+).*`)) &amp;&amp; ($instance.ftm_edge_aligned_mode.ChanOddMatchInit.getValue().countOccurrences(item -> (item ==  rp.getID().regexSubstr(`.*_Chnl(\d+)`,1))) == 0) &amp;&amp; ($instance.ftm_edge_aligned_mode.ChanEvenMatchInit.getValue().countOccurrences(item -> (item == rp.getID().regexSubstr(`.*_Chnl(\d+)`,1))) == 0)).map(setItem -> setItem.getID().regexSubstr(`.*_Chnl(\d+)`,1)).join(`, `)
                     + ` are enabled but these channels are not initialized (in output compare or a PWM mode).`"/>
                  <constraint when_expr="$instance.getMode() == `CenterAligned`" 
                     cond_expr="$this.countOccurrences(rp -> (rp.isAvailable()) &amp;&amp; (rp.getValue()) &amp;&amp; (rp.getID().regexMatch(`.*_Chnl(\d+).*`)) &amp;&amp; ($instance.ftm_center_aligned_mode.ChanMatchInit.getValue().countOccurrences(item -> (item ==  rp.getID().regexSubstr(`.*_Chnl(\d+)`,1))) == 0)) == 0" 
                     level="info" 
                     description_expr="`External triggers for channel(s) ` + 
                     $this.filter(rp -> (rp.isAvailable()) &amp;&amp; (rp.getValue()) &amp;&amp; (rp.getID().regexMatch(`.*_Chnl(\d+).*`)) &amp;&amp; ($instance.ftm_center_aligned_mode.ChanMatchInit.getValue().countOccurrences(item -> (item ==  rp.getID().regexSubstr(`.*_Chnl(\d+)`,1))) == 0)).map(setItem -> setItem.getID().regexSubstr(`.*_Chnl(\d+)`,1)).join(`, `)
                     + ` are enabled but these channels are not initialized (in output compare or a PWM mode).`"/>
               </validation>
            </reference>
            <reference id="chnlInitState" label="Initialization output value of the channels" type="ftm_init_output_value_t" options="use_set_values">
               <description>Defines the initialization value of the channels in OUTINT register</description>
            </reference>
            <reference id="chnlPolarity" label="Output polarity of the channels" type="ftm_output_polarity_t" options="use_set_values">
               <description>Defines the output polarity of the channels in POL register. When the active low polarity is set the active level of output is low (negative polarity is selected). Otherwise the active high polarity is set (the default polarity).</description>
            </reference>
            <reference id="bdmMode" label="Behavior in BDM mode" type="ftm_bdm_mode_t" config_set_id="fsl_ftm">
               <description>
FTM behavior in BDM mode. There are supported the following BDM modes:
* Mode 0 - FTM counter stopped, CH(n)F bit can be set, FTM channels in functional mode, writes to MOD,CNTIN and C(n)V registers bypass the register buffers.
* Mode 1 - FTM counter stopped, CH(n)F bit is not set, FTM channels outputs are forced to their safe value according to POLn bit, writes to MOD,CNTIN and C(n)V registers bypass the register buffers.
* Mode 2 - FTM counter stopped, CH(n)F bit is not set, FTM channels outputs are frozen when chip enters in BDM mode, writes to MOD,CNTIN and C(n)V registers bypass the register buffers.
* Mode 3 - FTM counter in functional mode, CH(n)F bit can be set, FTM channels in functional mode, writes to MOD,CNTIN and C(n)V registers is in fully functional mode.
               </description>
            </reference>
            <bool id="useGlobalTimeBase" label="External global time base">
               <description>Enable usage of an external global time base signal that is generated by another FTM.</description>
            </bool>
         </struct>
         <enum  id="clkSrc_t" label="clkSrc" from="internal">
            <item id="BusInterfaceClock" label="Bus Interface Clock" value="BUS_CLOCK"/>
            <item id="FixedClock" label="Fixed Clock" value="MCGFFCLK"/>
         </enum>
      </user_types>
      <settings>
         <reference id="ftm_config" label="Timer Configuration" type="ftm_config_t">
            <description>FlexTimer configuration</description>
         </reference>
         <reference type="ftm_interrupt_enable_t" id="timer_interrupts" label="Timer interrupts">
            <validation>
               <constraint when_expr="featureDefined(`FSL_FEATURE_FTM_HAS_RELOAD_INTERRUPT`) &amp;&amp; getFeature(`FSL_FEATURE_FTM_HAS_RELOAD_INTERRUPT`) &amp;&amp; ($this.kFTM_ReloadInterruptEnable.getValue())" cond_expr="$configSet.ftm_config.reloadPoints.getCValue() != ``" level="warning" description="The reload point interrupt is enabled but there is not enabled any reload point. See the Reload points setting of the Timer Configuration."/>
            </validation>
         </reference>
         <!-- Interrupt request from the system component -->
         <bool id="enable_irq" label="Enable interrupt request" options="UI_LABEL_BOLD">
            <description>Enable interrupt request in the NVIC (Nested Interrupt Vector Controller) of the CPU.</description>
         </bool>
         <reference id="ftm_interrupt" label="Interrupt" type="interrupt_vector_t" config_set_id="fsl_interrupt_peripheral" component_id="system" enable="$parent.enable_irq.getValue()" options="UI_LABEL_HIDDEN">
            <options_expr>
               <option id="irq_handler_insert" expr="
leftPadding(`uint32_t intStatus;`, 1) + `&#10;` +
leftPadding(`/* Reading all interrupt flags of status register */`, 1) + `&#10;` +
leftPadding(`intStatus = FTM_GetStatusFlags(` + $configSet.inst_peripheral_ID.getValue() + `);`, 1) + `&#10;` +
leftPadding(`FTM_ClearStatusFlags(` + $configSet.inst_peripheral_ID.getValue() + `, intStatus);`, 1) + `&#10;&#10;` +
leftPadding(`/* Place your code here */`, 1) + `&#10;`
               "/>
            </options_expr>
         </reference>
         <bool id="EnableTimerInInit" label="Start timer in initialization code">
            <description>When the start of the timer is enabled in the initialization code the FTM_StartTimer() function is called and the FTM device timer start counting.</description>
         </bool> 
         <info value="getFeature(`FTM_CHANNEL_COUNT`)" id="FTM_channel_count" label="Number of channels" available="featureDefined(`FTM_CHANNEL_COUNT`)">
            <description>Number of channels of this FTM device (MCU specific information).</description>
         </info>
         <variable id="inst_ID" value="$instance.getFnGroupPrefix() + $instance.getID()"></variable>
         <variable id="inst_ID_def" value="toUpperCase($parent.inst_ID.getValue())"></variable>
         <variable id="inst_peripheral_ID" value="$parent.inst_ID_def.getValue() + `_PERIPHERAL`"></variable>
         <variable id="timerModuloDefId" value="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_TIMER_MODULO_VALUE`)" ></variable>
      </settings>
      <validation>
         <constraint cond_expr="!(featureDefined(`FTM_IS_TPM_ONLY_INSTANCE`) &amp;&amp; getFeature(`FTM_IS_TPM_ONLY_INSTANCE`))" level="error" description="This instance of the FTM peripheral is not supported by FTM component. Use the TPM component."/>
      </validation>
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="common_code_templates"/>
            <from component_id="system" config_set_id="fsl_interrupt_peripheral"/>
         </import>
         <def fragment="ftm_start_init"> <!-- it is an array of structures -->
            <expr>
               leftPadding(`FTM_StartTimer(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`) + `, ` + 
               + $param.clock_source + `);`, 1) 
            </expr><br/>
         </def>
         <def fragment="ftm_fault_init">
            <expr>
               leftPadding(`FTM_SetupFault(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`) + `, ` + $param.fault_input + `, ` + $param.fault_config + `);`, 1) 
            </expr><br/>
         </def>
      </fragment_defs>
      <code>
         <section target="includes">
            <fragment id="include">
               <param id="name">common</param>
               <param id="filename">fsl_common.h</param>
            </fragment>
            <fragment id="include">
               <param id="name">uart</param>
               <param id="filename">fsl_clock.h</param>
            </fragment>
            <fragment id="include">
               <param id="name">uart</param>
               <param id="filename">fsl_ftm.h</param>
            </fragment>
         </section>
         <section target="defines">
            <!-- Peripheral name definition --> 
            <fragment id="define">
               <param id="name" expr="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`)"/>
               <param id="value" expr="$instance.getPeripheral()"/> <!-- The getValue() function must be used to provide the symbol name (getCValue() return a string) -->
               <param id="description">Definition of peripheral ID</param>
            </fragment>
            <!-- Clock source frequency size -->
            <fragment id="define" if_expr="($this.ftm_config.clockSource.getEnumItemId() == `kFTM_SystemClock`) || ($this.ftm_config.clockSource.getEnumItemId() == `kFTM_FixedClock`)">
               <param id="name" expr="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_CLOCK_SOURCE`)"/>
               <param id="value" expr="$this.ftm_config.frequencyValue.getValue()"/> 
               <param id="description">Definition of the clock source frequency</param>
            </fragment>
            <fragment id="define" if_expr="($this.ftm_config.clockSource.getEnumItemId() == `kFTM_ExternalClock`)">
               <param id="name" expr="toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_CLOCK_SOURCE`)"/>
               <param id="value" expr="$this.ftm_config.extClockFrequency.getValue().toHertz() + `UL`"/> 
               <param id="description">Definition of the clock source frequency</param>
            </fragment>
            <fragment id="define" if_expr="$instance.ftm_main_config.ftm_config.timerModuloRegisterValue.isAvailable()">
               <param id="name" expr="$configSet.timerModuloDefId.getValue()"/>
               <param id="value" expr="$instance.ftm_main_config.ftm_config.timerModuloRegisterValue.getValue().isInt() 
                  ? $instance.ftm_main_config.ftm_config.timerModuloRegisterValue.getValue()
                  : ($instance.getMode() != `CenterAligned`)
                  ? `(((` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_CLOCK_SOURCE`) + `/ (1U &lt;&lt; (` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`)+`-&gt;SC &amp; FTM_SC_PS_MASK)))` + ` / ` + $instance.ftm_main_config.ftm_config.timerFreqValue.getValue().toHertz() + `) - 1)`
                  : `((` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_CLOCK_SOURCE`) + `/ (1U &lt;&lt; (` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`)+`-&gt;SC &amp; FTM_SC_PS_MASK)))` + ` / (` + $instance.ftm_main_config.ftm_config.timerFreqValue.getValue().toHertz() + ` * 2))`"/> 
               <param id="description">Definition of the clock source frequency</param>
            </fragment>            
            <fragment id="IRQ_definitions" apply_to="$this.ftm_interrupt" if_expr="$this.enable_irq.getValue()"/>
         </section> 
         <section target="global_vars">
            <fragment id="const_struct" apply_to="$this.ftm_config">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_config`"></param>
               <param id="type" >ftm_config_t</param>
            </fragment>
            <fragment id="const_struct" for_elements_of="$this.ftm_config.faultInputs.filter(i -> i.getSetting(`enableFaultInput`).getValue())">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_fault_` + $this.getID() + `_config`"></param>
               <param id="type" >ftm_fault_param_t</param>
            </fragment>
         </section>
         <section target="global_vars_extern">
            <fragment id="extern_const_var">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_config`"></param>
               <param id="type" >ftm_config_t</param>
            </fragment>
         </section>
         <section target="init_function_body">
            <expr>leftPadding(`FTM_Init(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`) + `, &amp;` +  $instance.getFnGroupPrefix() + $instance.getID() + `_config);`, 1)</expr><br/>
            <fragment id="ftm_fault_init" for_elements_of="$this.ftm_config.faultInputs.filter(i -> i.getSetting(`enableFaultInput`).getValue())">
               <param id="fault_config" expr="`&amp;` + $instance.getFnGroupPrefix() + $instance.getID() + `_fault_` + $this.getID() + `_config`"></param>
               <param id="fault_input" expr="$configSet.enumItemsOfType(`ftm_fault_input_t`).findFirst(i -> i.getValue() ==  $this.getId()).getId()"/>
            </fragment>
         </section>
         <!-- POST INIT section (after initialization of channels -->
         <section target="init_function_postinit0">
            <!-- FTM device interrupt initialization -->
            <fragment id="IRQn_set_priority_default" if_expr="$this.enable_irq.getValue()" apply_to="$this.ftm_interrupt"/>
            <fragment id="IRQn_enable_default" if_expr="$this.enable_irq.getValue()" apply_to="$this.ftm_interrupt"/>
            <fragment id="ftm_start_init" if_expr="$this.EnableTimerInInit.getValue()">
               <param id="clock_source" expr="$instance.ftm_main_config.ftm_config.clockSource.getEnumItemId()"></param>
            </fragment>
         </section>
      </code>
      <quick_selections>
         <quick_selection id="QuickSelectionDefault" label="Default">
            <set id="ftm_config.timerOutputFrequency">10 kHz</set>
            <set id="ftm_config.extClockFrequencyStr">1</set>
            <set id="ftm_config.timerPrescaler">1</set>
            <set id="ftm_config.bdmMode">kFTM_BdmMode_0</set>
            <set id="ftm_config.pwmSyncMode.kFTM_SoftwareTrigger">true</set>
            <set id="ftm_config.inputFilterPeriod">1</set>
            <set id="ftm_config.deadTimePrescale">kFTM_Deadtime_Prescale_1</set>
            <set id="ftm_config.deadTimePeriod">0</set>
            <set id="ftm_config.useGlobalTimeBase">false</set>
            <set id="EnableTimerInInit">true</set>
         </quick_selection>
         <default>QuickSelectionDefault</default>
      </quick_selections>
   </config_set>
   
   <config_set id="ftm_edge_aligned_mode" label="FlexTimer Edge-aligned mode" from_source="fsl_ftm.h">
      <description>Configuration of timer channels.</description>
      <generated_types>
      </generated_types>
      <user_types>
         <enum id="ftm_chnl_pair_t" label="List of FTM channel pairs." from="_ftm_chnl">
            <description>Actual number of available channels is SoC dependent</description>
            <item id="kFTM_Chnl_0" label="FTM channel 0/1"/>
            <item id="kFTM_Chnl_1" label="FTM channel 2/3"/>
            <item id="kFTM_Chnl_2" label="FTM channel 4/5"/>
            <item id="kFTM_Chnl_3" label="FTM channel 6/7"/>
         </enum>
         <struct from="ftm_input_capture" id="ftm_input_capture_mode_t" label="FTM Input Capture mode">
            <reference type="ftm_chnl_t" id="chnNumber" label="Channel number" config_set_id="fsl_ftm">
               <validation>
                  <dependency resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_ch.` +  $this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1)" description_expr="`Signal CH` + $this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1) + ` of peripheral ` + $instance.getPeripheral() + ` is not routed`" level="Warning">
                     <feature name="routed" evaluation="equal">
                        <data expr="true"/>
                     </feature>
                  </dependency>
                  <dependency resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_ch.` +  $this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1)" description_expr="`Direction of signal CH` + $this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1) + ` of peripheral ` + $instance.getPeripheral() + ` is set as output but it will be used as input`" level="Warning">
                     <feature name="direction" evaluation="notEqualIgnoreCase">
                        <data expr="`OUTPUT`"/>
                     </feature>
                  </dependency>
                  <constraint cond_expr="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt() &lt; getFeature(`FTM_CHANNEL_COUNT`))" level="error" description="You must select an existing channel of the selected FTM device (see the Number of channel property of this component)"/>
               </validation>
            </reference>
            <reference id="input_capture_edge" label="Input Capture Edge" type="ftm_input_capture_edge_t" config_set_id="fsl_ftm">
            </reference>
            <string id="inputFilterPeriod" label="Filter period" options="remove_from_struct_init" 
               validation_expr="x -> system::validateValueFreqPeriod(x, 1, 16)">
               <description>
The input filter sampling period value in number of filter clock cycles (range 1-16), frequency units or time units. This period is used for sampling of the timer input signal. When the value 1 is selected the filter is bypassed.

An integer number in range 1 - 16 (0x10) is processed as a value in ticks of filter clock period, a frequency value must be in format &quot;float_number [Hz, kHz, MHz or GHz]&quot;, a period value must be in format &quot;float_number [ns, us, ms, s, m, h or d]&quot;.
Frequency units and time units can only be used when clock source frequency is selected (clock must not be disabled/calculated in runtime).

When the the minimum value 1 is selected (zero value of the register bitfield) the filter is disabled and the minimum pulse width (filter sampling period) is one filter clock period.
               </description>
               <validation>
                  <constraint when_expr="$parent.filterValue.getValue() != `N/A`" cond_expr="($parent.filterValue.getValue().toInt() &lt;= 16) &amp;&amp; ($parent.filterValue.getValue().toInt() &gt; 0)"  level="error" description="The filter sampling period in ticks must be in the range 1 - 16 (0x10)."/>
                  <constraint cond_expr="$parent.filterValue.getValue() != `N/A`"   level="error" description="A valid value of filter sampling period must be specified. When the filter frequency is not specified the filter sampling period must be specified as an integer number 1 - 16."/>
                  <constraint when_expr="($parent.chnNumber.getEnumItemId()!= `kFTM_Chnl_0`) &amp;&amp; ($parent.chnNumber.getEnumItemId()!= `kFTM_Chnl_1`) &amp;&amp; ($parent.chnNumber.getEnumItemId()!= `kFTM_Chnl_2`) &amp;&amp; ($parent.chnNumber.getEnumItemId()!= `kFTM_Chnl_3`)" cond_expr="$parent.filterValue.getValue().toInt() == 1" level="warning" 
                     description="Only the FTM channel 0, 1, 2 and 3 supports the filter sample period selection. For other channels the filter value is not applicable (set the value to 1 to disable filter)."/>
               </validation>
            </string>
            <variable id="filterValue" value="system::getIntDividerValue($parent.inputFilterPeriod.getValue(), $instance.ftm_main_config.ftm_config.filterClockFreqValue.getValue())" options="add_to_struct"/>
            <info id="inputFilterPeriod_info" label="Calculated filter period" 
               value=" system::calculateTicksFreqPeriod($parent.filterValue.getValue(), $instance.ftm_main_config.ftm_config.filterClockFreqValue.getValue())">
               <description>The calculated input filter sampling period in number of ticks of the filter clock cycles, sampling frequency and time period.</description>
            </info>
            <bool id="enable_chan_irq" label="Enable channel interrupt" options="remove_from_struct_init"/>
            <variable  id="chan_interrupt" available="$parent.enable_chan_irq.getValue()" value="`kFTM_Chnl` + $parent.chnNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1)  + `InterruptEnable`"></variable>
         </struct>
         <struct from="ftm_dual_edge" id="ftm_dual_edge_t" label="Dual Edge Capture Mode">
            <reference type="ftm_chnl_pair_t" id="chnNumber" label="Channel pair number">
                  <validation>
                     <dependency resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_ch.` +  ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2)" description_expr="`Signal CH` + ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2) + ` of peripheral ` + $instance.getPeripheral() + ` is not routed`" level="Warning">
                        <feature name="routed" evaluation="equal">
                           <data expr="true"/>
                        </feature>
                     </dependency>
                     <dependency resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_ch.` +  ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2+1)" description_expr="`Signal CH` + ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2+1) + ` of peripheral ` + $instance.getPeripheral() + ` is not routed`" level="Warning">
                        <feature name="routed" evaluation="equal">
                           <data expr="true"/>
                        </feature>
                     </dependency>
                     <dependency resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_ch.` +  ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2)" description_expr="`Direction of signal CH` + ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2) + ` of peripheral ` + $instance.getPeripheral() + ` is set as output but it will be used as input`" level="Warning">
                        <feature name="direction" evaluation="notEqualIgnoreCase">
                           <data expr="`OUTPUT`"/>
                        </feature>
                     </dependency>                     
                     <dependency resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_ch.` +  ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2+1)" description_expr="`Direction of signal CH` + ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2+1) + ` of peripheral ` + $instance.getPeripheral() + ` is set as output but it will be used as input`" level="Warning">
                        <feature name="direction" evaluation="notEqualIgnoreCase">
                           <data expr="`OUTPUT`"/>
                        </feature>
                     </dependency>                     
                     <constraint cond_expr="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; 
                                         (($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2) &lt; getFeature(`FTM_CHANNEL_COUNT`)) &amp;&amp;
                                         (($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2+1) &lt; getFeature(`FTM_CHANNEL_COUNT`))" level="error" description="You must select an existing channel pair of the selected FTM device (see the Number of channel property of this component)"/>
                  </validation>
            </reference>
            <reference type="ftm_dual_edge_capture_param_t" id="dual_edge_capture_param" label="Dual Edge Mode" config_set_id="fsl_ftm" options="UI_LABEL_HIDDEN;UI_BORDER_HIDDEN">
            </reference>
            <string id="inputFilterPeriod" label="Filter period" options="remove_from_struct_init" 
               validation_expr="x -> system::validateValueFreqPeriod(x, 1, 16)">
               <description>
The input filter sampling period value in number of filter clock cycles (range 1-16), frequency units or time units. This period is used for sampling of the timer input signal. When the value 1 is selected the filter is bypassed.

An integer number in range 1 - 16 (0x10) is processed as a value in ticks of filter clock period, a frequency value must be in format &quot;float_number [Hz, kHz, MHz or GHz]&quot;, a period value must be in format &quot;float_number [ns, us, ms, s, m, h or d]&quot;.
Frequency units and time units can only be used when clock source frequency is selected (clock must not be disabled/calculated in runtime).

When the the minimum value 1 is selected (zero value of the register bitfield) the filter is disabled and the minimum pulse width (filter sampling period) is one filter clock period.
               </description>
               <validation>
                  <constraint when_expr="$parent.filterValue.getValue() != `N/A`" cond_expr="($parent.filterValue.getValue().toInt() &lt;= 16) &amp;&amp; ($parent.filterValue.getValue().toInt() &gt; 0)"  level="error" description="The filter sampling period in ticks must be in the range 1 - 16 (0x10)."/>
                  <constraint cond_expr="$parent.filterValue.getValue() != `N/A`"   level="error" description="A valid value of filter sampling period must be specified. When the filter frequency is not specified the filter sampling period must be specified as an integer number 1 - 16."/>
                  <constraint when_expr="($parent.chnNumber.getEnumItemId()!= `kFTM_Chnl_0`) &amp;&amp; ($parent.chnNumber.getEnumItemId()!= `kFTM_Chnl_1`)" cond_expr="$parent.filterValue.getValue().toInt() == 1" level="warning" 
                     description="Only the FTM channel pairs 0/1 and 2/3 supports the filter sample period selection. For other channels the filter value is not applicable (set the value to 1 to disable filter)."/>
               </validation>
            </string>
            <variable id="filterValue" value="system::getIntDividerValue($parent.inputFilterPeriod.getValue(), $instance.ftm_main_config.ftm_config.filterClockFreqValue.getValue())" options="add_to_struct"/>
            <info id="inputFilterPeriod_info" label="Calculated filter period" 
               value=" system::calculateTicksFreqPeriod($parent.filterValue.getValue(), $instance.ftm_main_config.ftm_config.filterClockFreqValue.getValue())">
               <description>The calculated input filter sampling period in number of ticks of the filter clock cycles, sampling frequency and time period.</description>
            </info>
            <bool id="enable_chan_irq" label="Enable channel N interrupt" options="remove_from_struct_init"/>
            <variable  id="chan_interrupt" available="$parent.enable_chan_irq.getValue()" value="`kFTM_Chnl` + (($parent.chnNumber.getValue() == `kFTM_Chnl_0`) ? `0` : ($parent.chnNumber.getValue() == `kFTM_Chnl_1`) ? `2` : ($parent.chnNumber.getValue() == `kFTM_Chnl_2`) ? `4` : `6`)  + `InterruptEnable`"></variable>
            <bool id="enable_chan1_irq" label="Enable channel N+1 interrupt"  options="remove_from_struct_init"/>
            <variable  id="chan1_interrupt" available="$parent.enable_chan1_irq.getValue()" value="`kFTM_Chnl` + (($parent.chnNumber.getValue() == `kFTM_Chnl_0`) ? `1` : ($parent.chnNumber.getValue() == `kFTM_Chnl_1`) ? `3` : ($parent.chnNumber.getValue() == `kFTM_Chnl_2`) ? `5` : `7`)  + `InterruptEnable`"></variable>
         </struct>
         <struct from="ftm_output_compare" id="ftm_output_compare_mode_t" label="FTM Output Compare mode">
            <reference type="ftm_chnl_t" id="chnNumber" label="Channel number" config_set_id="fsl_ftm">
               <validation>
                  <dependency when_expr="$parent.output_compare_mode.getValue() != `kFTM_NoOutputSignal`" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_ch.` +  $this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1)" description_expr="`Signal CH` + $this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1) + ` of peripheral ` + $instance.getPeripheral() + ` is not routed`" level="Warning">
                     <feature name="routed" evaluation="equal">
                        <data expr="true"/>
                     </feature>
                  </dependency>
                  <dependency when_expr="$parent.output_compare_mode.getValue() != `kFTM_NoOutputSignal`" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_ch.` +  $this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1)" description_expr="`Direction of signal CH` + $this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1) + ` of peripheral ` + $instance.getPeripheral() + ` is set as input but it will be used as output`" level="Warning">
                     <feature name="direction" evaluation="notEqualIgnoreCase">
                        <data expr="`INPUT`"/>
                     </feature>
                  </dependency>
                  <constraint cond_expr="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt() &lt; getFeature(`FTM_CHANNEL_COUNT`))" level="error" description="You must select an existing channel of the selected FTM device (see the Number of channel property of this component)"/>
               </validation>
            </reference>
            <reference id="output_compare_mode" label="Output Compare Mode" type="ftm_output_compare_mode_t" config_set_id="fsl_ftm">
            </reference>
            <string id="compareValueStr" label="Compare value" options="remove_from_struct_init" 
               validation_expr="x -> system::validateValuePeriodDuty(x,0,0xFFFF)">
               <description>
Selection of the Compare value that will be used as the match value of the FTM channel. The value can be set in time units, number of ticks of the timer/counter, percent number. Supported formats of values:
* An integer number is processed as a number of ticks; range 0 - 65535.
* A float number + % (float_number%) is processed as a percentage of the timer period; range 0 - 100.0%. Float number can written also as a fraction, for example 13/17%. Exponent format of the float number is not supported.
* A period value must be in format &quot;float_number [ns, us, ms, s, m, h or d]&quot;.

Frequency units and percentage values can only be used when clock source frequency is selected (clock must not be disabled or runtime calculated by the CLOCK_GetFreq()).
               </description>
               <validation>
                  <constraint when_expr="$parent.compareValue.getValue().isInt() &amp;&amp; $instance.ftm_main_config.ftm_config.timerModuloValue.getValue().isInt()" cond_expr="($parent.compareValue.getValue().toInt() &lt;= $instance.ftm_main_config.ftm_config.timerModuloValue.getValue()) &amp;&amp; ($parent.compareValue.getValue().toInt() &gt;= 0)"  
                     level="error" description_expr="`The Duty width value must be in the range 0 - ` + $instance.ftm_main_config.ftm_config.timerModuloValue.getValue() + ` ticks (timer modulo value) that specify the maximum value of match register value. Adjust the timer frequency/period and/or the timer input frequency.`"/>
                  <constraint cond_expr="$parent.compareValue.getValue().isInt()"  
                     level="error" description_expr="`The Duty value cannot be calculated due to missing specification of the input frequency. Select the timer input frequency or set the duty cycle in timer ticks.`"/>
               </validation>
            </string>
            <variable id="compareValue" value="system::getDutyCycleValue($parent.compareValueStr.getValue(), $instance.ftm_main_config.ftm_config.timerModuloValue.getValue(), $instance.ftm_main_config.ftm_config.timerInputFreq.getValue())" options="add_to_struct"/>
            <info id="calculatedDutyPeriod" label="Calculated compare value" 
               value="system::calculateTicksPeriod($parent.compareValue.getValue(), $instance.ftm_main_config.ftm_config.timerInputFreq.getValue())">
               <description>Calculated compare value in timer ticks and time period. Calculation is based on the supported values of the channel match register and maximum value that is limited by the timer modulo value.</description>
            </info>
            <bool id="enable_chan_irq" label="Enable channel interrupt" options="remove_from_struct_init"/>
            <variable  id="chan_interrupt" available="$parent.enable_chan_irq.getValue()" value="`kFTM_Chnl` + $parent.chnNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1)  + `InterruptEnable`"></variable>
         </struct>
         <struct id="ftm_chnl_pwm_config_param_t" label="Options to configure a FTM channel using precise setting" from="_ftm_chnl_pwm_config_param">
            <description>Options for configuration of a FTM channel as PWM output by using the edge aligned PWM mode.</description>
            <reference id="chnlNumber" label="Channel number" type="ftm_chnl_t" config_set_id="fsl_ftm">
               <description>The FTM channel number.</description>
               <validation>
                  <dependency when_expr="$parent.level.getValue() != `kFTM_NoPwmSignal`"  resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_ch.` +  $this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1)" description_expr="`Signal CH` + $this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1) + ` of peripheral ` + $instance.getPeripheral() + ` is not routed`" level="Warning">
                     <feature name="routed" evaluation="equal">
                        <data expr="true"/>
                     </feature>
                  </dependency>
                  <dependency when_expr="$parent.level.getValue() != `kFTM_NoPwmSignal`" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_ch.` +  $this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1)" description_expr="`Direction of signal CH` + $this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1) + ` of peripheral ` + $instance.getPeripheral() + ` is set as input but it will be used as output`" level="Warning">
                     <feature name="direction" evaluation="notEqualIgnoreCase">
                        <data expr="`INPUT`"/>
                     </feature>
                  </dependency>
                  <constraint cond_expr="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt() &lt; getFeature(`FTM_CHANNEL_COUNT`))" level="error" description="You must select an existing channel of the selected FTM device (see the Number of channel property of this component)"/>
               </validation>
            </reference>
            <reference id="level" label="PWM output active level" type="ftm_pwm_level_select_t" config_set_id="fsl_ftm">
               <description>PWM output active level selection.</description>
            </reference>
            <string id="dutyValueStr" label="Duty cycle" options="remove_from_struct_init" 
               validation_expr="x -> system::validateValuePeriodDuty(x,0,0xFFFF)">
               <description>
Selection of the PWM pulse width (duty cycle) in time units, number of ticks of the timer/counter, percent number. Supported formats of values:
* An integer number is processed as a number of ticks; range 0 - 65535.
* A float number + % (float_number%) is processed as a percentage of the duty cycle; range 0 - 100.0%. Float number can written also as a fraction, for example 13/17%. Exponent format of the float number is not supported.
* A period value must be in format &quot;float_number [ns, us, ms, s, m, h or d]&quot;.

Frequency units and time units can only be used when clock source frequency is selected (clock must not be disabled or runtime calculated by the CLOCK_GetFreq()).
               </description>
               <validation>
                  <constraint when_expr="$parent.dutyValue.getValue().isInt() &amp;&amp; $instance.ftm_main_config.ftm_config.timerModuloValue.getValue().isInt()" cond_expr="($parent.dutyValue.getValue().toInt() &lt;= $instance.ftm_main_config.ftm_config.timerModuloValue.getValue()) &amp;&amp; ($parent.dutyValue.getValue().toInt() &gt;= 0)"  
                     level="error" description_expr="`The Duty width value must be in the range 0 - ` + $instance.ftm_main_config.ftm_config.timerModuloValue.getValue() + ` ticks (timer modulo value) that specify the maximum value of match register value. Adjust the timer frequency/period and/or the timer input frequency.`"/>
                  <constraint cond_expr="$parent.dutyValue.getValue().isInt()"  
                     level="error" description_expr="`The Duty value cannot be calculated due to missing specification of the input frequency. Select the timer input frequency or set the duty cycle in timer ticks.`"/>
               </validation>
            </string>
            <variable id="dutyValue" value="system::getDutyCycleValue($parent.dutyValueStr.getValue(), $instance.ftm_main_config.ftm_config.timerModuloValue.getValue(), $instance.ftm_main_config.ftm_config.timerInputFreq.getValue())" options="add_to_struct"/>
            <info id="calculatedDutyPeriod" label="Calculated duty cycle" 
               value="system::calculateTicksPeriod($parent.dutyValue.getValue(), $instance.ftm_main_config.ftm_config.timerInputFreq.getValue())">
               <description>Calculated duty width in timer ticks and time period. Calculation is based on the supported values of the channel match register and maximum value that is limited by the timer modulo value.</description>
            </info>
            <bool id="enable_chan_irq" label="Enable channel interrupt" options="remove_from_struct_init"/>
            <variable  id="chan_interrupt" available="$parent.enable_chan_irq.getValue()" value="`kFTM_Chnl` + $parent.chnlNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1)  + `InterruptEnable`"></variable>
         </struct>
         <struct id="ftm_chnl_combined_pwm_config_param_t" label="Options to configure a FTM channel using precise setting" from="_ftm_chnl_pwm_config_param">
            <description>Options for configuration of a FTM channel as PWM output by using a combined PWM mode.</description>
            <reference id="chnlNumber" label="Channel pair number" type="ftm_chnl_pair_t">
               <description>The channel/channel pair number. In combined mode, this represents the channel pair number.</description>
               <validation>
                  <dependency when_expr="$parent.level.getValue() != `kFTM_NoPwmSignal`" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_ch.` +  ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2)" description_expr="`Signal CH` + ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2) + ` of peripheral ` + $instance.getPeripheral() + ` is not routed`" level="Warning">
                     <feature name="routed" evaluation="equal">
                        <data expr="true"/>
                     </feature>
                  </dependency>
                  <dependency when_expr="$parent.level.getValue() != `kFTM_NoPwmSignal`" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_ch.` +  ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2+1)" description_expr="`Signal CH` + ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2+1) + ` of peripheral ` + $instance.getPeripheral() + ` is not routed`" level="Warning">
                     <feature name="routed" evaluation="equal">
                        <data expr="true"/>
                     </feature>
                  </dependency>
                  <dependency when_expr="$parent.level.getValue() != `kFTM_NoPwmSignal`" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_ch.` +  ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2)" description_expr="`Direction of signal CH` + ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2) + ` of peripheral ` + $instance.getPeripheral() + ` is set as input but it will be used as output`" level="Warning">
                     <feature name="direction" evaluation="notEqualIgnoreCase">
                        <data expr="`INPUT`"/>
                     </feature>
                  </dependency>
                  <dependency when_expr="$parent.level.getValue() != `kFTM_NoPwmSignal`" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_ch.` +  ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2+1)" description_expr="`Direction of signal CH` + ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2+1) + ` of peripheral ` + $instance.getPeripheral() + ` is set as input but it will be used as output`" level="Warning">
                     <feature name="direction" evaluation="notEqualIgnoreCase">
                        <data expr="`INPUT`"/>
                     </feature>
                  </dependency>
                  <constraint cond_expr="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; 
                     (($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2) &lt; getFeature(`FTM_CHANNEL_COUNT`)) &amp;&amp;
                     (($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2+1) &lt; getFeature(`FTM_CHANNEL_COUNT`))" level="error" description="You must select an existing channel pair of the selected FTM device (see the Number of channel property of this component)"/>
               </validation>
            </reference>
            <reference id="level" label="PWM output active level" type="ftm_pwm_level_select_t" config_set_id="fsl_ftm">
               <description>PWM output active level selection.</description>
            </reference>
            <string id="firstEdgeValueStr" label="First edge" options="remove_from_struct_init" 
               validation_expr="x -> system::validateValuePeriodDuty(x,0,0xFFFF)">
               <description>
Selection of the first edge poistion of the PWM pulse in time units, number of ticks of the timer/counter, percent number. Supported formats of values:
* An integer number is processed as a number of ticks; range 0 - 65535.
* A float number + % (float_number%) is processed as a percentage of the signal period; range 0 - 100.0%. Float number can written also as a fraction, for example 13/17%. Exponent format of the float number is not supported.
* A period value must be in format &quot;float_number [ns, us, ms, s, m, h or d]&quot;.

Frequency units and time units can only be used when clock source frequency is selected (clock must not be disabled or runtime calculated by the CLOCK_GetFreq()).
               </description>
               <validation>
                  <constraint when_expr="$parent.firstEdgeValue.getValue().isInt()  &amp;&amp; $instance.ftm_main_config.ftm_config.timerModuloValue.getValue().isInt()" cond_expr="($parent.firstEdgeValue.getValue().toInt() &lt;= $instance.ftm_main_config.ftm_config.timerModuloValue.getValue()) &amp;&amp; ($parent.firstEdgeValue.getValue().toInt() &gt;= 0)"  
                     level="error" description_expr="`The first edge value must be in the range 0 - ` + $instance.ftm_main_config.ftm_config.timerModuloValue.getValue() + ` ticks (timer modulo value) that specify the maximum value of match register value. Adjust the timer frequency/period and/or the first edge value.`"/>
               </validation>
            </string>
            <variable id="firstEdgeValue" value="system::getDutyCycleValue($parent.firstEdgeValueStr.getValue(), $instance.ftm_main_config.ftm_config.timerModuloValue.getValue(), $instance.ftm_main_config.ftm_config.timerInputFreq.getValue())">
               <options_expr>
                  <option id="add_to_struct" available="$this.getValue().isInt()"/>
               </options_expr>
            </variable>
            <info id="calculatedFirstEdgeValue" label="Calculated first edge" 
               value="system::calculateTicksPeriod($parent.firstEdgeValue.getValue(), $instance.ftm_main_config.ftm_config.timerInputFreq.getValue())">
               <description>Calculated first edge position of the PWM signal in timer ticks and time period. Calculation is based on the selected combined mode of this channel and the timer modulo value.</description>
            </info>
            <string id="dutyValueStr" label="Duty cycle" options="remove_from_struct_init" 
               validation_expr="x -> system::validateValuePeriodDuty(x,0,0xFFFF)">
               <description>
Selection of the PWM pulse width (duty cycle) in time units, number of ticks of the timer/counter, percent number. Supported formats of values:
* An integer number is processed as a number of ticks; range 0 - 65535.
* A float number + % (float_number%) is processed as a percentage of the duty cycle; range 0 - 100.0%. Float number can written also as a fraction, for example 13/17%. Exponent format of the float number is not supported.
* A period value must be in format &quot;float_number [ns, us, ms, s, m, h or d]&quot;.

Frequency units and time units can only be used when clock source frequency is selected (clock must not be disabled or runtime calculated by the CLOCK_GetFreq()).
               </description>
               <validation>
                  <constraint when_expr="$parent.dutyValuePre.getValue().isInt() &amp;&amp; $instance.ftm_main_config.ftm_config.timerModuloValue.getValue().isInt()" cond_expr="($parent.dutyValuePre.getValue().toInt() &lt;= $instance.ftm_main_config.ftm_config.timerModuloValue.getValue()) &amp;&amp; ($parent.dutyValuePre.getValue().toInt() &gt;= 0)"  
                     level="error" description_expr="`The duty width value must be in the range 0 - ` + $instance.ftm_main_config.ftm_config.timerModuloValue.getValue() + ` ticks (timer modulo value) that specify the maximum value of match register value. Adjust the timer frequency/period and/or the duty cycle value.`"/>
                  <constraint when_expr="$parent.dutyValuePre.getValue().isInt() &amp;&amp; $parent.firstEdgeValue.getValue().isInt() &amp;&amp; $instance.ftm_main_config.ftm_config.timerModuloValue.getValue().isInt()" 
                     cond_expr="(($parent.dutyValuePre.getValue().toInt() + $parent.firstEdgeValue.getValue().toInt()) &lt;= $instance.ftm_main_config.ftm_config.timerModuloValue.getValue()) &amp;&amp; ($parent.dutyValuePre.getValue().toInt() &gt;= 0)"  
                     level="error" description_expr="`The duty width + first edge value must be in the range 0 - ` + $instance.ftm_main_config.ftm_config.timerModuloValue.getValue() + ` ticks (timer modulo value) that specify the maximum value of match register value. Adjust the timer frequency/period, the first edge value and/or the duty cycle value.`"/>
                  <constraint cond_expr="$parent.dutyValue.getValue().isInt()"  
                     level="error" description_expr="`The Duty value cannot be calculated due to missing specification of the input frequency. Select the timer input frequency or set the duty cycle in timer ticks.`"/>
               </validation>
            </string>
            <variable id="dutyValuePre" value="system::getDutyCycleValue($parent.dutyValueStr.getValue(), $instance.ftm_main_config.ftm_config.timerModuloValue.getValue(), $instance.ftm_main_config.ftm_config.timerInputFreq.getValue())"/>
            <!-- The calculation of the duty cycle is done by the following expression because of the MCUX-40278 issue - incorrect calculation of the duty in the FTM_SetupPwmMode() function. It shall be updated whe fixed in the driver. -->
            <variable id="dutyValue" value="($parent.dutyValuePre.getValue().isInt() &amp;&amp; $parent.firstEdgeValue.getValue().isInt()) ? $parent.dutyValuePre.getValue().toInt() + $parent.firstEdgeValue.getValue().toInt() : `N/A`" options="add_to_struct"/>
            <!-- When the MCUX-40278 issue is fixed the following duty value variable shall be used:
               <variable id="dutyValue" value="($parent.dutyValuePre.getValue().isInt()) ? $parent.dutyValuePre.getValue().toInt() : `N/A`" options="add_to_struct"/>-->
            <info id="calculatedDutyPeriod" label="Calculated duty cycle" 
               value="system::calculateTicksPeriod($parent.dutyValuePre.getValue(), $instance.ftm_main_config.ftm_config.timerInputFreq.getValue())">
               <description>Calculated duty width in timer ticks and time period. Calculation is based on the supported values of the channel match register and maximum value that is limited by the timer modulo value.</description>
            </info>
            <bool id="enableComplementary" label="Complementary mode" options="remove_from_struct_init">
               <description>When enabled the combined channels output complementary signals otherwise the combined channels output same signals;</description>
            </bool>
            <bool id="enableDeadtime" label="Deadtime insertion" options="remove_from_struct_init">
               <description>Used only in combined PWM mode with enabled complementary mode. When enabled the deadtime insertion in this pair of channels is enabled.</description>
            </bool>
            <!-- Interrupts -->
            <bool id="enable_chan_irq" label="Enable channel N interrupt" options="remove_from_struct_init"/>
            <variable  id="chan_interrupt" available="$parent.enable_chan_irq.getValue()" value="`kFTM_Chnl` + (($parent.chnlNumber.getValue() == `kFTM_Chnl_0`) ? `0` : ($parent.chnlNumber.getValue() == `kFTM_Chnl_1`) ? `2` : ($parent.chnlNumber.getValue() == `kFTM_Chnl_2`) ? `4` : `6`)  + `InterruptEnable`"></variable>
            <bool id="enable_chan1_irq" label="Enable channel N+1 interrupt"  options="remove_from_struct_init"/>
            <variable  id="chan1_interrupt" available="$parent.enable_chan1_irq.getValue()" value="`kFTM_Chnl` + (($parent.chnlNumber.getValue() == `kFTM_Chnl_0`) ? `1` : ($parent.chnlNumber.getValue() == `kFTM_Chnl_1`) ? `3` : ($parent.chnlNumber.getValue() == `kFTM_Chnl_2`) ? `5` : `7`)  + `InterruptEnable`"></variable>
         </struct>
         <enum id="ftm_edge_aligned_mode_t" label="FTM edge-aligned channel modes." from="_ftm_edge_aligned_mode">
            <item id="kFTM_InputCapture" label="Input Capture">
               <description>Input capture mode of a singe FTM channel</description>
            </item>
            <item id="kFTM_DualEdgeCapture" label="Dual Edge Capture">
               <description>Dual edge capture mode of FTM channel pair.</description>
            </item>
            <item id="kFTM_OutputCompare" label="Output compare">
               <description>Output compare mode of a singe FTM channel</description>
            </item>
            <item id="kFTM_EdgeAlignedPwm" label="Edge-aligned PWM">
               <description>Edge aligned PWM mode of a singe FTM channel</description>
            </item>
            <item id="kFTM_CombinedPwm" label="Combined PWM">
               <description>Combined PWM mode of a FTM channel pair. This mode support shift of the PWM pulse by using two channels. In this mode, the edge-aligned, center-aligned, or asymmetrical PWM can be generated.</description> 
            </item>
            <!-- The following ecomplementary mode is not supported as a different mode because the IP block guide does not provide specification of these FTM modes.
                 The functinality is provided by using selection of the complementary output in the combined mode settings. -->
            <!--  <item id="kFTM_ComplementaryPwm" label="Complementary PWM">
               <description>Complementary PWM mode (complementary output is enabled)</description>
            </item> -->
         </enum>
         <struct id="ftm_edge_aligned_channel_mode" label="FTM Edge Aligned Channel Mode" from="_ftm_edge_aligned_channel_mode">         
            <validation>
               <!-- constraint for checking of duplicated channel - it is also used for combined mode - even number of channels -->
               <constraint cond_expr="$parent.searchInArray(
                  item -> (($this.getID() != item.getID()) &amp;&amp; 
                  (((item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_InputCapture`) 
                    ?  item.getSetting(`input_capture.chnNumber`).getValue().regexSubstr(`.*Chnl_(\d+)`, 1) 
                    : (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_DualEdgeCapture`) 
                    ? (item.getSetting(`dual_edge_capture.chnNumber`).getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2) 
                    : (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_OutputCompare`) 
                    ?  item.getSetting(`output_compare.chnNumber`).getValue().regexSubstr(`.*Chnl_(\d+)`, 1) 
                    : (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_EdgeAlignedPwm`) 
                    ?  item.getSetting(`edge_aligned_pwm.chnlNumber`).getValue().regexSubstr(`.*Chnl_(\d+)`, 1) 
                    : (item.getSetting(`combined_pwm.chnlNumber`).getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2) 
                   ) == 
                   (
                    ($this.edge_aligned_mode.getValue() == `kFTM_InputCapture`) 
                    ? $this.input_capture.chnNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1) 
                    : ($this.edge_aligned_mode.getValue() == `kFTM_DualEdgeCapture`) 
                    ? ($this.dual_edge_capture.chnNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2) 
                    : ($this.edge_aligned_mode.getValue() == `kFTM_OutputCompare`) 
                    ? $this.output_compare.chnNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1) 
                    : ($this.edge_aligned_mode.getValue() == `kFTM_EdgeAlignedPwm`) 
                    ? $this.edge_aligned_pwm.chnlNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1) 
                    : ($this.combined_pwm.chnlNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2)
                   )    
                 ))) &lt; 0 " level="warning" 
                    description_expr="`Duplicated channel (` + 
                    (($this.edge_aligned_mode.getValue() == `kFTM_InputCapture`) 
                    ? $this.input_capture.chnNumber.getEnumItemLabel() 
                    : ($this.edge_aligned_mode.getValue() == `kFTM_DualEdgeCapture`) 
                    ? ($this.dual_edge_capture.chnNumber.getEnumItemLabel()) 
                    : ($this.edge_aligned_mode.getValue() == `kFTM_OutputCompare`) 
                    ? $this.output_compare.chnNumber.getEnumItemLabel() 
                    : ($this.edge_aligned_mode.getValue() == `kFTM_EdgeAlignedPwm`) 
                    ? $this.edge_aligned_pwm.chnlNumber.getEnumItemLabel() 
                    : ($this.combined_pwm.chnlNumber.getEnumItemLabel()))
                 + `) is selected. Please, select each channel once only.`" />
               <!-- constraint for checking of duplicated channel - it is also used for combined mode - odd number of channels -->
               <constraint cond_expr="$parent.searchInArray(
                  item -> (($this.getID() != item.getID()) &amp;&amp; 
                  ((
                    (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_DualEdgeCapture`) 
                    ? (item.getSetting(`dual_edge_capture.chnNumber`).getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2+1) 
                    : (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_CombinedPwm`) 
                    ? (item.getSetting(`combined_pwm.chnlNumber`).getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2+1) 
                    : (-1)
                   ) == 
                   (
                    ($this.edge_aligned_mode.getValue() == `kFTM_InputCapture`) 
                    ? $this.input_capture.chnNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1) 
                    : ($this.edge_aligned_mode.getValue() == `kFTM_DualEdgeCapture`) 
                    ? ($this.dual_edge_capture.chnNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2+1) 
                    : ($this.edge_aligned_mode.getValue() == `kFTM_OutputCompare`) 
                    ? $this.output_compare.chnNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1) 
                    : ($this.edge_aligned_mode.getValue() == `kFTM_EdgeAlignedPwm`) 
                    ? $this.edge_aligned_pwm.chnlNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1) 
                    : ($this.combined_pwm.chnlNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2+1)
                   )    
                 ))) &lt; 0 " level="warning" 
                    description_expr="`Duplicated channel (` + 
                    (($this.edge_aligned_mode.getValue() == `kFTM_InputCapture`) 
                    ? $this.input_capture.chnNumber.getEnumItemLabel() 
                    : ($this.edge_aligned_mode.getValue() == `kFTM_DualEdgeCapture`) 
                    ? ($this.dual_edge_capture.chnNumber.getEnumItemLabel()) 
                    : ($this.edge_aligned_mode.getValue() == `kFTM_OutputCompare`) 
                    ? $this.output_compare.chnNumber.getEnumItemLabel() 
                    : ($this.edge_aligned_mode.getValue() == `kFTM_EdgeAlignedPwm`) 
                    ? $this.edge_aligned_pwm.chnlNumber.getEnumItemLabel() 
                    : ($this.combined_pwm.chnlNumber.getEnumItemLabel()))
                 + `) is selected. Please, select each channel once only.`" />
               <constraint cond_expr="$parent.searchInArray(
                  item -> (($this.getID() != item.getID()) &amp;&amp; 
                  (((item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_InputCapture`) 
                    ?  item.getSetting(`input_capture.chnNumber`).getValue().regexSubstr(`.*Chnl_(\d+)`, 1) 
                    : (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_DualEdgeCapture`) 
                    ? (item.getSetting(`dual_edge_capture.chnNumber`).getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2) 
                    : (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_OutputCompare`) 
                    ?  item.getSetting(`output_compare.chnNumber`).getValue().regexSubstr(`.*Chnl_(\d+)`, 1) 
                    : (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_EdgeAlignedPwm`) 
                    ?  item.getSetting(`edge_aligned_pwm.chnlNumber`).getValue().regexSubstr(`.*Chnl_(\d+)`, 1) 
                    : (item.getSetting(`combined_pwm.chnlNumber`).getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2) 
                   ) == 
                   (
                    ($this.edge_aligned_mode.getValue() == `kFTM_DualEdgeCapture`) 
                    ? ($this.dual_edge_capture.chnNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2+1) 
                    : ($this.edge_aligned_mode.getValue() == `kFTM_CombinedPwm`) 
                    ? ($this.combined_pwm.chnlNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2+1) 
                    : (-1)
                   )    
                 ))) &lt; 0 " level="warning" 
                    description_expr="`Duplicated channel (` + 
                    (($this.edge_aligned_mode.getValue() == `kFTM_InputCapture`) 
                    ? $this.input_capture.chnNumber.getEnumItemLabel() 
                    : ($this.edge_aligned_mode.getValue() == `kFTM_DualEdgeCapture`) 
                    ? ($this.dual_edge_capture.chnNumber.getEnumItemLabel()) 
                    : ($this.edge_aligned_mode.getValue() == `kFTM_OutputCompare`) 
                    ? $this.output_compare.chnNumber.getEnumItemLabel() 
                    : ($this.edge_aligned_mode.getValue() == `kFTM_EdgeAlignedPwm`) 
                    ? $this.edge_aligned_pwm.chnlNumber.getEnumItemLabel() 
                    : ($this.combined_pwm.chnlNumber.getEnumItemLabel()))
                 + `) is selected. Please, select each channel once only.`" />
            </validation>
            <string id="channelId" label="Channel ID">
               <description>Custom channel identifier of the channel that is used for the channel definition in generated header file. When empty ID is used the definition is not generated in the header file.</description>
               <validation>
                  <constraint when_expr="$this.value() != ``" cond_expr="$this.value().isCIdentifier()" level="error" description_expr="`Name ` + $this.value() + ` is not a valid identifier.`"/>
                  <constraint when_expr="$this.value() != ``" cond_expr="$components.system.#global.duplicit_ids.getValue().noneMatch(x -> (x.getValue() == $parent.channelFullId.getValue()))" level="warning" description_expr="`Custom channel ID &quot;` + $this.getValue() + `&quot; is a duplicate. The ` + $parent.channelFullId.getValue() + ` definition name is already used in this project.`"/>
               </validation>
            </string>
            <variable id="channelFullId" value="($parent.channelId.getValue()!= ``) ? toUpperCase($instance.ftm_main_config.inst_ID_def.getValue()  + `_` + $parent.channelId.getValue() + ((($parent.edge_aligned_mode.getValue() == `kFTM_DualEdgeCapture`) || ($parent.edge_aligned_mode.getValue() == `kFTM_CombinedPwm`)) ? `_PAIR` : `_CHANNEL`)) : ``">
               <options_expr>
                  <option id="id_check" available="$this.getValue() != ``"/>
               </options_expr>
            </variable>
            <variable id="channelNumber" value="(($parent.edge_aligned_mode.getValue() == `kFTM_InputCapture`) 
               ? $parent.input_capture.chnNumber.getEnumItemLabel() 
               : ($parent.edge_aligned_mode.getValue() == `kFTM_DualEdgeCapture`) 
               ? ($parent.dual_edge_capture.chnNumber.getEnumItemLabel()) 
               : ($parent.edge_aligned_mode.getValue() == `kFTM_OutputCompare`) 
               ? $parent.output_compare.chnNumber.getEnumItemLabel() 
               : ($parent.edge_aligned_mode.getValue() == `kFTM_EdgeAlignedPwm`) 
               ? $parent.edge_aligned_pwm.chnlNumber.getEnumItemLabel() 
               : ($parent.combined_pwm.chnlNumber.getEnumItemLabel()))"></variable>
            <reference type="ftm_edge_aligned_mode_t" id="edge_aligned_mode" label="Edge-aligned mode">
               <description>Selection of the edge-aligned mode of the channel.</description>
            </reference>
            <reference type="ftm_input_capture_mode_t" id="input_capture" label="Input Capture settings" available="$parent.edge_aligned_mode.getValue() == `kFTM_InputCapture`"/>
            <reference type="ftm_dual_edge_t" id="dual_edge_capture" label="Dual-edge Capture settings" available="$parent.edge_aligned_mode.getValue() == `kFTM_DualEdgeCapture`"/>
            <reference type="ftm_output_compare_mode_t" id="output_compare" label="Output Compare settings" available="$parent.edge_aligned_mode.getValue() == `kFTM_OutputCompare`"/>
            <reference type="ftm_chnl_pwm_config_param_t" id="edge_aligned_pwm" label="Edge-aligned PWM settings" available="$parent.edge_aligned_mode.getValue() == `kFTM_EdgeAlignedPwm`"/>
            <reference type="ftm_chnl_combined_pwm_config_param_t" id="combined_pwm" label="Combined PWM settings" available="$parent.edge_aligned_mode.getValue() == `kFTM_CombinedPwm`"/>
         </struct>
      </user_types>
      <settings>
         <array id="ftm_edge_aligned_channels_config" label="Channels" type="ftm_edge_aligned_channel_mode" options="UI_SHOW_CONTENT_AS=MASTER_DETAIL" key_selector_expr="x ->  (x.getSetting(`channelId`).getValue() != ``) ? x.getSetting(`channelId`).getValue() : x.getSetting(`channelNumber`).getValue()">
            <description>Configuration of the FTM channels in the edge-eligned mode.</description>
            <item_defaults>
               <set_default id="input_capture.inputFilterPeriod" value_expr="x -> 1"/>
               <set_default id="dual_edge_capture.inputFilterPeriod" value_expr="x -> 1"/>
            </item_defaults>
         </array>
         <!-- Variables used for reloadPoints verification; it return list of channels that provide the match event occurrence (output compare or a PWM mode). -->
         <variable value="$parent.ftm_edge_aligned_channels_config.map(item -> 
            (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_OutputCompare`)
            ? (item.getSetting(`output_compare.chnNumber`).getValue().regexSubstr(`.*Chnl_(\d+)`, 1)) 
            : (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_EdgeAlignedPwm`) 
            ? (item.getSetting(`edge_aligned_pwm.chnlNumber`).getValue().regexSubstr(`.*Chnl_(\d+)`, 1)) 
            : (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_CombinedPwm`) 
            ? ((item.getSetting(`combined_pwm.chnlNumber`).getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2))
            : ``)" id="ChanOddMatchInit"></variable>
         <variable value="$parent.ftm_edge_aligned_channels_config.map(item -> 
            (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_CombinedPwm`) 
            ? ((item.getSetting(`combined_pwm.chnlNumber`).getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2+1))
            : ``)" id="ChanEvenMatchInit"></variable>
      </settings>
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="common_code_templates"/>
         </import>
         <def fragment="channel_define">
            <fragment id="define" if_expr="$this.channelId.getValue() != ``">
               <param id="name" expr="$this.channelFullId.getValue()"/>
               <param id="value" expr="(($this.edge_aligned_mode.getValue() == `kFTM_InputCapture`) 
                  ? $this.input_capture.chnNumber.getCValue()
                  : ($this.edge_aligned_mode.getValue() == `kFTM_DualEdgeCapture`) 
                  ? $this.dual_edge_capture.chnNumber.getCValue()
                  : ($this.edge_aligned_mode.getValue() == `kFTM_OutputCompare`) 
                  ? $this.output_compare.chnNumber.getCValue()
                  : ($this.edge_aligned_mode.getValue() == `kFTM_EdgeAlignedPwm`) 
                  ? $this.edge_aligned_pwm.chnlNumber.getCValue()
                  : ($this.combined_pwm.chnlNumber.getCValue()))"/>
               <param id="description" expr="`Definition of ` + $instance.getPeripheral() + ` channel/pair number ` +(($this.edge_aligned_mode.getValue() == `kFTM_InputCapture`) 
                  ? $this.input_capture.chnNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1) 
                  : ($this.edge_aligned_mode.getValue() == `kFTM_DualEdgeCapture`) 
                  ? ($this.dual_edge_capture.chnNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2 + `/` + (($this.dual_edge_capture.chnNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2)+1)) 
                  : ($this.edge_aligned_mode.getValue() == `kFTM_OutputCompare`) 
                  ? $this.output_compare.chnNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1) 
                  : ($this.edge_aligned_mode.getValue() == `kFTM_EdgeAlignedPwm`) 
                  ? $this.edge_aligned_pwm.chnlNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1) 
                  : ($this.combined_pwm.chnlNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2 + `/` + (($this.combined_pwm.chnlNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt()*2)+1))) + ` on ` + $this.edge_aligned_mode.getEnumItemLabel()"/>
            </fragment>
         </def>
         <def fragment="dual_edge_capture_struct">
            <fragment id="const_struct" apply_to="$this.dual_edge_capture_param">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_channel` + $parent.chnNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1)"></param>
               <param id="type">ftm_dual_edge_capture_param_t</param>
            </fragment>
         </def>
         <def fragment="channel_struct">
            <fragment id="dual_edge_capture_struct" if_expr="($this.edge_aligned_mode.getValue() == `kFTM_DualEdgeCapture`)" apply_to="$this.dual_edge_capture">
            </fragment>
         </def>
         <def fragment="ftm_edge_aligned_channels_struct"> <!-- it is an array of structures -->
            <fragment id="channel_struct" for_elements_of="$this" >     <!-- apply in context of each iten in the set/structure/array -->      
            </fragment>
            <br/>
         </def>
         <!-- Init functions -->
         <def fragment="input_capture_init">
            <expr>
               leftPadding(`FTM_SetupInputCapture(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`) + `, ` + 
               $this.chnNumber.getCValue() + `, ` +
               $this.input_capture_edge.getCValue() + `, ` +
               ($this.filterValue.getValue().toInt() - 1) + `);`, 1)
            </expr><br/>
         </def>
         <def fragment="dual_edge_capture_init">
            <expr>
               leftPadding(`FTM_SetupDualEdgeCapture(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`) + `, ` + 
               $this.chnNumber.getCValue() + `, ` +
               `&amp;` + $instance.getFnGroupPrefix() + $instance.getID() + `_channel` + $this.chnNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1) + `, ` + 
               ($this.filterValue.getValue().toInt() - 1) + `);`, 1)
            </expr><br/>
         </def>
         <def fragment="output_compare_init">
            <expr>
               leftPadding(`FTM_SetupOutputCompare(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`) + `, ` + 
               $this.chnNumber.getCValue() + `, ` +
               $this.output_compare_mode.getCValue() + `, ` +
               $this.compareValue.getValue() + `U);`, 1)
            </expr><br/>
         </def>
         <def fragment="channel_init">
            <fragment id="input_capture_init" if_expr="($this.edge_aligned_mode.getValue() == `kFTM_InputCapture`)" apply_to="$this.input_capture"></fragment>
            <fragment id="dual_edge_capture_init" if_expr="($this.edge_aligned_mode.getValue() == `kFTM_DualEdgeCapture`)" apply_to="$this.dual_edge_capture"></fragment>
            <fragment id="output_compare_init" if_expr="($this.edge_aligned_mode.getValue() == `kFTM_OutputCompare`)" apply_to="$this.output_compare"></fragment>
         </def>
         <def fragment="ftm_edge_aligned_channels_init"> <!-- it is an array of structures -->
            <fragment id="channel_init" for_elements_of="$this" >     <!-- apply in context of each iten in the set/structure/array -->      
            </fragment>
         </def>
         <!-- PWM channels signal params configuration as an array of the ftm_chnl_pwm_config_param_t structures -->         
         <def fragment="pwm_channel_struct">
            <expr>leftPadding(`{`,1)</expr><br/>
            <fragment id="field" for_elements_of="$this.edge_aligned_pwm">
               <param id="paddingLevel" expr="2"></param>
            </fragment>
            <expr>leftPadding(`}`,1)</expr>
            <expr> ($param._last ? ``: `,`) </expr><br/>
         </def>
         <def fragment="pwm_channels_struct"> <!-- it is an array of structures -->
            <expr>`const ` + $param.type + ` ` + $param.name + `[] = { `</expr><br/>
            <fragment id="pwm_channel_struct" for_elements_of="$this.filter(item -> (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_EdgeAlignedPwm`))"/>      
            <text>};</text>
            <br/>
         </def>
         <def fragment="pwm_channels_init"> <!-- it is an array of structures -->
            <expr>
               leftPadding(`FTM_SetupPwmMode(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`) + `, ` + 
               $param.struct_name + `, ` + 
               + $param.number_of_channels + `, ` +
               + `kFTM_EdgeAlignedPwm);`, 1) 
            </expr><br/>
         </def>
         <!-- PWM channels signal params configuration as an array of the ftm_chnl_pwm_config_param_t structures -->         
         <def fragment="combined_pwm_channel_struct">
            <expr>leftPadding(`{`,1)</expr><br/>
            <fragment id="field" for_elements_of="$this.combined_pwm">
                  <param id="paddingLevel" expr="2"></param>
            </fragment>
            <expr>leftPadding(`}`,1)</expr>
            <expr> ($param._last ? ``: `,`) </expr><br/>
         </def>
         <def fragment="combined_pwm_channels_struct"> <!-- it is an array of structures -->
            <expr>`const ` + $param.type + ` ` + $param.name + `[] = { `</expr><br/>
            <fragment id="combined_pwm_channel_struct" for_elements_of="$this.filter(item -> (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_CombinedPwm`) &amp;&amp; (item.getSetting(`combined_pwm.enableComplementary`).getValue() == $param.complementaryMode))">      
            </fragment>
            <text>};</text>
            <br/>
         </def>
         <def fragment="combined_pwm_channels_init"> <!-- it is an array of structures -->
            <expr>
               leftPadding(`FTM_SetupPwmMode(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`) + `, ` + 
               $param.struct_name + `, ` + 
               + $param.number_of_channels + `, ` +
               + $param.combinedMode +`);`, 1) 
            </expr><br/>
         </def>

         <def fragment="combined_pwm_deadtime_init"> <!-- it is an array of structures -->
            <expr>
               leftPadding(`FTM_SetDeadTimeEnable(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`) + `, ` + 
               $param.channel + `, ` + 
               + $param.deadtime +`);`, 1) 
            </expr><br/>
         </def>
         
         
         <def fragment="ftm_set_timer_period_init"> <!-- it is an array of structures -->
            <expr>
               leftPadding(`FTM_SetTimerPeriod(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`) + `, ` + $instance.ftm_main_config.timerModuloDefId.getValue() + `);`, 1) 
            </expr><br/>
         </def>
         <!-- Enable interrupts of channels and timer -->
         <def fragment="channel_interrupts">
            <expr if_expr="$this.edge_aligned_mode.getValue() == `kFTM_InputCapture`">$this.input_capture.enable_chan_irq.getValue() ? $this.input_capture.chan_interrupt.getValue() : ``</expr>
            <expr if_expr="$this.edge_aligned_mode.getValue() == `kFTM_DualEdgeCapture`">($this.dual_edge_capture.enable_chan_irq.getValue() &amp;&amp; $this.dual_edge_capture.enable_chan1_irq.getValue()) ? ($this.dual_edge_capture.chan_interrupt.getValue() + `|` + $this.dual_edge_capture.chan1_interrupt.getValue()) : $this.dual_edge_capture.enable_chan_irq.getValue() ? $this.dual_edge_capture.chan_interrupt.getValue() : $this.dual_edge_capture.enable_chan1_irq.getValue() ? $this.dual_edge_capture.chan1_interrupt.getValue() : ``</expr>
            <expr if_expr="$this.edge_aligned_mode.getValue() == `kFTM_OutputCompare`">$this.output_compare.enable_chan_irq.getValue() ? $this.output_compare.chan_interrupt.getValue() : ``</expr>
            <expr if_expr="$this.edge_aligned_mode.getValue() == `kFTM_EdgeAlignedPwm`">$this.edge_aligned_pwm.enable_chan_irq.getValue() ? $this.edge_aligned_pwm.chan_interrupt.getValue() : ``</expr>
            <expr if_expr="$this.edge_aligned_mode.getValue() == `kFTM_CombinedPwm`">($this.combined_pwm.enable_chan_irq.getValue() &amp;&amp; $this.combined_pwm.enable_chan1_irq.getValue()) ? ($this.combined_pwm.chan_interrupt.getValue() + `|` + $this.combined_pwm.chan1_interrupt.getValue()) : $this.combined_pwm.enable_chan_irq.getValue() ? $this.combined_pwm.chan_interrupt.getValue() : $this.combined_pwm.enable_chan1_irq.getValue() ? $this.combined_pwm.chan1_interrupt.getValue() : `` </expr>
            <expr> ($param._last ? `` : ` | `) </expr>
         </def>
         <def fragment="ftm_enable_interrupts"> <!-- it is an array of structures -->
            <expr>
               leftPadding(`FTM_EnableInterrupts(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`) + `, `, 1) 
            </expr>
            <fragment id="channel_interrupts" for_elements_of="$this.filter(item -> ((item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_InputCapture`) &amp;&amp; (item.getSetting(`input_capture.enable_chan_irq`).getValue())) || 
                                                                                    ((item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_DualEdgeCapture`) &amp;&amp; (item.getSetting(`dual_edge_capture.enable_chan_irq`).getValue() || item.getSetting(`dual_edge_capture.enable_chan1_irq`).getValue())) || 
                                                                                    ((item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_OutputCompare`) &amp;&amp; (item.getSetting(`output_compare.enable_chan_irq`).getValue())) || 
                                                                                    ((item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_EdgeAlignedPwm`) &amp;&amp; (item.getSetting(`edge_aligned_pwm.enable_chan_irq`).getValue())) || 
                                                                                    ((item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_CombinedPwm`) &amp;&amp; (item.getSetting(`combined_pwm.enable_chan_irq`).getValue() || item.getSetting(`combined_pwm.enable_chan1_irq`).getValue())))"/>
            <expr if_expr="($this.searchInArray(item -> ((item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_InputCapture`) &amp;&amp; (item.getSetting(`input_capture.enable_chan_irq`).getValue())) || 
               ((item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_DualEdgeCapture`) &amp;&amp; (item.getSetting(`dual_edge_capture.enable_chan_irq`).getValue() || item.getSetting(`dual_edge_capture.enable_chan1_irq`).getValue())) || 
                                                 ((item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_OutputCompare`) &amp;&amp; (item.getSetting(`output_compare.enable_chan_irq`).getValue())) || 
                                                 ((item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_EdgeAlignedPwm`) &amp;&amp; (item.getSetting(`edge_aligned_pwm.enable_chan_irq`).getValue())) || 
                                                 ((item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_CombinedPwm`) &amp;&amp; (item.getSetting(`combined_pwm.enable_chan_irq`).getValue() || item.getSetting(`combined_pwm.enable_chan1_irq`).getValue()))  ) >= 0) &amp;&amp;
                            ($instance.ftm_main_config.timer_interrupts.getCValue() != ``)">` | `</expr>
            <expr>$instance.ftm_main_config.timer_interrupts.getCValue()</expr>
            <expr>   
               `);` 
            </expr><br/>
         </def>
      </fragment_defs>
      <code>
         <section target="defines">
            <fragment id="channel_define" for_elements_of="$this.ftm_edge_aligned_channels_config"/>
         </section> 
         <section target="global_vars">
            <fragment id="ftm_edge_aligned_channels_struct" apply_to="$this.ftm_edge_aligned_channels_config">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_edgeAlignedConfig`"></param>
               <param id="type" >ftm_edge_aligned_channels_config_t</param>
            </fragment>
            <fragment id="pwm_channels_struct" apply_to="$this.ftm_edge_aligned_channels_config" if_expr="$this.ftm_edge_aligned_channels_config.searchInArray(item -> (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_EdgeAlignedPwm`)) >= 0">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_pwmSignalParams`"></param>
               <param id="type" >ftm_chnl_pwm_config_param_t</param>
            </fragment>
            <fragment id="combined_pwm_channels_struct" apply_to="$this.ftm_edge_aligned_channels_config" if_expr="$this.ftm_edge_aligned_channels_config.searchInArray(item -> (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_CombinedPwm`) &amp;&amp; (item.getSetting(`combined_pwm.enableComplementary`).getValue() == false)) >= 0">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_combinedPwmSignalParams`"></param>
               <param id="type" >ftm_chnl_pwm_config_param_t</param>
               <param id="complementaryMode">false</param>
            </fragment>
            <fragment id="combined_pwm_channels_struct" apply_to="$this.ftm_edge_aligned_channels_config" if_expr="$this.ftm_edge_aligned_channels_config.searchInArray(item -> (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_CombinedPwm`) &amp;&amp; (item.getSetting(`combined_pwm.enableComplementary`).getValue() == true)) >= 0">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_complementaryPwmSignalParams`"></param>
               <param id="type" >ftm_chnl_pwm_config_param_t</param>
               <param id="complementaryMode">true</param>
            </fragment>
         </section>
         <section target="global_vars_extern">
         </section>
         <section target="init_function_body">
            <!-- The FTM_SetTimerPeriod function muts be called before configuration of channels becuase the modulo value is used in some modes. -->
            <fragment id="ftm_set_timer_period_init"/>
               <!-- Initialization functions for Input Capture, Output Compare and Dual Edge modes -->
            <fragment id="ftm_edge_aligned_channels_init" apply_to="$this.ftm_edge_aligned_channels_config"></fragment>
            <!-- PWM channels initialization function -->
            <fragment id="pwm_channels_init" apply_to="$this.ftm_edge_aligned_channels_config" if_expr="$this.ftm_edge_aligned_channels_config.searchInArray(item -> (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_EdgeAlignedPwm`)) >= 0">
               <param id="struct_name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_pwmSignalParams`"></param>
               <param id="number_of_channels" expr="`sizeof(` + $instance.getFnGroupPrefix() + $instance.getID() + `_pwmSignalParams` + `) / sizeof(ftm_chnl_pwm_config_param_t)`"></param> <!-- Note: $this expression here corespond to the expression apply_to="$this.ftm_edge_aligned_channels_config" above  -->
            </fragment>
            <!-- Combined PWM modes initialization functions -->
            <fragment id="combined_pwm_channels_init" apply_to="$this.ftm_edge_aligned_channels_config" if_expr="$this.ftm_edge_aligned_channels_config.searchInArray(item -> (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_CombinedPwm`) &amp;&amp; (item.getSetting(`combined_pwm.enableComplementary`).getValue() == false)) >= 0">
               <param id="struct_name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_combinedPwmSignalParams`"></param>
               <param id="number_of_channels" expr="`sizeof(` + $instance.getFnGroupPrefix() + $instance.getID() + `_combinedPwmSignalParams` + `) / sizeof(ftm_chnl_pwm_config_param_t)`"></param> <!-- Note: $this expression here corespond to the expression apply_to="$this.ftm_edge_aligned_channels_config" above  -->
               <param id="combinedMode">kFTM_CombinedPwm</param>
            </fragment>
            <fragment id="combined_pwm_channels_init" apply_to="$this.ftm_edge_aligned_channels_config" if_expr="$this.ftm_edge_aligned_channels_config.searchInArray(item -> (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_CombinedPwm`) &amp;&amp; (item.getSetting(`combined_pwm.enableComplementary`).getValue() == true)) >= 0">
               <param id="struct_name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_complementaryPwmSignalParams`"></param>
               <param id="number_of_channels" expr="`sizeof(` + $instance.getFnGroupPrefix() + $instance.getID() + `_complementaryPwmSignalParams` + `) / sizeof(ftm_chnl_pwm_config_param_t)`"></param> <!-- Note: $this expression here corespond to the expression apply_to="$this.ftm_edge_aligned_channels_config" above  -->
               <param id="combinedMode">kFTM_ComplementaryPwm</param>
            </fragment>
            <fragment id="combined_pwm_deadtime_init" for_elements_of="$this.ftm_edge_aligned_channels_config.filter(item -> (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_CombinedPwm`))" if_expr="$this.ftm_edge_aligned_channels_config.searchInArray(item -> (item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_CombinedPwm`)) >= 0">
               <param id="struct_name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_complementaryPwmSignalParams`"></param>
               <param id="channel" expr="$this.combined_pwm.chnlNumber.getValue()"></param> 
               <param id="deadtime" expr="$this.combined_pwm.enableDeadtime.getValue()"></param>
            </fragment>
            <!-- Enable interrupts of timer and channels -->
            <fragment id="ftm_enable_interrupts" apply_to="$this.ftm_edge_aligned_channels_config" if_expr="($this.ftm_edge_aligned_channels_config.searchInArray(item -> (((item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_InputCapture`) &amp;&amp; (item.getSetting(`input_capture.enable_chan_irq`).getValue())) || 
               ((item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_DualEdgeCapture`) &amp;&amp; (item.getSetting(`dual_edge_capture.enable_chan_irq`).getValue() || item.getSetting(`dual_edge_capture.enable_chan1_irq`).getValue())) || 
               ((item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_OutputCompare`) &amp;&amp; (item.getSetting(`output_compare.enable_chan_irq`).getValue())) || 
               ((item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_EdgeAlignedPwm`) &amp;&amp; (item.getSetting(`edge_aligned_pwm.enable_chan_irq`).getValue())) || 
               ((item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_CombinedPwm`) &amp;&amp; (item.getSetting(`combined_pwm.enable_chan_irq`).getValue() || item.getSetting(`combined_pwm.enable_chan1_irq`).getValue()))  )) >= 0) ||
               ($instance.ftm_main_config.timer_interrupts.getCValue() != ``)">
            </fragment>
         </section>
      </code>
      <quick_selections>
         <quick_selection id="default" label="Default">
            <set id="ftm_edge_aligned_channels_config">0</set>
         </quick_selection>
         <quick_selection id="inputCapture" label="Input capture">
            <set id="ftm_edge_aligned_channels_config.0.channelId">Input_capture</set>
            <set id="ftm_edge_aligned_channels_config.0.edge_aligned_mode">kFTM_InputCapture</set>
            <set id="ftm_edge_aligned_channels_config.0.input_capture.input_capture_edge">kFTM_FallingEdge</set>
            <set id="ftm_edge_aligned_channels_config.0.input_capture.inputFilterPeriod">1</set>
         </quick_selection>
         <quick_selection id="dualEdgeCapture" label="Dual edge capture">
            <set id="ftm_edge_aligned_channels_config.0.channelId">Dual_capture</set>
            <set id="ftm_edge_aligned_channels_config.0.edge_aligned_mode">kFTM_DualEdgeCapture</set>
            <set id="ftm_edge_aligned_channels_config.0.dual_edge_capture.dual_edge_capture_param.mode">kFTM_OneShot</set>
            <set id="ftm_edge_aligned_channels_config.0.dual_edge_capture.dual_edge_capture_param.currChanEdgeMode">kFTM_RisingEdge</set>
            <set id="ftm_edge_aligned_channels_config.0.dual_edge_capture.dual_edge_capture_param.nextChanEdgeMode">kFTM_FallingEdge</set>
            <set id="ftm_edge_aligned_channels_config.0.dual_edge_capture.inputFilterPeriod">1</set>
         </quick_selection>
         <quick_selection id="outputCompare" label="Output compare">
            <set id="ftm_edge_aligned_channels_config.0.channelId">Output_compare</set>
            <set id="ftm_edge_aligned_channels_config.0.edge_aligned_mode">kFTM_OutputCompare</set>
            <set id="ftm_edge_aligned_channels_config.0.output_compare.output_compare_mode">kFTM_ToggleOnMatch</set>
            <set id="ftm_edge_aligned_channels_config.0.output_compare.compareValueStr">0</set>
         </quick_selection>
         <quick_selection id="pwmTwoChannels" label="Two PWM channels">
            <set id="ftm_edge_aligned_channels_config.0.channelId">pwm_0</set>
            <set id="ftm_edge_aligned_channels_config.0.edge_aligned_mode">kFTM_EdgeAlignedPwm</set>
            <set id="ftm_edge_aligned_channels_config.0.edge_aligned_pwm.level">kFTM_HighTrue</set>
            <set id="ftm_edge_aligned_channels_config.0.edge_aligned_pwm.chnlNumber">kFTM_Chnl_0</set>
            <set id="ftm_edge_aligned_channels_config.0.edge_aligned_pwm.dutyValueStr">1000</set>
            <set id="ftm_edge_aligned_channels_config.1.channelId">pwm_1</set>
            <set id="ftm_edge_aligned_channels_config.1.edge_aligned_mode">kFTM_EdgeAlignedPwm</set>
            <set id="ftm_edge_aligned_channels_config.1.edge_aligned_pwm.level">kFTM_HighTrue</set>
            <set id="ftm_edge_aligned_channels_config.1.edge_aligned_pwm.chnlNumber">kFTM_Chnl_1</set>
            <set id="ftm_edge_aligned_channels_config.1.edge_aligned_pwm.dutyValueStr">1000</set>
         </quick_selection>
         <quick_selection id="combinedPWM" label="Combined PWM">
            <set id="ftm_edge_aligned_channels_config.0.channelId">pwm</set>
            <set id="ftm_edge_aligned_channels_config.0.edge_aligned_mode">kFTM_CombinedPwm</set>
            <set id="ftm_edge_aligned_channels_config.0.combined_pwm.level">kFTM_HighTrue</set>
            <set id="ftm_edge_aligned_channels_config.0.combined_pwm.firstEdgeValueStr">100</set>
            <set id="ftm_edge_aligned_channels_config.0.combined_pwm.dutyValueStr">1000</set>
            <set id="ftm_edge_aligned_channels_config.0.combined_pwm.enableComplementary">true</set>
         </quick_selection>
         <default>default</default>
      </quick_selections>
   </config_set>
   
   <config_set id="ftm_center_aligned_mode" label="FlexTimer Center-aligned mode" from_source="fsl_ftm.h">
      <description>FlexTimer center aligned mode configuration.</description>
      <generated_types>
      </generated_types>
      <user_types>
         <struct id="ftm_chnl_pwm_config_param_t" label="Options to configure a FTM channel using precise setting" from="_ftm_chnl_pwm_config_param">
            <description>Options for configuration of a FTM channel as PWM output by using the center aligned PWM mode.</description>
            <string id="channelId" label="Channel ID" options="remove_from_struct_init">
               <description>Custom channel identifier of the channel that is used for the channel definition in generated header file. When empty ID is used the definition is not generated in the header file.</description>
               <validation>
                  <constraint when_expr="$this.value() != ``" cond_expr="$this.value().isCIdentifier()" level="error" description_expr="`Name ` + $this.value() + ` is not a valid identifier.`"/>
                  <constraint when_expr="$this.value() != ``" cond_expr="$components.system.#global.duplicit_ids.getValue().noneMatch(x -> (x.getValue() == $parent.channelFullId.getValue()))" level="warning" description_expr="`Custom channel ID &quot;` + $this.getValue() + `&quot; is a duplicate. The ` + $parent.channelFullId.getValue() + ` definition name is already used in this project.`"/>
               </validation>
            </string>
            <variable id="channelFullId" value="($parent.channelId.getValue()!= ``) ? (toUpperCase($instance.ftm_main_config.inst_ID_def.getValue() + `_` + $parent.channelId.getValue()) + `_CHANNEL`) : ``">
               <options_expr>
                  <option id="id_check" available="$this.getValue() != ``"/>
               </options_expr>
            </variable>
            <reference id="chnlNumber" label="Channel number" type="ftm_chnl_t" config_set_id="fsl_ftm">
               <description>The FTM channel number.</description>
               <validation>
                  <dependency when_expr="$parent.level.getValue() != `kFTM_NoPwmSignal`"  resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_ch.` +  $this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1)" description_expr="`Signal CH` + $this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1) + ` of peripheral ` + $instance.getPeripheral() + ` is not routed`" level="Warning">
                     <feature name="routed" evaluation="equal">
                        <data expr="true"/>
                     </feature>
                  </dependency>
                  <dependency when_expr="$parent.level.getValue() != `kFTM_NoPwmSignal`" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_ch.` +  $this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1)" description_expr="`Direction of signal CH` + $this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1) + ` of peripheral ` + $instance.getPeripheral() + ` is set as input but it will be used as output`" level="Warning">
                     <feature name="direction" evaluation="notEqualIgnoreCase">
                        <data expr="`INPUT`"/>
                     </feature>
                  </dependency>
                  <constraint cond_expr="featureDefined(`FTM_CHANNEL_COUNT`) &amp;&amp; ($this.getValue().regexSubstr(`.*Chnl_(\d+)`, 1).toInt() &lt; getFeature(`FTM_CHANNEL_COUNT`))" level="error" description="You must select an existing channel of the selected FTM device (see the Number of channel property of this component)"/>
               </validation>
            </reference>
            <reference id="level" label="PWM output active level" type="ftm_pwm_level_select_t" config_set_id="fsl_ftm">
               <description>PWM output active level selection.</description>
            </reference>
            <string id="dutyValueStr" label="Duty cycle" options="remove_from_struct_init" 
               validation_expr="x -> system::validateValuePeriodDuty(x,0,0x1FFFE)">
               <description>
Selection of the PWM pulse width (duty cycle) in time units, number of ticks of the timer/counter, percent number. Supported formats of values:
* An integer number is processed as a number of ticks; range 0 - 131070 (0x1FFFE) (even numbers are supported in the center aligned mode only).
* A float number + % (float_number%) is processed as a percentage of the duty cycle; range 0 - 100.0%. Float number can written also as a fraction, for example 13/17%. Exponent format of the float number is not supported.
* A period value must be in format &quot;float_number [ns, us, ms, s, m, h or d]&quot;.

Frequency units and time units can only be used when clock source frequency is selected (clock must not be disabled or runtime calculated by the CLOCK_GetFreq()).
               </description>
               <validation>
                  <constraint when_expr="$parent.dutyValue.getValue().isInt() &amp;&amp; $instance.ftm_main_config.ftm_config.timerModuloValue.getValue().isInt()" cond_expr="($parent.dutyValue.getValue().toInt() &lt;= $instance.ftm_main_config.ftm_config.timerModuloValue.getValue()) &amp;&amp; ($parent.dutyValue.getValue().toInt() &gt;= 0)"  
                     level="error" description_expr="`The Duty width value must be in the range 0 - ` + $instance.ftm_main_config.ftm_config.timerModuloValue.getValue() + ` ticks (timer modulo value) that specify the maximum value of match register value. Adjust the timer frequency/period and/or the timer input frequency.`"/>
                  <constraint cond_expr="$parent.dutyValue.getValue().isInt()"  
                     level="error" description_expr="`The Duty value cannot be calculated due to missing specification of the input frequency. Select the timer input frequency or set the duty cycle in timer ticks.`"/>
               </validation>
            </string>
            <!-- The dutyValuePeriod is the whole period of the PWM duty that is doubled in the centered mode (timer count up and down) -->
            <variable id="dutyValuePeriod" value="system::getDutyCycleValue($parent.dutyValueStr.getValue(), $instance.ftm_main_config.ftm_config.timerModuloDividerValue.getValue(), $instance.ftm_main_config.ftm_config.timerInputFreq.getValue())"/>
            <!-- The duty cycle value that correspond to the register value - it is a half of the period in the centered mode. -->
            <variable id="dutyValue" value="$parent.dutyValuePeriod.getValue().isInt() ? ($parent.dutyValuePeriod.getValue() / 2) : `N/A`" options="add_to_struct"/>
            <info id="calculatedDutyPeriod" label="Calculated duty cycle" 
               value="system::calculateTicksPeriod($parent.dutyValue.getValue().isInt() ? ($parent.dutyValue.getValue() * 2) : `N/A`, $instance.ftm_main_config.ftm_config.timerInputFreq.getValue())">
               <description>Calculated duty width in timer ticks and time period. Calculation is based on the supported values of the channel match register and maximum value that is limited by the timer modulo value.</description>
            </info>
            <bool id="enable_chan_irq" label="Enable channel interrupt" options="remove_from_struct_init"/>
            <variable  id="chan_interrupt" available="$parent.enable_chan_irq.getValue()" value="`kFTM_Chnl` + $parent.chnlNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1)  + `InterruptEnable`"></variable>
         </struct>
         <reference id="center_aligned_pwm" label="Center-aligned PWM settings" type="ftm_chnl_pwm_config_param_t">
            <validation>
               <!-- constraint for checking of duplicated channels -->
               <constraint cond_expr="($parent.searchInArray(item -> (($this.getID() != item.getID()) &amp;&amp; 
                                      ((item.getSetting(`chnlNumber`).getValue())  ==  ($this.chnlNumber.getValue())))) &lt; 0)" level="warning" 
                                      description_expr="`Duplicated channel (` + $this.chnlNumber.getEnumItemLabel() + `) is selected. Select each channel once only.`"/>
            </validation>
         </reference>
      </user_types>
      <settings>
         <array id="ftm_center_aligned_channels_config" label="Channels" type="center_aligned_pwm" options="UI_SHOW_CONTENT_AS=MASTER_DETAIL" key_selector_expr="x ->  (x.getSetting(`channelId`).getValue() != ``) ? x.getSetting(`channelId`).getValue() : x.getSetting(`chnlNumber`).getEnumItemLabel()">
            <description>Configuration of the FTM channels in the edge-eligned mode.</description>
            <item_defaults>
               <set_default id="dutyValueStr" value_expr="x -> 0"/>
            </item_defaults>            
         </array>
         <!-- Variables used for reloadPoints verification; it return list of channels that provide the match event occurrence (output compare or a PWM mode). -->
         <variable value="$parent.ftm_center_aligned_channels_config.map(item -> item.getSetting(`chnlNumber`).getValue().regexSubstr(`.*Chnl_(\d+)`, 1))" id="ChanMatchInit"></variable>
      </settings>
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="common_code_templates"/>
         </import>
         <def fragment="channel_define">
            <fragment id="define" if_expr="$this.channelId.getValue() != ``">
               <param id="name" expr="$this.channelFullId.getValue()"/>
               <param id="value" expr="$this.chnlNumber.getCValue()"/>
               <param id="description" expr="`Definition of ` + $instance.getPeripheral() + ` channel number ` + $this.chnlNumber.getValue().regexSubstr(`.*Chnl_(\d+)`, 1)"/>
            </fragment>
         </def>
         <def fragment="ftm_edge_aligned_channels_struct"> <!-- it is an array of structures -->
            <fragment id="channel_struct" for_elements_of="$this" >     <!-- apply in context of each iten in the set/structure/array -->      
            </fragment>
            <br/>
         </def>
         <!-- Init functions -->
         <!-- PWM channels signal params configuration as an array of the ftm_chnl_pwm_config_param_t structures -->         
         <def fragment="center_pwm_channel_struct">
            <expr>leftPadding(`{`,1)</expr><br/>
            <fragment id="field" for_elements_of="$this">
                  <param id="paddingLevel" expr="2"></param>
            </fragment>
            <expr>leftPadding(`}`,1)</expr>
            <expr> ($param._last ? ``: `,`) </expr><br/>
         </def>
         <def fragment="center_pwm_channels_struct"> <!-- it is an array of structures -->
            <expr>`const ` + $param.type + ` ` + $param.name + `[] = { `</expr><br/>
            <fragment id="center_pwm_channel_struct" for_elements_of="$this">      
            </fragment>
            <text>};</text>
            <br/>
         </def>
         <def fragment="center_pwm_channels_init"> <!-- it is an array of structures -->
            <expr>
               leftPadding(`FTM_SetupPwmMode(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`) + `, ` + 
               $param.struct_name + `, ` + 
               + $param.number_of_channels + `, ` +
               + `kFTM_CenterAlignedPwm);`, 1) 
            </expr><br/>
         </def>
         <!-- Enable interrupts of channels and timer -->
         <def fragment="channel_interrupts">
            <expr>$this.enable_chan_irq.getValue() ? $this.chan_interrupt.getValue() : ``</expr>
            <expr> ($param._last ? `` : ` | `) </expr>
         </def>
         <def fragment="ftm_enable_interrupts"> <!-- it is an array of structures -->
            <expr>
               leftPadding(`FTM_EnableInterrupts(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`) + `, `, 1) 
            </expr>
            <fragment id="channel_interrupts" for_elements_of="$this.filter(item -> (item.getSetting(`enable_chan_irq`).getValue()))"/>
            <expr if_expr="( ($this.searchInArray(item -> (item.getSetting(`enable_chan_irq`).getValue())) >= 0) &amp;&amp;
                                                  ($instance.ftm_main_config.timer_interrupts.getCValue() != ``))">` | `</expr>
            <expr>$instance.ftm_main_config.timer_interrupts.getCValue()</expr>
            <expr>   
               `);` 
            </expr><br/>
         </def>
         <def fragment="ftm_set_timer_period_init">
            <expr>
               leftPadding(`FTM_SetTimerPeriod(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`) + `, ` + $instance.ftm_main_config.timerModuloDefId.getValue() + `);`, 1) 
            </expr><br/>
         </def>
      </fragment_defs>
      <code>
         <section target="defines">
            <fragment id="channel_define" for_elements_of="$this.ftm_center_aligned_channels_config"/>
         </section> 
         <section target="global_vars">
            <fragment id="center_pwm_channels_struct" apply_to="$this.ftm_center_aligned_channels_config" if_expr="$this.ftm_center_aligned_channels_config.length() &gt; 0">
               <!--               <fragment id="pwm_channels_struct" apply_to="$this.ftm_edge_aligned_channels_config" if_expr="$this.ftm_edge_aligned_channels_config.searchInArray($item.getSetting(`edge_aligned_mode`).getValue() == `kFTM_EdgeAlignedPwm`)">-->
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_centerPwmSignalParams`"></param>
               <param id="type" >ftm_chnl_pwm_config_param_t</param>
            </fragment>
         </section>
         <section target="global_vars_extern">
         </section>
         <section target="init_function_body">
            <!-- The FTM_SetTimerPeriod function muts be called before configuration of channels becuase the modulo value is used in some modes. -->
            <fragment id="ftm_set_timer_period_init"/>
            <!-- Center PWM channels initialization function -->
            <fragment id="center_pwm_channels_init" apply_to="$this.ftm_center_aligned_channels_config" if_expr="$this.ftm_center_aligned_channels_config.length() &gt; 0">
               <param id="struct_name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_centerPwmSignalParams`"></param>
               <param id="number_of_channels" expr="`sizeof(` + $instance.getFnGroupPrefix() + $instance.getID() + `_centerPwmSignalParams` + `) / sizeof(ftm_chnl_pwm_config_param_t)`"></param> <!-- Note: $this expression here corespond to the expression apply_to="$this.ftm_edge_aligned_channels_config" above  -->
            </fragment>
            <!-- Enable interrupts of timer and channels -->
            <fragment id="ftm_enable_interrupts" apply_to="$this.ftm_center_aligned_channels_config" if_expr="($this.ftm_center_aligned_channels_config.searchInArray(item -> (item.getSetting(`enable_chan_irq`).getValue())) >= 0) || ($instance.ftm_main_config.timer_interrupts.getCValue() != ``)">
            </fragment>
         </section>
      </code>
      <quick_selections>
         <quick_selection id="default" label="Default">
            <set id="ftm_edge_aligned_channels_config">0</set>
         </quick_selection>
         <quick_selection id="centerPWM" label="Center PWM">
            <set id="ftm_center_aligned_channels_config.0.channelId">pwm</set>
            <set id="ftm_center_aligned_channels_config.0.level">kFTM_HighTrue</set>
            <set id="ftm_center_aligned_channels_config.0.dutyValueStr">1000</set>
         </quick_selection>
         <default>default</default>
      </quick_selections>
   </config_set>
   <config_set id="ftm_quadrature_decoder_mode" label="FlexTimer Quadrature Decoder Mode" from_source="fsl_ftm.h">
      <description>FlexTimer quadrature decoder mode configuration.</description>
      <generated_types>
      </generated_types>
      <user_types>
         <struct id="ftm_phase_params_t" label="FlexTimer quadrature decoder phase parameters." from="_ftm_phase_param">
            <bool id="enablePhaseFilter" label="Enable phase filter">
               <description>Eenable phase filter of quadrature decoder inputs</description>
            </bool>
            <string id="phaseFilterPeriod" label="Filter period" options="remove_from_struct_init" 
               validation_expr="x -> system::validateValueFreqPeriod(x, 1, 16)">
               <description>
The phase filter sampling period value in number of filter clock cycles (range 1-16), frequency units or time units. This period is used for sampling of the timer input signal. When the value 1 is selected the filter is bypassed.

An integer number in range 1 - 16 (0x10) is processed as a value in ticks of filter clock period, a frequency value must be in format &quot;float_number [Hz, kHz, MHz or GHz]&quot;, a period value must be in format &quot;float_number [ns, us, ms, s, m, h or d]&quot;.
Frequency units and time units can only be used when clock source frequency is selected (clock must not be disabled/calculated in runtime).

When the the minimum value 1 is selected (zero value of the register bitfield) the filter is disabled and the minimum pulse width (filter sampling period) is one filter clock period.
               </description>
               <validation>
                  <constraint when_expr="$parent.phaseFilter.getValue() != `N/A`" cond_expr="($parent.phaseFilter.getValue().toInt() &lt;= 16) &amp;&amp; ($parent.phaseFilter.getValue().toInt() &gt; 0)"  level="error" description="The filter sampling period in ticks must be in the range 1 - 16 (0x10)."/>
                  <constraint cond_expr="$parent.phaseFilter.getValue() != `N/A`"   level="error" description="A valid value of filter sampling period must be specified. When the filter frequency is not specified the filter sampling period must be specified as an integer number 1 - 16."/>
               </validation>
            </string>
            <variable id="phaseFilter" value="system::getIntDividerValue($parent.phaseFilterPeriod.getValue(), $instance.ftm_main_config.ftm_config.filterClockFreqValue.getValue())" options="add_to_struct"/>
            <!-- Phase filter value that is used as paramter (value of the register bitfield) -->
            <variable id="phaseFilterVal" value="$parent.phaseFilter.getValue().isInt() ? ($parent.phaseFilter.getValue().toInt() - 1) : 0 " options="add_to_struct"/>
            <info id="phaseFilterPeriod_info" label="Calculated filter period" 
               value=" system::calculateTicksFreqPeriod($parent.phaseFilter.getValue(), $instance.ftm_main_config.ftm_config.filterClockFreqValue.getValue())">
               <description>The calculated phase filter sampling period in number of ticks of the filter clock cycles, sampling frequency and time period.</description>
            </info>
            <reference id="phasePolarity" label="Phase polarity" type="ftm_phase_polarity_t" config_set_id="fsl_ftm">
               <description>Phase polarity</description>
            </reference>
         </struct>
      </user_types>
      <settings>
         <!-- Quadrature decoder mode - modulo value -->
         <integer type="uint16_t" id="timerModuloVal" label="Timer modulo value" min_expr="1">
            <description>Timer modulo value (16 bits unsigned integer) that is used in the quadrature decoder mode of the FTM device.</description>
         </integer>
         <!-- Quadrature decoder mode - initial value of the timer-->
         <integer type="uint16_t" id="timerInitVal" label="Timer initial value">
            <description>Initial value of the timer (16 bits unsigned integer) that is used in the quadrature decoder mode of the FTM device.</description>
         </integer>
         <reference id="ftm_quad_decoder_mode" label="FTM Quadrature Decoder Mode" type="ftm_quad_decode_mode_t" config_set_id="fsl_ftm">
            <description>Quadrature decoder mode</description>
         </reference>
         <reference id="ftm_phase_a_params" label="FTM Phase A Parameters" type="ftm_phase_params_t">
            <description>Phase A parameters configuration.</description>
            <validation>
<!--               <dependency when_expr="queryFeature()" resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_qd_ph.A`" description_expr="`Quadrature decoder phase A signal needs to be routed`" level="Warning">-->
                <dependency resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_qd_ph.A`" description_expr="`Quadrature decoder phase A signal is not supported for the device ` + $instance.getPeripheral()" level="Warning">
                     <feature name="exists" evaluation="equal">
                     <data expr="true"/>
                  </feature>
               </dependency>
               <dependency resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_qd_ph.A`" description_expr="`Quadrature decoder phase A signal is not routed (` + $instance.getPeripheral() + ` device).`" level="Warning">
                  <feature name="routed" evaluation="equal">
                     <data expr="true"/>
                  </feature>
               </dependency>
            </validation>
         </reference>
         <reference id="ftm_phase_b_params" label="FTM Phase B Parameters" type="ftm_phase_params_t">
            <description>Phase B parameters configuration.</description>
            <validation>   
               <dependency resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_qd_ph.B`" description_expr="`Quadrature decoder phase B signal is not supported for the device ` + $instance.getPeripheral()" level="Warning">
                  <feature name="exists" evaluation="equal">
                     <data expr="true"/>
                  </feature>
               </dependency>
               <dependency resource_type="PeripheralUnifiedSignal" resource_id_expr="$instance.getPeripheral() + `.tmr_qd_ph.B`" description_expr="`Quadrature decoder phase B signal is not routed (` + $instance.getPeripheral() + ` device).`" level="Warning">
                  <feature name="routed" evaluation="equal">
                     <data expr="true"/>
                  </feature>
               </dependency>
           </validation>
         </reference>
      </settings>
      <fragment_defs>
         <import>
            <from component_id="system" config_set_id="common_code_templates"/>
         </import>
         <def fragment="ftm_quad_decoder_struct"> <!-- it is an array of structures -->
            <fragment id="channel_struct" for_elements_of="$this" >     <!-- apply in context of each iten in the set/structure/array -->      
            </fragment>
            <br/>
         </def>
         <!-- Init functions -->
         <def fragment="quad_decoder_struct_items">
            <fragment id="field" apply_to="$this.enablePhaseFilter">
               <param id="paddingLevel" expr="1"></param>
               <param id="_last" expr="false"></param> <!-- define the _last parameter because one item of the structer is applied only -->
            </fragment>
            <fragment id="field" apply_to="$this.phaseFilterVal" if_expr="$this.enablePhaseFilter.getValue()">
               <param id="paddingLevel" expr="1"></param>
               <param id="_last" expr="false"></param> <!-- define the _last parameter because one item of the structer is applied only -->
            </fragment>
            <fragment id="field" apply_to="$this.phasePolarity">
               <param id="paddingLevel" expr="1"></param>
               <param id="_last" expr="true"></param> <!-- define the _last parameter because one item of the structer is applied only -->
            </fragment>
            <br/>
         </def>
         <def fragment="quad_decoder_struct"> 
            <expr>`const ` + $param.type + ` ` + $param.name + ` = { `</expr><br/>
            <fragment id="quad_decoder_struct_items" apply_to="$this"/>       
            <text>};</text>
            <br/>
         </def>
         <def fragment="quad_decoder_init"> <!-- it is an array of structures -->
            <expr>
               leftPadding(`FTM_SetupQuadDecode(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`) + `, ` + 
               `&amp;` + $param.struct_phase_A_name + `, ` + 
               `&amp;` + $param.struct_phase_B_name + `, ` + 
               + $param.quad_mode + `);`, 1) 
            </expr><br/>
         </def>
         <def fragment="quad_decoder_modulo_value"> <!-- it is an array of structures -->
            <text>/* Initialization of the timer initial value and modulo value */</text><br/>
            <expr>
               leftPadding(`FTM_SetQuadDecoderModuloValue(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`) + `, ` + 
               + $this.timerInitVal.getValue() + `,` + 
               + $this.timerModuloVal.getValue() + `);`, 1) 
            </expr><br/>
         </def>
         <def fragment="ftm_enable_interrupts">
            <expr>
               leftPadding(`FTM_EnableInterrupts(` + toUpperCase($instance.getFnGroupPrefix() + $instance.getID() + `_PERIPHERAL`) + `, `, 1) + 
               (($instance.ftm_main_config.timer_interrupts.getCValue() != ``) ? $instance.ftm_main_config.timer_interrupts.getCValue() : `0`) + `);` 
            </expr><br/>
         </def>
      </fragment_defs>
      <code>
         <section target="defines">
         </section> 
         <section target="global_vars">
            <fragment id="quad_decoder_struct" apply_to="$this.ftm_phase_a_params">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_phaseAParams`"></param>
               <param id="type" >ftm_phase_params_t</param>
            </fragment>
            <fragment id="quad_decoder_struct" apply_to="$this.ftm_phase_b_params">
               <param id="name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_phaseBParams`"></param>
               <param id="type" >ftm_phase_params_t</param>
            </fragment>
         </section>
         <section target="global_vars_extern">
         </section>
         <section target="init_function_body">
            <!-- Quadrature decoder initialization functions -->
            <fragment id="quad_decoder_modulo_value"/>
            <fragment id="quad_decoder_init">
               <param id="struct_phase_A_name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_phaseAParams`"></param>
               <param id="struct_phase_B_name" expr="$instance.getFnGroupPrefix() + $instance.getID() + `_phaseBParams`"></param>
               <param id="quad_mode" expr="$this.ftm_quad_decoder_mode.getCValue()"></param> <!-- Note: $this expression here corespond to the expression apply_to="$this.ftm_edge_aligned_channels_config" above  -->
            </fragment>
            <!-- FTM interrupts initialization -->
            <fragment id="ftm_enable_interrupts" if_expr="$instance.ftm_main_config.timer_interrupts.getCValue() != ``"/>
         </section>
      </code>
      <quick_selections>
         <quick_selection id="default" label="Default">
            <set id="timerModuloVal">0xFFFF</set>
            <set id="ftm_phase_a_params.phaseFilterPeriod">1</set>
            <set id="ftm_phase_b_params.phaseFilterPeriod">1</set>
         </quick_selection>
         <default>default</default>
      </quick_selections>
   </config_set>
</component:config_component>